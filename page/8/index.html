<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Codes Online">
<meta property="og:url" content="http://51codes.top/page/8/index.html">
<meta property="og:site_name" content="Codes Online">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Codes Online">






  <link rel="canonical" href="http://51codes.top/page/8/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Codes Online</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Codes Online</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _enjoying</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/30/kafka-zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/kafka-zookeeper/" itemprop="url">
                  消息中间件kafka+zookeeper集群部署
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-30 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-30T23:47:44+08:00">2017-10-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 19:46:32" itemprop="dateModified" datetime="2017-11-11T19:46:32+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>业务系统中，通常会遇到这些场景：A系统向B系统主动推送一个处理请求；A系统向B系统发送一个业务处理请求，因为某些原因（断电、宕机。。），B业务系统挂机了，A系统发起的请求处理失败；前端应用并发量过大，部分请求丢失或后端业务系统卡死。。。。这个时候，消息中间件就派上用场了–提升系统稳定性、可用性、可扩展性。</p>
<h3 id="一、消息中间件"><a href="#一、消息中间件" class="headerlink" title="一、消息中间件"></a>一、消息中间件</h3><p>消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行–它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。</p>
<p>总体来说，消息中间件有以下作用:<strong>降低耦合、流量消峰（防浪涌）、可靠性传输、事件驱动</strong></p>
<h4 id="1-降低耦合"><a href="#1-降低耦合" class="headerlink" title="1.降低耦合:"></a>1.降低耦合:</h4><p>通过发布订阅的方式松耦合。</p>
<p>我们以注册业务为例，注册成功会发送短信、邮件给用户来确认，传统架构模型是这样：</p>
<p><img src="/2017/10/30/kafka-zookeeper/1.png" alt=""></p>
<p>邮件业务和短信业务的代码是写在用户注册的流程里，无论是通过接口的方式来实现，还是远程调用的方式来实现，耦合度都很高，现在，新增一个需求，用户注册完成以后不发送邮件了，而是给用户“增加积分”，我们来分析这几种情况：</p>
<p>第一、都在一个业务系统内通过代码堆积、接口调用的方式来实现注册成功后的业务处理，我们需要改动注册代码，上线时需要启停应用，这种方式耦合度最高。</p>
<p>第二、通过远程调用的方式，代码类似如下</p>
<p><img src="/2017/10/30/kafka-zookeeper/2.png" alt=""></p>
<p>当我们要新增业务处理时，如下</p>
<p><img src="/2017/10/30/kafka-zookeeper/3.png" alt=""></p>
<p>还是要改动主流程代码，避免不了启停应用。</p>
<p>如果我们引入消息中间件，如下：</p>
<p><img src="/2017/10/30/kafka-zookeeper/4.png" alt=""></p>
<p>通过发布订阅的方式，用户注册成功后，给消息中间件发送一个消息，各个业务端订阅同一个频道的消息，接收到注册成功的消息后就执行相应业务。新增“增加积分”，就让积分系统相关处理订阅这个消息就够了，不用改动用户业务代码，不用启停应用，就可以实现业务的平滑扩展。</p>
<p>CRM中，这种应用场景有很多，再比如，用户回访业务，回访成功后发短信追评、记录历史工单等等，都可以使用消息中间件来送耦合，实现业务的平滑扩展。</p>
<h4 id="2-流量消峰、防浪涌"><a href="#2-流量消峰、防浪涌" class="headerlink" title="2.流量消峰、防浪涌:"></a>2.流量消峰、防浪涌:</h4><p>消息中间件可以在峰值时堆积消息，而在峰值过去后下游系统慢慢消费消息解决流量洪峰的问题</p>
<p>并发量达到高峰时，后端系统压力通常会很大，无论是应用服务器还是数据库服务器，这个时候可以将类似请求放到消息中间件的消息队列中堆积起来慢慢处理，也可以设置消息队列的大小达到控制并发量的目的，商品秒杀的业务场景比较典型，在实际工作中遇到的业务场景也有很多，不一一列举。</p>
<h4 id="3-可靠性传输："><a href="#3-可靠性传输：" class="headerlink" title="3.可靠性传输："></a>3.可靠性传输：</h4><p>基于消息的通信是可靠的，消息不会丢失。</p>
<p>大多数消息中间件都提供将消息持久化到磁盘的功能。开篇的第一个场景中，消息中间件可以将生产者生产的消息持久化到磁盘，后端应用宕机，但消息不会丢失，应用重启继续处理。</p>
<p>你可能会有这样的疑问，那消息中间件宕机了，接收不到消息怎么持久化？没关系，消息中间件提供了多种消息复制策略、持久化策略，集群部署策略等都可以保证消息的可靠性传输。那如果你是个爱钻牛角尖的人，你也许会问，集群中所有的节点都挂了怎么办。。。那如果世界末日了你还在care消息不消息的事情的话只能说明你足够敬业。</p>
<h3 id="4-事件驱动："><a href="#4-事件驱动：" class="headerlink" title="4.事件驱动："></a>4.事件驱动：</h3><p>系统与系统之间可以通过消息传递的形式驱动业务</p>
<p>可以将复杂的应用系统重构成为事件驱动的系统。事件溯源（Event Sourcing），表示一个对象从创建到消亡，会经过的多种状态。如果把对象的状态变化都存储下来，不但可以根据状态变化记录获取对象的当前状态，也可以回溯对象的变化过程。消息中间件能很好地支持这样的系统设计方式，将触发对象状态变化的事件放入消息队列。</p>
<h4 id="5-分布式事务支持"><a href="#5-分布式事务支持" class="headerlink" title="5.分布式事务支持"></a>5.分布式事务支持</h4><p>这个老生常谈的问题了，如果你不明白什么是分布式事务，请移步 www.baidu.com 。</p>
<p>kafka提供了对分布式事务的支持。欲知如何支持，且听下回分解。</p>
<h3 id="二、kafka介绍"><a href="#二、kafka介绍" class="headerlink" title="二、kafka介绍"></a>二、kafka介绍</h3><p>Kafka是由LinkedIn开发的一个分布式的消息系统，使用Scala编写，它以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark都支持与Kafka集成。淘宝的两款消息中间件，notify 和最近被Apache 加冕为顶级开源项目的RocketMQ都有kafka的影子。</p>
<p>总之，它很牛逼。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Kafka 专用术语</span><br><span class="line">Broker：Kafka 集群包含一个或多个服务器，这种服务器被称为 broker。</span><br><span class="line">Topic：每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。</span><br><span class="line">Partition：Partition 是物理上的概念，每个 Topic 包含一个或多个 Partition。</span><br><span class="line">Producer：负责发布消息到 Kafka broker。</span><br><span class="line">Consumer：消息消费者，向 Kafka broker 读取消息的客户端。</span><br><span class="line">Consumer Group：每个 Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）</span><br></pre></td></tr></table></figure></p>
<p>kafka的架构图如下(来自网络)：</p>
<p><img src="/2017/10/30/kafka-zookeeper/5.jpg" alt=""></p>
<h3 id="三、集群部署和测试"><a href="#三、集群部署和测试" class="headerlink" title="三、集群部署和测试"></a>三、集群部署和测试</h3><p>kafka需要一个服务注册中心，你可以选择kafka自带的zookeeper，也可以单独部署。为了更好的管理，笔者单独部署zookeeper集群–其实是个伪集群，一台liux主机开放了三个端口即可。</p>
<p>zookeeper的运行需要jdk，所以先下载安装jdk，本文使用的jdk1.8</p>
<p>1.）下载安装jdk</p>
<p>jdk的安装步骤不做赘述， 笔者的版本是 jdk-8u144-linux-x64.tar.gz</p>
<p>配置环境变量（不会找度娘）</p>
<p>2.）下载zookeeper</p>
<p>先关闭防火墙，或者开放下文中需要用到的所有端口。</p>
<p>移步阿帕奇官网下载最新版zookeeper，</p>
<p>Zookeeper集群的工作是超过半数才能对外提供服务，3台中超过两台超过半数，允许1台挂掉。</p>
<p>创建目录 zookeeper ：</p>
<p>mkdir zookeeper</p>
<p>解压下载后的压缩文件 tar -zxvf zookeeper-3.4.6.tar.gz</p>
<p>拷贝三份：</p>
<p>cp -r zookeeper-3.4.6 zookeeper0</p>
<p>cp -r zookeeper-3.4.6 zookeeper1</p>
<p>cp -r zookeeper-3.4.6 zookeeper2</p>
<p>进入zookeeper目录，其他的两个zookeeper实例同样操作:</p>
<p>创建两个目录zkdata、zkdatalog</p>
<p><img src="/2017/10/30/kafka-zookeeper/6.png" alt=""></p>
<p>进入conf目录，</p>
<p><img src="/2017/10/30/kafka-zookeeper/7.png" alt=""></p>
<p>拷贝zoo_sample.cfg 为zoo.cfg，详细配置如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=<span class="number">10</span></span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=<span class="number">5</span></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir=<span class="regexp">/usr/</span>zookeeper/zookeeper0/zkdata</span><br><span class="line">dataLogDir=<span class="regexp">/usr/</span>zookeeper/zookeeper0/zkdatalog</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=<span class="number">4180</span></span><br><span class="line">server<span class="number">.0</span>=<span class="number">192.168</span><span class="number">.217</span><span class="number">.129</span>:<span class="number">8880</span>:<span class="number">7770</span>    </span><br><span class="line">server<span class="number">.1</span>=<span class="number">192.168</span><span class="number">.217</span><span class="number">.129</span>:<span class="number">8881</span>:<span class="number">7771</span>    </span><br><span class="line">server<span class="number">.2</span>=<span class="number">192.168</span><span class="number">.217</span><span class="number">.129</span>:<span class="number">8882</span>:<span class="number">7772</span> </span><br><span class="line">#server.0 这个0是服务器的标识也可以是其他的数字， 表示这个是第几号服务器，用来标识服务器，这个标识要写到快照目录下面myid文件里</span><br><span class="line">#192.168.217.129为集群里的IP地址，第一个端口是master和slave之间的通信端口</span><br></pre></td></tr></table></figure>
<p>以下是配置文件的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#tickTime：</span><br><span class="line">这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</span><br><span class="line">#initLimit：</span><br><span class="line">这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒</span><br><span class="line">#syncLimit：</span><br><span class="line">这个配置项标识 Leader 与Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是5*2000=10秒</span><br><span class="line">#dataDir：</span><br><span class="line">快照日志的存储路径</span><br><span class="line">#dataLogDir：</span><br><span class="line">事物日志的存储路径，如果不配置这个那么事物日志会默认存储到dataDir制定的目录，这样会严重影响zk的性能，当zk吞吐量较大的时候，产生的事物日志、快照日志太多</span><br><span class="line">#clientPort：</span><br><span class="line">这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span><br></pre></td></tr></table></figure></p>
<p>创建myid<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#server0</span><br><span class="line">echo <span class="string">"0"</span> &gt; /usr/zookeeper/zookeeper0/zkdata</span><br><span class="line">#server2</span><br><span class="line">echo <span class="string">"1"</span> &gt; /usr/zookeeper/zookeeper1/zkdata</span><br><span class="line">#server3</span><br><span class="line">echo <span class="string">"2"</span> &gt; /usr/zookeeper/zookeeper2/zkdata</span><br></pre></td></tr></table></figure></p>
<p>其他两个实例修改端口，同样操作。</p>
<p>启动zookeeper</p>
<p>进入bin目录；执行 ./zkServer.sh ../conf/zoo.cfg命令</p>
<p><img src="/2017/10/30/kafka-zookeeper/8.png" alt=""></p>
<p>检查启动状态：</p>
<p>./zkServer.sh status</p>
<p><img src="/2017/10/30/kafka-zookeeper/9.png" alt=""></p>
<p>mode：leader 表示这是个leader节点</p>
<p>其他两个实例同样操作。至此zookeeper伪集群搭建完毕。</p>
<p>来源：<a href="https://my.oschina.net/u/3112259/blog/1556837" target="_blank" rel="external">https://my.oschina.net/u/3112259/blog/1556837</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/29/jdk-cglib-proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/jdk-cglib-proxy/" itemprop="url">
                  JDK动态代理和CGLIB代理的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-29 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-29T23:47:44+08:00">2017-10-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 16:43:34" itemprop="dateModified" datetime="2017-11-11T16:43:34+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当一个对象（客户端）不能或者不想直接引用另一个对象（目标对象），这时可以应用代理模式在这两者之间构建一个桥梁–代理对象。</p>
<p>按照代理对象的创建时期不同，可以分为两种：</p>
<p>静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。</p>
<p>动态代理：在程序运行时，运用反射机制动态创建而成。</p>
<p>其中动态代理又可分两种，Spring里会自动在JDK的代理和CGLIB之间切换，同时我们也可以强制Spring使用CGLIB。</p>
<h3 id="1-JDK动态代理"><a href="#1-JDK动态代理" class="headerlink" title="1.JDK动态代理"></a>1.JDK动态代理</h3><p>此时代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性，具体接口实现中，可以在调用目标对象相应方法前后加上其他业务处理逻辑。</p>
<p>代理模式在实际使用时需要指定具体的目标对象，如果为每个类都添加一个代理类的话，会导致类很多，同时如果不知道具体类的话，怎样实现代理模式呢？这就引出动态代理。</p>
<p>JDK动态代理只能针对实现了接口的类生成代理。</p>
<h3 id="2-CGLIB代理"><a href="#2-CGLIB代理" class="headerlink" title="2.CGLIB代理"></a>2.CGLIB代理</h3><p>CGLIB（CODE GENERLIZE LIBRARY）代理是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。</p>
<p>如果目标对象没有实现接口，则默认会采用CGLIB代理；<br>如果目标对象实现了接口，可以强制使用CGLIB实现代理（添加CGLIB库，并在spring配置中加入<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code>）。</p>
<p>AOP包括切面（aspect）、通知（advice）、连接点（joinpoint），实现方式就是通过对目标对象的代理在连接点前后加入通知，完成统一的切面操作。</p>
<p>来源：<a href="http://blog.csdn.net/cpzhong/article/details/6423333" target="_blank" rel="external">http://blog.csdn.net/cpzhong/article/details/6423333</a></p>
<hr>
<h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><p>静态代理：</p>
<p>Count.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.dao;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 定义一个账户接口 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Count</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 查看账户方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 修改账户方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountImpl.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.dao.impl;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.Count;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 委托类(包含业务逻辑) </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountImpl</span> <span class="keyword">implements</span> <span class="title">Count</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查看账户方法..."</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"修改账户方法..."</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CountProxy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.dao.impl;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.Count;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 这是一个代理类（增强CountImpl实现类） </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountProxy</span> <span class="keyword">implements</span> <span class="title">Count</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> CountImpl countImpl;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 覆盖默认构造器 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countImpl </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountProxy</span><span class="params">(CountImpl countImpl)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.countImpl = countImpl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"事务处理之前"</span>);  </span><br><span class="line">        <span class="comment">// 调用委托类的方法;  </span></span><br><span class="line">        countImpl.queryCount();  </span><br><span class="line">        System.out.println(<span class="string">"事务处理之后"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"事务处理之前"</span>);  </span><br><span class="line">        <span class="comment">// 调用委托类的方法;  </span></span><br><span class="line">        countImpl.updateCount();  </span><br><span class="line">        System.out.println(<span class="string">"事务处理之后"</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TestCount.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.test;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.impl.CountImpl;  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.impl.CountProxy;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *测试Count类 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCount</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        CountImpl countImpl = <span class="keyword">new</span> CountImpl();  </span><br><span class="line">        CountProxy countProxy = <span class="keyword">new</span> CountProxy(countImpl);  </span><br><span class="line">        countProxy.updateCount();  </span><br><span class="line">        countProxy.queryCount();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>观察代码可以发现每一个代理类只能为一个接口服务，这样一来程序开发中必然会产生过多的代理，而且，所有的代理操作除了调用的方法不一样之外，其他的操作都一样，则此时肯定是重复代码。解决这一问题最好的做法是可以通过一个代理类完成全部的代理功能，那么此时就必须使用动态代理完成。</p>
<h3 id="JDK动态代理："><a href="#JDK动态代理：" class="headerlink" title="JDK动态代理："></a>JDK动态代理：</h3><p>JDK动态代理中包含一个类和一个接口：</p>
<p>InvocationHandler接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span> <span class="keyword">throws</span> Throwable</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object proxy：指被代理的对象。 </span><br><span class="line">Method method：要调用的方法 </span><br><span class="line">Object[] args：方法调用时所需要的参数</span><br></pre></td></tr></table></figure></p>
<p>可以将InvocationHandler接口的子类想象成一个代理的最终操作类，替换掉ProxySubject。</p>
<p>Proxy类：</p>
<p>Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, </span></span></span><br><span class="line"><span class="function"><span class="params">InvocationHandler h)</span> </span></span><br><span class="line"><span class="function">                               <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>
<p>参数说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader：类加载器 </span><br><span class="line">Class&lt;?&gt;[] interfaces：得到全部的接口 </span><br><span class="line">InvocationHandler h：得到InvocationHandler接口的子类实例</span><br></pre></td></tr></table></figure></p>
<p>Ps:类加载器</p>
<p>在Proxy类中的newProxyInstance（）方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，在Java中主要有一下三种类加载器;</p>
<p>Booststrap ClassLoader：此加载器采用C++编写，一般开发中是看不到的；</p>
<p>Extendsion ClassLoader：用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类;</p>
<p>AppClassLoader：(默认)加载classpath指定的类，是最常使用的是一种加载器。</p>
<p>动态代理与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。java.lang.reflect 包中的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。</p>
<p>动态代理示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BookFacade.java </span><br><span class="line"><span class="keyword">package</span> net.battier.dao;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookFacade</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookFacadeImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.dao.impl;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.BookFacade;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeImpl</span> <span class="keyword">implements</span> <span class="title">BookFacade</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"增加图书方法。。。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookFacadeProxy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.proxy;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * JDK动态代理代理类 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> student </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object target;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 绑定委托对象并返回一个代理类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.target = target;  </span><br><span class="line">        <span class="comment">//取得代理对象  </span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),  </span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);   <span class="comment">//要绑定接口(这是一个缺陷，cglib弥补了这一缺陷)  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 调用方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        Object result=<span class="keyword">null</span>;  </span><br><span class="line">        System.out.println(<span class="string">"事物开始"</span>);  </span><br><span class="line">        <span class="comment">//执行方法  </span></span><br><span class="line">        result=method.invoke(target, args);  </span><br><span class="line">        System.out.println(<span class="string">"事物结束"</span>);  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TestProxy.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.test;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.BookFacade;  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.impl.BookFacadeImpl;  </span><br><span class="line"><span class="keyword">import</span> net.battier.proxy.BookFacadeProxy;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        BookFacadeProxy proxy = <span class="keyword">new</span> BookFacadeProxy();  </span><br><span class="line">        BookFacade bookProxy = (BookFacade) proxy.bind(<span class="keyword">new</span> BookFacadeImpl());  </span><br><span class="line">        bookProxy.addBook();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，JDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这就要使用cglib动态代理了。</p>
<h3 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h3><p>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p>
<p>示例</p>
<p>BookFacadeCglib.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.dao;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookFacade</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookCadeImpl1.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.dao.impl;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 这个是没有实现接口的实现类 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> student </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeImpl1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"增加图书的普通方法..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookFacadeProxy.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.proxy;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;  </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;  </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用cglib动态代理 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> student </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object target;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 创建代理对象 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.target = target;  </span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();  </span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());  </span><br><span class="line">        <span class="comment">// 回调方法  </span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);  </span><br><span class="line">        <span class="comment">// 创建代理对象  </span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="comment">// 回调方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args,  </span></span></span><br><span class="line"><span class="function"><span class="params">            MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"事物开始"</span>);  </span><br><span class="line">        proxy.invokeSuper(obj, args);  </span><br><span class="line">        System.out.println(<span class="string">"事物结束"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TestCglib.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.test;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.impl.BookFacadeImpl1;  </span><br><span class="line"><span class="keyword">import</span> net.battier.proxy.BookFacadeCglib;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCglib</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        BookFacadeCglib cglib=<span class="keyword">new</span> BookFacadeCglib();  </span><br><span class="line">        BookFacadeImpl1 bookCglib=(BookFacadeImpl1)cglib.getInstance(<span class="keyword">new</span> BookFacadeImpl1());  </span><br><span class="line">        bookCglib.addBook();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：<a href="http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html" target="_blank" rel="external">http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/28/stateless-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/stateless-service/" itemprop="url">
                  无状态服务和有状态服务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-28 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-28T23:47:44+08:00">2017-10-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 13:37:04" itemprop="dateModified" datetime="2017-11-11T13:37:04+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>无状态服务（stateless service）对单次请求的处理，不依赖其他请求，也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（比如说数据库），服务器本身不存储任何信息</p>
<p>有状态服务（stateful service）则相反，它会在自身保存一些数据，先后的请求是有关联的</p>
<h3 id="二、优劣"><a href="#二、优劣" class="headerlink" title="二、优劣"></a>二、优劣</h3><p>有状态服务常常用于实现事务（并不是唯一办法，下文有另外的方案）。举一个常见的例子，在商城里购买一件商品。需要经过放入购物车、确认订单、付款等多个步骤。由于HTTP协议本身是无状态的，所以为了实现有状态服务，就需要通过一些额外的方案。比如最常见的session，将用户挑选的商品（购物车），保存到session中，当付款的时候，再从购物车里取出商品信息</p>
<p>有状态服务可以很容易地实现事务，所以也是有价值的。但是经常听到一种说法，即server要设计为无状态的，这主要是从可伸缩性来考虑的。如果server是无状态的，那么对于客户端来说，就可以将请求发送到任意一台server上，然后就可以通过负载均衡等手段，实现水平扩展。如果server是有状态的，那么就无法很容易地实现了，因为客户端需要始终把请求发到同一台server才行，所谓“session迁移”等方案，也就是为了解决这个问题</p>
<p><img src="/2017/10/28/stateless-service/1.png" alt=""></p>
<h3 id="三、session和cookie"><a href="#三、session和cookie" class="headerlink" title="三、session和cookie"></a>三、session和cookie</h3><p>基于session和cookie都可以实现事务，可以认为，session是有状态的，而cookie是无状态的</p>
<h3 id="四、无状态实现事务的方法"><a href="#四、无状态实现事务的方法" class="headerlink" title="四、无状态实现事务的方法"></a>四、无状态实现事务的方法</h3><p>并不是一定要用有状态服务才能实现事务，本文提供另外的几种方案作为参考<br>举一个多次提交的场景作为例子：用户需要提交很多数据，分为2个页面提交</p>
<p><img src="/2017/10/28/stateless-service/2.png" alt=""></p>
<p>这里就涉及到2次http请求，第一次提交字段1、2、3，第二次提交字段4、5、6</p>
<p>用session很容易实现这个需求，server只需要将第一次提交的数据，保存在session里，然后返回第2个表单作为相应；然后取出第一次提交的数据，和第二次提交的数据汇聚以后，一起存入数据库即可</p>
<p>不用session同样也可以实现，server接收到第一次请求以后，将数据作为隐藏元素，放在第2个表单里返回；这样用户第2次提交的时候，就隐含地再次提交了第一次的数据；server将所有数据存入数据库<br>用HTML5，则还可以进一步优化，client可以将第一次提交的数据，保存在sessionStorage里<br>用cookie也是类似的道理，同样可以实现，但是不太好</p>
<p>总的来说，3种替代方案（隐藏表单元素、sessionStorage、cookie）都避免了在server端暂存数据，从而实现了stateless service。本质上，这3种方案的请求里，都包含了所有必须的数据，符合本文一开始的定义</p>
<h3 id="五、将有状态服务转换成无状态服务"><a href="#五、将有状态服务转换成无状态服务" class="headerlink" title="五、将有状态服务转换成无状态服务"></a>五、将有状态服务转换成无状态服务</h3><p>根据本文一开始的定义，除了将所有信息都放在请求里之外，还有另外一种方法可以实现无状态服务，即将信息放在一个单独可共享的地方，独立于server存在<br>比如，同样还是采取session的方式，在服务端保存数据，减少每次client请求传输的数据量（节省流量）；但是将session集中存放，比如放在单独的session层里。这种情况下，server同样是无状态的，可以做水平扩展</p>
<p><img src="/2017/10/28/stateless-service/3.png" alt=""></p>
<h3 id="六、无状态类"><a href="#六、无状态类" class="headerlink" title="六、无状态类"></a>六、无状态类</h3><p>引申一下，JAVA里有一种类的设计，可以称为无状态类。这种类的特征是只有方法没有字段，在三层架构（展现层、逻辑层、持久层）里，逻辑层经常可以看到这种类<br>我觉得无状态类和stateless server在思想上是一样的，这个类本身是没有状态的，所以当外部要调用它的方法时，需要在方法参数中传来所需的所有信息，不依赖该类自身的状态（字段值），在并发环境下，可以避免多线程带来的副作用</p>
<h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>有状态服务可以比较容易地实现事务，在不需要考虑水平扩展时，是比较好的选择<br>无状态服务的优势在于可以很方便地水平伸缩，但是在实现事务时，需要做一些额外的动作<br>可以通过剥离session等方法，将一个有状态服务，转换成无状态服务</p>
<p>关于这个话题，下面这个链接也不错：<br><a href="http://stackoverflow.com/questions/4495950/how-do-stateless-servers-work" target="_blank" rel="external">http://stackoverflow.com/questions/4495950/how-do-stateless-servers-work</a></p>
<p>来源：<a href="http://kyfxbl.iteye.com/blog/1831869" target="_blank" rel="external">http://kyfxbl.iteye.com/blog/1831869</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/28/webview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/webview/" itemprop="url">
                  WebView加载速度优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-28 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-28T23:47:44+08:00">2017-10-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 15:31:12" itemprop="dateModified" datetime="2017-11-11T15:31:12+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h3><p>这个比较容易，开启webView的缓存功能就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WebSettings settings = webView.getSettings();</span><br><span class="line">settings.setAppCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">settings.setDatabaseEnabled(<span class="keyword">true</span>);</span><br><span class="line">settings.setDomStorageEnabled(<span class="keyword">true</span>);<span class="comment">//开启DOM缓存，关闭的话H5自身的一些操作是无效的</span></span><br><span class="line">settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br></pre></td></tr></table></figure>
<p>这边我们通过setCacheMode方法来设置WebView的缓存策略，WebSettings.LOAD_DEFAULT是默认的缓存策略，它在缓存可获取并且没有过期的情况下加载缓存，否则通过网络获取资源。这样的话可以减少页面的网络请求次数，那我们如何在离线的情况下也能打开页面呢，这里我们在加载页面的时候可以通过判断网络状态，在无网络的情况下更改webview的缓存策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">NetworkInfo info = cm.getActiveNetworkInfo();</span><br><span class="line"><span class="keyword">if</span>(info.isAvailable())</span><br><span class="line">&#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY);<span class="comment">//不使用网络，只加载缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以使我们的混合应用在没有网络的情况下也能使用一部分的功能，不至于什么都显示不了了，当然如果我们将缓存做的更好一些，<strong>在网络好的时候，比如说在WIFI状态下，去后台加载一些网页缓存起来，这样处理的话，即使在无网络情况下第一次打开某些页面的时候，也能将该页面显示出来</strong>。</p>
<p>当然缓存资源后随之会带来一个问题，那就是资源无法及时更新，WebSettings.LOAD_DEFAULT中的页面中的缓存版本好像不是很起作用，所以我们这边可能需要自己做一个缓存版本控制。这个缓存版本控制可以放在APP版本更新中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (upgrade.cacheControl &gt; cacheControl)</span><br><span class="line">&#123;</span><br><span class="line">    webView.clearCache(<span class="keyword">true</span>);<span class="comment">//删除DOM缓存</span></span><br><span class="line">    VersionUtils.clearCache(mContext.getCacheDir());<span class="comment">//删除APP缓存</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        mContext.deleteDatabase(<span class="string">"webview.db"</span>);<span class="comment">//删除数据库缓存</span></span><br><span class="line">        mContext.deleteDatabase(<span class="string">"webviewCache.db"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>有时候一个页面资源比较多，图片，CSS，js比较多，还引用了JQuery这种庞然巨兽，从加载到页面渲染完成需要比较长的时间，有一个解决方案是将这些资源打包进APK里面，然后当页面加载这些资源的时候让它从本地获取，这样可以提升加载速度也能减少服务器压力。重写WebClient类中的shouldInterceptRequest方法，再将这个类设置给WebView。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> WebViewClient()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebResourceResponse <span class="title">shouldInterceptRequest</span><span class="params">(WebView view, String url)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url.contains(<span class="string">"[tag]"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            String localPath = url.replaceFirst(<span class="string">"^http.*[tag]\\]"</span>, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                InputStream is = getApplicationContext().getAssets().open(localPath);</span><br><span class="line">                Log.d(TAG, <span class="string">"shouldInterceptRequest: localPath "</span> + localPath);</span><br><span class="line">                String mimeType = <span class="string">"text/javascript"</span>;</span><br><span class="line">                <span class="keyword">if</span> (localPath.endsWith(<span class="string">"css"</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    mimeType = <span class="string">"text/css"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WebResourceResponse(mimeType, <span class="string">"UTF-8"</span>, is);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里我们队页面中带有特殊标记的请求进行过滤替换，也就是上面代码中的[tag]，这个可以跟做后台开发的同事约定好来就行了。对图片资源或者其他资源进行替换也是可以的。补充一个小点可以通过settings.setLoadsImagesAutomatically(true);来设置在页面装载完成之后再去加载图片。</p>
<h3 id="H5优化"><a href="#H5优化" class="headerlink" title="H5优化"></a>H5优化</h3><p>Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使 用JQuery，会在处理完DOM对象，执行完$(document).ready(function() {});事件自会后才会渲染并显示页面。而同样的页面在iPhone上却是载入相当的快，因为iPhone是显示完页面才会触发脚本的执行。所以我们这边的解决方案延迟JS脚本的载入，这个方面的问题是需要Web前端工程师帮忙优化的，网上应该有比较多LazyLoad插件，这里放一个比较老的链接Painless JavaScript lazy loading with LazyLoad,同样也放上一小段前端代码，仅供参考。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/css/j/lazyload-min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  loadComplete() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//instead of document.read();</span></span></span><br><span class="line"><span class="undefined">  &#125; </span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">loadscript</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    LazyLoad.loadOnce([</span></span><br><span class="line"><span class="javascript">      <span class="string">'/css/j/jquery-1.6.2.min.js'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'/css/j/flow/jquery.flow.1.1.min.js'</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">'/css/j/min.js?v=2011100852'</span></span></span><br><span class="line"><span class="undefined">      ], loadComplete);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  setTimeout(loadscript,10);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>来源：<a href="http://www.jianshu.com/p/427600ca2107" target="_blank" rel="external">http://www.jianshu.com/p/427600ca2107</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/28/browser-how-work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/browser-how-work/" itemprop="url">
                  浏览器内部工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-28 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-28T23:47:44+08:00">2017-10-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 16:24:53" itemprop="dateModified" datetime="2017-11-11T16:24:53+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>浏览器可以被认为是使用最广泛的软件，本文将介绍浏览器的工作原理，我们将看到，从你在地址栏输入google.com到你看到google主页过程中都发生了什么。</p>
<p>将讨论的浏览器</p>
<p>今天，有五种主流浏览器——IE、Firefox、Safari、Chrome及Opera。</p>
<p>本文将基于一些开源浏览器的例子——Firefox、Chrome及Safari，Safari是部分开源的。</p>
<p>　　根据W3C（World Wide Web Consortium万维网联盟）的浏览器统计数据，当前（2011年5月），Firefox、Safari及Chrome的市场占有率综合已接近60％。（原文为2009年10月，数据没有太大变化）因此，可以说开源浏览器已经占据了浏览器市场的半壁江山。</p>
<h3 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h3><p>　　浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置，在网络一章有更多讨论。</p>
<p>　　HTML和CSS规范中规定了浏览器解释html文档的方式，由W3C组织对这些规范进行维护，W3C是负责制定web标准的组织。</p>
<p>　　HTML规范的最新版本是<a href="http://www.w3.org/TR/html401/" target="_blank" rel="external">HTML4</a>，HTML5还在制定中（译注：两年前），[最新的CSS规范版本是2]（<a href="http://www.w3.org/TR/CSS2），CSS3也还正在制定中（译注：同样两年前）。" target="_blank" rel="external">http://www.w3.org/TR/CSS2），CSS3也还正在制定中（译注：同样两年前）。</a></p>
<p>　　这些年来，浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为web开发者带来了严重的兼容性问题。</p>
<p>　　但是，浏览器的用户界面则差不多，常见的用户界面元素包括：</p>
<p>用来输入URI的地址栏</p>
<p>前进、后退按钮</p>
<p>书签选项</p>
<p>用于刷新及暂停当前加载文档的刷新、暂停按钮</p>
<p>用于到达主页的主页按钮</p>
<p>　　奇怪的是，并没有哪个正式公布的规范对用户界面做出规定，这些是多年来各浏览器厂商之间相互模仿和不断改进的结果。</p>
<p>　　HTML5并没有规定浏览器必须具有的UI元素，但列出了一些常用元素，包括地址栏、状态栏及工具栏。还有一些浏览器有自己专有的功能，比如Firefox的下载管理。更多相关内容将在后面讨论用户界面时介绍。</p>
<h3 id="浏览器的主要构成（High-Level-Structure）"><a href="#浏览器的主要构成（High-Level-Structure）" class="headerlink" title="浏览器的主要构成（High Level Structure）"></a>浏览器的主要构成（High Level Structure）</h3><p>　　浏览器的主要组件包括：</p>
<p>　　1. 用户界面 － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。</p>
<p>　　2. 浏览器引擎 － 用来查询及操作渲染引擎的接口。</p>
<p>　　3. 渲染引擎 － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。</p>
<p>　　4. 网络 － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。</p>
<p>　　5. UI后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。</p>
<p>　　6. JS解释器 － 用来解释执行JS代码。</p>
<p>　　7. 数据存储 － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</p>
<p><img src="/2017/10/28/browser-how-work/1.png" alt=""></p>
<p>图1：浏览器主要组件</p>
<p>　　需要注意的是，不同于大部分浏览器，Chrome为每个Tab分配了各自的渲染引擎实例，每个Tab就是一个独立的进程。</p>
<p>　　对于构成浏览器的这些组件，后面会逐一详细讨论。</p>
<h3 id="二、渲染引擎（The-rendering-engine）"><a href="#二、渲染引擎（The-rendering-engine）" class="headerlink" title="二、渲染引擎（The rendering engine）"></a>二、渲染引擎（The rendering engine）</h3><p>　　渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。</p>
<p>　　默认情况下，渲染引擎可以显示html、xml文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用PDF阅读器插件，可以显示PDF格式，将由专门一章讲解插件及扩展，这里只讨论渲染引擎最主要的用途——显示应用了CSS之后的html及图片。</p>
<h3 id="渲染引擎简介"><a href="#渲染引擎简介" class="headerlink" title="渲染引擎简介"></a>渲染引擎简介</h3><p>　　本文所讨论的浏览器——Firefox、Chrome和Safari是基于两种渲染引擎构建的，Firefox使用Geoko——Mozilla自主研发的渲染引擎，Safari和Chrome都使用webkit。</p>
<p>　　Webkit是一款开源渲染引擎，它本来是为Linux平台研发的，后来由Apple移植到Mac及Windows上，相关内容请参考 <a href="http://webkit.org" target="_blank" rel="external">http://webkit.org</a> 。</p>
<p>渲染主流程（The main flow）</p>
<p>　　渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。</p>
<p>　　下面是渲染引擎在取得内容之后的基本流程：</p>
<p>　　解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</p>
<p><img src="/2017/10/28/browser-how-work/2.png" alt=""></p>
<p>图2：渲染引擎基本流程</p>
<p>　　渲染引擎开始解析html，并将标签转化为内容树中的dom节点。接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树——render树。</p>
<p>　　Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。</p>
<p>　　Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</p>
<p>　　值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<p><img src="/2017/10/28/browser-how-work/3.png" alt=""></p>
<p>图3：webkit主流程</p>
<p><img src="/2017/10/28/browser-how-work/4.jpg" alt=""></p>
<p>图4：Mozilla的Geoko渲染引擎主流程</p>
<p>　　从图3和4中可以看出，尽管webkit和Gecko使用的术语稍有不同，他们的主要流程基本相同。Gecko称可见的格式化元素组成的树为frame树，每个元素都是一个frame，webkit则使用render树这个名词来命名由渲染对象组成的树。Webkit中元素的定位称为布局，而Gecko中称为回流。Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂。下面将讨论流程中的各个阶段。</p>
<h3 id="三、解析与DOM树构建（Parsing-and-DOM-tree-construction）"><a href="#三、解析与DOM树构建（Parsing-and-DOM-tree-construction）" class="headerlink" title="三、解析与DOM树构建（Parsing and DOM tree construction）"></a>三、解析与DOM树构建（Parsing and DOM tree construction）</h3><h4 id="解析（Parsing－general）"><a href="#解析（Parsing－general）" class="headerlink" title="解析（Parsing－general）"></a>解析（Parsing－general）</h4><p>　　既然解析是渲染引擎中一个非常重要的过程，我们将稍微深入的研究它。首先简要介绍一下解析。</p>
<p>　　解析一个文档即将其转换为具有一定意义的结构——编码可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。</p>
<p>　　例如，解析“2＋3－1”这个表达式，可能返回这样一棵树。</p>
<p><img src="/2017/10/28/browser-how-work/5.png" alt=""></p>
<p>图5：数学表达式树节点</p>
<h4 id="文法（Grammars）"><a href="#文法（Grammars）" class="headerlink" title="文法（Grammars）"></a>文法（Grammars）</h4><p>　　解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。人类语言不具有这一特性，因此不能被一般的解析技术所解析。</p>
<p>解析器－词法分析器（Parser－Lexer combination）</p>
<p>　　解析可以分为两个子过程——语法分析及词法分析</p>
<p>　　词法分析就是将输入分解为符号，符号是语言的词汇表——基本有效单元的集合。对于人类语言来说，它相当于我们字典中出现的所有单词。</p>
<p>　　语法分析指对语言应用语法规则。</p>
<p>　　解析器一般将工作分配给两个组件——词法分析器（有时也叫分词器）负责将输入分解为合法的符号，解析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。</p>
<p><img src="/2017/10/28/browser-how-work/6.png" alt=""></p>
<p>图6：从源文档到解析树</p>
<p>　　解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p>
<h4 id="转换（Translation）"><a href="#转换（Translation）" class="headerlink" title="转换（Translation）"></a>转换（Translation）</h4><p>　　很多时候，解析树并不是最终结果。解析一般在转换中使用——将输入文档转换为另一种格式。编译就是个例子，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。</p>
<p><img src="/2017/10/28/browser-how-work/7.png" alt=""></p>
<p>图7：编译流程</p>
<h4 id="解析实例Parsing-example"><a href="#解析实例Parsing-example" class="headerlink" title="解析实例Parsing example"></a>解析实例Parsing example</h4><p>　　图5中，我们从一个数学表达式构建了一个解析树，这里定义一个简单的数学语言来看下解析过程。</p>
<p>　　词汇表：我们的语言包括整数、加号及减号。</p>
<p>　　语法：</p>
<p>　　1. 该语言的语法基本单元包括表达式、term及操作符</p>
<p>　　2. 该语言可以包括多个表达式</p>
<p>　　3. 一个表达式定义为两个term通过一个操作符连接</p>
<p>　　4. 操作符可以是加号或减号</p>
<p>　　5. term可以是一个整数或一个表达式</p>
<p>　　现在来分析一下“2＋3－1”这个输入</p>
<p>　　第一个匹配规则的子字符串是“2”，根据规则5，它是一个term，第二个匹配的是“2+3”，它符合第2条规则——一个操作符连接两个term，下一次匹配发生在输入的结束处。“2+3-1”是一个表达式，因为我们已经知道“2+3”是一个term，所以我们有了一个term紧跟着一个操作符及另一个term。“2++”将不会匹配任何规则，因此是一个无效输入。</p>
<p>词汇表及语法的定义</p>
<p>　　词汇表通常利用正则表达式来定义。</p>
<p>　　例如上面的语言可以定义为：</p>
<p>　　INTEGER：0｜［1－9］［0－9］＊</p>
<p>　　PLUS：+</p>
<p>　　MINUS：－</p>
<p>　　正如看到的，这里用正则表达式定义整数。</p>
<p>　　语法通常用BNF格式定义，我们的语言可以定义为：</p>
<p>　　expression :＝ term operation term</p>
<p>　　operation := PLUS | MINUS</p>
<p>　　term := INTEGER | expression</p>
<p>　　如果一个语言的文法是上下文无关的，则它可以用正则解析器来解析。对上下文无关文法的一个直观的定义是，该文法可以用BNF来完整的表达。可查看 <a href="http://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="external">http://en.wikipedia.org/wiki/Context-free_grammar</a> 。</p>
<h4 id="解析器类型（Types-of-parsers）"><a href="#解析器类型（Types-of-parsers）" class="headerlink" title="解析器类型（Types of parsers）"></a>解析器类型（Types of parsers）</h4><p>　　有两种基本的解析器——自顶向下解析及自底向上解析。比较直观的解释是，自顶向下解析，查看语法的最高层结构并试着匹配其中一个；自底向上解析则从输入开始，逐步将其转换为语法规则，从底层规则开始直到匹配高层规则。</p>
<p>　　来看一下这两种解析器如何解析上面的例子：</p>
<p>　　自顶向下解析器从最高层规则开始——它先识别出“2+3“，将其视为一个表达式，然后识别出”2+3-1“为一个表达式（识别表达式的过程中匹配了其他规则，但出发点是最高层规则）。</p>
<p>　　自底向上解析会扫描输入直到匹配了一条规则，然后用该规则取代匹配的输入，直到解析完所有输入。部分匹配的表达式被放置在解析堆栈中。</p>
<p><img src="/2017/10/28/browser-how-work/8.png" alt=""></p>
<p>　　自底向上解析器称为shift reduce解析器，因为输入向右移动（想象一个指针首先指向输入开始处，并向右移动），并逐渐简化为语法规则。</p>
<h4 id="自动化解析（Generating-parsers-automatically）"><a href="#自动化解析（Generating-parsers-automatically）" class="headerlink" title="自动化解析（Generating parsers automatically）"></a>自动化解析（Generating parsers automatically）</h4><p>　　解析器生成器这个工具可以自动生成解析器，只需要指定语言的文法——词汇表及语法规则，它就可以生成一个解析器。创建一个解析器需要对解析有深入的理解，而且手动的创建一个由较好性能的解析器并不容易，所以解析生成器很有用。Webkit使用两个知名的解析生成器——用于创建语法分析器的Flex及创建解析器的Bison（你可能接触过Lex和Yacc）。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p>
<h4 id="HTML解析器（HTML-Parser）"><a href="#HTML解析器（HTML-Parser）" class="headerlink" title="HTML解析器（HTML Parser）"></a>HTML解析器（HTML Parser）</h4><p>　　HTML解析器的工作是将html标识解析为解析树。</p>
<h4 id="HTML文法定义（The-HTML-grammar-definition）"><a href="#HTML文法定义（The-HTML-grammar-definition）" class="headerlink" title="HTML文法定义（The HTML grammar definition）"></a>HTML文法定义（The HTML grammar definition）</h4><p>　　W3C组织制定规范定义了HTML的词汇表和语法。</p>
<h4 id="非上下文无关文法（Not-a-context-free-grammar）"><a href="#非上下文无关文法（Not-a-context-free-grammar）" class="headerlink" title="非上下文无关文法（Not a context free grammar）"></a>非上下文无关文法（Not a context free grammar）</h4><p>　　正如在解析简介中提到的，上下文无关文法的语法可以用类似BNF的格式来定义。</p>
<p>　　不幸的是，所有的传统解析方式都不适用于html（当然我提出它们并不只是因为好玩，它们将用来解析css和js），html不能简单的用解析所需的上下文无关文法来定义。</p>
<p>　　Html有一个正式的格式定义——DTD（Document Type Definition文档类型定义）——但它并不是上下文无关文法，html更接近于xml，现在有很多可用的xml解析器，html有个xml的变体——xhtml，它们间的不同在于，html更宽容，它允许忽略一些特定标签，有时可以省略开始或结束标签。总的来说，它是一种soft语法，不像xml呆板、固执。</p>
<p>　　显然，这个看起来很小的差异却带来了很大的不同。一方面，这是html流行的原因——它的宽容使web开发人员的工作更加轻松，但另一方面，这也使很难去写一个格式化的文法。所以，html的解析并不简单，它既不能用传统的解析器解析，也不能用xml解析器解析。</p>
<h4 id="HTML-DTD"><a href="#HTML-DTD" class="headerlink" title="HTML DTD"></a>HTML DTD</h4><p>　　Html适用DTD格式进行定义，这一格式是用于定义SGML家族的语言，包括了对所有允许元素及它们的属性和层次关系的定义。正如前面提到的，html DTD并没有生成一种上下文无关文法。</p>
<p>　　DTD有一些变种，标准模式只遵守规范，而其他模式则包含了对浏览器过去所使用标签的支持，这么做是为了兼容以前内容。最新的标准DTD在  <a href="http://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="external">http://www.w3.org/TR/html4/strict.dtd</a> </p>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>　　输出的树，也就是解析树，是由DOM元素及属性节点组成的。DOM是文档对象模型的缩写，它是html文档的对象表示，作为html元素的外部接口供js等调用。</p>
<p>　　树的根是“document”对象。</p>
<p>　　DOM和标签基本是一一对应的关系，例如，如下的标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Hello DOM</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”example.png”</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　将会被转换为下面的DOM树：</p>
<p><img src="/2017/10/28/browser-how-work/9.png" alt=""></p>
<p>图8：示例标签对应的DOM树</p>
<p>　　和html一样，DOM的规范也是由W3C组织制定的。访问 <a href="http://www.w3.org/DOM/DOMTR" target="_blank" rel="external">http://www.w3.org/DOM/DOMTR</a> ，这是使用文档的一般规范。一个模型描述一种特定的html元素，可以在 <a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.htm" target="_blank" rel="external">http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.htm</a> 查看html定义。</p>
<p>　　这里所谓的树包含了DOM节点是说树是由实现了DOM接口的元素构建而成的，浏览器使用已被浏览器内部使用的其他属性的具体实现。</p>
<h4 id="解析算法（The-parsing-algorithm）"><a href="#解析算法（The-parsing-algorithm）" class="headerlink" title="解析算法（The parsing algorithm）"></a>解析算法（The parsing algorithm）</h4><p>　　正如前面章节中讨论的，hmtl不能被一般的自顶向下或自底向上的解析器所解析。</p>
<p>　　原因是：</p>
<p>　　1. 这门语言本身的宽容特性</p>
<p>　　2. 浏览器对一些常见的非法html有容错机制</p>
<p>　　3. 解析过程是往复的，通常源码不会在解析过程中发生改变，但在html中，脚本标签包含的“document.write”可能添加标签，这说明在解析过程中实际上修改了输入。</p>
<p>　　不能使用正则解析技术，浏览器为html定制了专属的解析器。</p>
<p>　　Html5规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。</p>
<p>　　符号化是词法分析的过程，将输入解析为符号，html的符号包括开始标签、结束标签、属性名及属性值。</p>
<p>　　符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，这样直到处理完所有输入。</p>
<p><img src="/2017/10/28/browser-how-work/10.png" alt=""></p>
<p>图9：HTML解析流程</p>
<h4 id="符号识别算法（The-tokenization-algorithm）"><a href="#符号识别算法（The-tokenization-algorithm）" class="headerlink" title="符号识别算法（The tokenization algorithm）"></a>符号识别算法（The tokenization algorithm）</h4><p>　　算法输出html符号，该算法用状态机表示。每次读取输入流中的一个或多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响结果，这意味着，读取同样的字符，可能因为当前状态的不同，得到不同的结果以进入下一个正确的状态。</p>
<p>　　这个算法很复杂，这里用一个简单的例子来解释这个原理。</p>
<p>　　基本示例——符号化下面的html：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Hello world</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　初始状态为“Data State”，当遇到“&lt;”字符，状态变为“Tag open state”，读取一个a－z的字符将产生一个开始标签符号，状态相应变为“Tag name state”，一直保持这个状态直到读取到“&gt;”，每个字符都附加到这个符号名上，例子中创建的是一个html符号。</p>
<p>　　当读取到“&gt;”，当前的符号就完成了，此时，状态回到“Data state”，“”重复这一处理过程。到这里，html和body标签都识别出来了。现在，回到“Data state”，读取“Hello world”中的字符“H”将创建并识别出一个字符符号，这里会为“Hello world”中的每个字符生成一个字符符号。</p>
<p>　　这样直到遇到“”中的“&lt;”。现在，又回到了“Tag open state”，读取下一个字符“/”将创建一个闭合标签符号，并且状态转移到“Tag name state”，还是保持这一状态，直到遇到“&gt;”。然后，产生一个新的标签符号并回到“Data state”。后面的“”将和“”一样处理。</p>
<p><img src="/2017/10/28/browser-how-work/11.png" alt=""></p>
<p>图10：符号化示例输入</p>
<h4 id="树的构建算法（Tree-construction-algorithm）"><a href="#树的构建算法（Tree-construction-algorithm）" class="headerlink" title="树的构建算法（Tree construction algorithm）"></a>树的构建算法（Tree construction algorithm）</h4><p>　　在树的构建阶段，将修改以Document为根的DOM树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的Dom元素，对应的Dom元素将会被创建。这些元素除了会被添加到Dom树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。</p>
<p>　　来看一下示例中树的创建过程：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Hello world</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　构建树这一阶段的输入是符号识别阶段生成的符号序列。</p>
<p>　　首先是“initial mode”，接收到html符号后将转换为“before html”模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。</p>
<p>　　状态此时变为“before head”，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。</p>
<p>　　现在，转到“in head”模式，然后是“after head”。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到“in body”模式。</p>
<p>　　然后，接收到字符串“Hello world”的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。</p>
<p>　　接收到body结束符号时，转移到“after body”模式，接着接收到html结束符号，这个符号意味着转移到了“after after body”模式，当接收到文件结束符时，整个解析过程结束。</p>
<p><img src="/2017/10/28/browser-how-work/12.gif" alt=""></p>
<p>图11：示例html树的构建过程</p>
<h4 id="解析结束时的处理（Action-when-the-parsing-is-finished）"><a href="#解析结束时的处理（Action-when-the-parsing-is-finished）" class="headerlink" title="解析结束时的处理（Action when the parsing is finished）"></a>解析结束时的处理（Action when the parsing is finished）</h4><p>　　在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。</p>
<p>　　文档状态将被设置为完成，同时触发一个load事件。</p>
<p>　　Html5规范中有符号化及构建树的完整算法( <a href="http://www.w3.org/TR/html5/syntax.html#html-parser" target="_blank" rel="external">http://www.w3.org/TR/html5/syntax.html#html-parser</a> )。</p>
<p>　　浏览器容错（Browsers error tolerance）</p>
<p>　　你从来不会在一个html页面上看到“无效语法”这样的错误，浏览器修复了无效内容并继续工作。</p>
<p>　　以下面这段html为例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mytag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mytag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">Really lousy HTML</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　这段html违反了很多规则（mytag不是合法的标签，p及div错误的嵌套等等），但是浏览器仍然可以没有任何怨言的继续显示，它在解析的过程中修复了html作者的错误。</p>
<p>　　浏览器都具有错误处理的能力，但是，另人惊讶的是，这并不是html最新规范的内容，就像书签及前进后退按钮一样，它只是浏览器长期发展的结果。一些比较知名的非法html结构，在许多站点中出现过，浏览器都试着以一种和其他浏览器一致的方式去修复。</p>
<p>　　Html5规范定义了这方面的需求，webkit在html解析类开始部分的注释中做了很好的总结。</p>
<p>　　解析器将符号化的输入解析为文档并创建文档，但不幸的是，我们必须处理很多没有很好格式化的html文档，至少要小心下面几种错误情况。</p>
<p>　　1. 在未闭合的标签中添加明确禁止的元素。这种情况下，应该先将前一标签闭合</p>
<p>　　2. 不能直接添加元素。有些人在写文档的时候会忘了中间一些标签（或者中间标签是可选的），比如HTML HEAD BODY TR TD LI等</p>
<p>　　3. 想在一个行内元素中添加块状元素。关闭所有的行内元素，直到下一个更高的块状元素</p>
<p>　　4. 如果这些都不行，就闭合当前标签直到可以添加该元素。</p>
<p>　　下面来看一些webkit容错的例子：</p>
<p>　　</p>
<h4 id="替代"><a href="#替代" class="headerlink" title="替代"></a>替代</h4><p>　　一些网站使用替代，为了兼容IE和Firefox，webkit将其看作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</span><br><span class="line">reportError(MalformedBRError);</span><br><span class="line">t-&gt;beginTag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　Note －这里的错误处理在内部进行，用户看不到。</p>
<p>　　迷路的表格</p>
<p>　　这指一个表格嵌套在另一个表格中，但不在它的某个单元格内。</p>
<p>　　比如下面这个例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">　　webkit将会将嵌套的表格变为两个兄弟表格：</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_inStrayTableContent &amp;&amp; localName == tableTag)</span><br><span class="line">popBlock(tableTag);</span><br></pre></td></tr></table></figure>
<p>　　webkit使用堆栈存放当前的元素内容，它将从外部表格的堆栈中弹出内部的表格，则它们变为了兄弟表格。
　　</p>
<h4 id="嵌套的表单元素"><a href="#嵌套的表单元素" class="headerlink" title="嵌套的表单元素"></a>嵌套的表单元素</h4><p>　　用户将一个表单嵌套到另一个表单中，则第二个表单将被忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m_currentFormElement) &#123;</span><br><span class="line">m_currentFormElement = <span class="keyword">new</span> HTMLFormElement(formTag,m_document);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　</p>
<h4 id="太深的标签继承"><a href="#太深的标签继承" class="headerlink" title="太深的标签继承"></a>太深的标签继承</h4><p>　　 www.liceo.edu.mx 是一个由嵌套层次的站点的例子，最多只允许20个相同类型的标签嵌套，多出来的将被忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool HTMLParser::allowNestedRedundantTag(<span class="keyword">const</span> AtomicString&amp; tagName)</span><br><span class="line">&#123;</span><br><span class="line">unsigned i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (HTMLStackElem* curr = m_blockStack;</span><br><span class="line">i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;</span><br><span class="line">curr = curr-&gt;next, i++) &#123; &#125;</span><br><span class="line"><span class="keyword">return</span> i != cMaxRedundantTagDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　放错了地方的html、body闭合标签</p>
<p>　　又一次不言自明。</p>
<p>　　支持不完整的html。我们从来不闭合body，因为一些愚蠢的网页总是在还未真正结束时就闭合它。我们依赖调用end方法去执行关闭的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>　　所以，web开发者要小心了，除非你想成为webkit容错代码的范例，否则还是写格式良好的html吧。</p>
<h3 id="CSS解析（CSS-parsing）"><a href="#CSS解析（CSS-parsing）" class="headerlink" title="CSS解析（CSS parsing）"></a>CSS解析（CSS parsing）</h3><p>　　还记得简介中提到的解析的概念吗，不同于html，css属于上下文无关文法，可以用前面所描述的解析器来解析。Css规范定义了css的词法及语法文法。</p>
<p>　　看一些例子：</p>
<p>　　每个符号都由正则表达式定义了词法文法（词汇表）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment///*[^*]*/*+([^/*][^*]*/*+)*//</span><br><span class="line">num[0-9]+|[0-9]*&quot;.&quot;[0-9]+</span><br><span class="line">nonascii[/200-/377]</span><br><span class="line">nmstart[_a-z]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">nmchar[_a-z0-9-]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">name&#123;nmchar&#125;+</span><br><span class="line">ident&#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure>
<p>　　“ident”是识别器的缩写，相当于一个class名，“name”是一个元素id（用“＃”引用）。<br>　　语法用BNF进行描述：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">: selector [ <span class="string">','</span> S* selector ]*</span><br><span class="line"><span class="string">'&#123;'</span> S* declaration [ <span class="string">';'</span> S* declaration ]* <span class="string">'&#125;'</span> S*</span><br><span class="line">;</span><br><span class="line">selector</span><br><span class="line">: simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">;</span><br><span class="line">simple_selector</span><br><span class="line">: element_name [ HASH | class | attrib | pseudo ]*</span><br><span class="line">| [ HASH | class | attrib | pseudo ]+</span><br><span class="line">;</span><br><span class="line"><span class="class"><span class="keyword">class</span></span></span><br><span class="line">: '.' IDENT</span><br><span class="line">;</span><br><span class="line">element_name</span><br><span class="line">: IDENT | <span class="string">'*'</span></span><br><span class="line">;</span><br><span class="line">attrib</span><br><span class="line">: <span class="string">'['</span> S* IDENT S* [ [ <span class="string">'='</span> | INCLUDES | DASHMATCH ] S*</span><br><span class="line">[ IDENT | STRING ] S* ] <span class="string">']'</span></span><br><span class="line">;</span><br><span class="line">pseudo</span><br><span class="line">: <span class="string">':'</span> [ IDENT | FUNCTION S* [IDENT S*] <span class="string">')'</span> ]</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p>
<p>说明：一个规则集合有这样的结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.error , a.error &#123;</span><br><span class="line">color:red;</span><br><span class="line">font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>div.error和a.error时选择器，大括号中的内容包含了这条规则集合中的规则，这个结构在下面的定义中正式的定义了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">: selector [ <span class="string">','</span> S* selector ]*</span><br><span class="line"><span class="string">'&#123;'</span> S* declaration [ <span class="string">';'</span> S* declaration ]* <span class="string">'&#125;'</span> S*</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p>
<p>　　这说明，一个规则集合具有一个或是可选个数的多个选择器，这些选择器以逗号和空格（S表示空格）进行分隔。每个规则集合包含大括号及大括号中的一条或多条以分号隔开的声明。声明和选择器在后面进行定义。</p>
<h3 id="Webkit-CSS解析器（Webkit-CSS-parser）"><a href="#Webkit-CSS解析器（Webkit-CSS-parser）" class="headerlink" title="Webkit CSS解析器（Webkit CSS parser）"></a>Webkit CSS解析器（Webkit CSS parser）</h3><p>　　Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。回忆一下解析器的介绍，Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。它们都是将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。</p>
<p><img src="/2017/10/28/browser-how-work/13.png" alt=""></p>
<p>图12：解析css</p>
<h3 id="处理脚本及样式表的顺序（The-order-of-processing-scripts-and-style-sheets）"><a href="#处理脚本及样式表的顺序（The-order-of-processing-scripts-and-style-sheets）" class="headerlink" title="处理脚本及样式表的顺序（The order of processing scripts and style sheets）"></a>处理脚本及样式表的顺序（The order of processing scripts and style sheets）</h3><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>　　web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。Html5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。</p>
<h4 id="预解析（Speculative-parsing）"><a href="#预解析（Speculative-parsing）" class="headerlink" title="预解析（Speculative parsing）"></a>预解析（Speculative parsing）</h4><p>　　Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h4 id="样式表（Style-sheets）"><a href="#样式表（Style-sheets）" class="headerlink" title="样式表（Style sheets）"></a>样式表（Style sheets）</h4><p>　　样式表采用另一种不同的模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。</p>
<h3 id="四、渲染树构建（Render-tree-construction）"><a href="#四、渲染树构建（Render-tree-construction）" class="headerlink" title="四、渲染树构建（Render tree construction）"></a>四、渲染树构建（Render tree construction）</h3><p>　　当Dom树构建完成时，浏览器开始构建另一棵树——渲染树。渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。</p>
<p>　　Firefox将渲染树中的元素称为frames，WebKit则用renderer或渲染对象来描述这些元素。</p>
<p>　　一个渲染对象知道怎么布局及绘制自己及它的children。</p>
<p>　　RenderObject是Webkit的渲染对象基类，它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</span><br><span class="line">Node* node;<span class="comment">//the DOM node</span></span><br><span class="line">RenderStyle* style;<span class="comment">// the computed style</span></span><br><span class="line">RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　每个渲染对象用一个和该节点的css盒模型相对应的矩形区域来表示，正如css2所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的display样式属性的影响（参考样式计算章节）。下面的webkit代码说明了如何根据display属性决定某个节点创建何种类型的渲染对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)</span><br><span class="line">&#123;</span><br><span class="line">Document* doc = node-&gt;document();</span><br><span class="line">RenderArena* arena = doc-&gt;renderArena();</span><br><span class="line">...</span><br><span class="line">RenderObject* o = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (style-&gt;display()) &#123;</span><br><span class="line"><span class="keyword">case</span> NONE:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> INLINE:</span><br><span class="line">o = <span class="keyword">new</span> (arena) RenderInline(node);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BLOCK:</span><br><span class="line">o = <span class="keyword">new</span> (arena) RenderBlock(node);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> INLINE_BLOCK:</span><br><span class="line">o = <span class="keyword">new</span> (arena) RenderBlock(node);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LIST_ITEM:</span><br><span class="line">o = <span class="keyword">new</span> (arena) RenderListItem(node);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　元素的类型也需要考虑，例如，表单控件和表格带有特殊的框架。</p>
<p>　　在Webkit中，如果一个元素想创建一个特殊的渲染对象，它需要重写“createRenderer”方法，使渲染对象指向不包含几何信息的样式对象。</p>
<h3 id="渲染树和Dom树的关系（The-render-tree-relation-to-the-DOM-tree）"><a href="#渲染树和Dom树的关系（The-render-tree-relation-to-the-DOM-tree）" class="headerlink" title="渲染树和Dom树的关系（The render tree relation to the DOM tree）"></a>渲染树和Dom树的关系（The render tree relation to the DOM tree）</h3><p>　　渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，例如head元素。另外，display属性为none的元素也不会在渲染树中出现（visibility属性为hidden的元素将出现在渲染树中）。</p>
<p>　　还有一些Dom元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而折行时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的html，根据css规范，一个行内元素只能仅包含行内元素或仅包含块状元素，在存在混合内容时，将会创建匿名的块状渲染对象包裹住行内元素。</p>
<p>　　一些渲染对象和所对应的Dom节点不在树上相同的位置，例如，浮动和绝对定位的元素在文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。</p>
<p><img src="/2017/10/28/browser-how-work/14.png" alt=""></p>
<p>图13：渲染树及对应的Dom树</p>
<h3 id="创建树的流程（The-flow-of-constructing-the-tree）"><a href="#创建树的流程（The-flow-of-constructing-the-tree）" class="headerlink" title="创建树的流程（The flow of constructing the tree）"></a>创建树的流程（The flow of constructing the tree）</h3><p>　　Firefox中，表述为一个监听Dom更新的监听器，将frame的创建委派给Frame Constructor，这个构建器计算样式（参看样式计算）并创建一个frame。</p>
<p>　　Webkit中，计算样式并生成渲染对象的过程称为attachment，每个Dom节点有一个attach方法，attachment的过程是同步的，调用新节点的attach方法将节点插入到Dom树中。</p>
<p>　　处理html和body标签将构建渲染树的根，这个根渲染对象对应被css规范称为containing block的元素——包含了其他所有块元素的顶级块元素。它的大小就是viewport——浏览器窗口的显示区域，Firefox称它为viewPortFrame，webkit称为RenderView，这个就是文档所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。</p>
<h3 id="样式计算（Style-Computation）"><a href="#样式计算（Style-Computation）" class="headerlink" title="样式计算（Style Computation）"></a>样式计算（Style Computation）</h3><p>　　创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。</p>
<p>　　样式包括各种来源的样式表，行内样式元素及html中的可视化属性（例如bgcolor），可视化属性转化为css样式属性。</p>
<p>　　样式表来源于浏览器默认样式表，及页面作者和用户提供的样式表——有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在Firefox中，可以通过在Firefox Profile目录下放置样式表实现）。</p>
<p>　　计算样式的一些困难：</p>
<p>　　1. 样式数据是非常大的结构，保存大量的样式属性会带来内存问题。</p>
<p>　　2. 如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。</p>
<p>　　例如，下面这个复杂选择符</p>
<p>　　div div div div｛…｝</p>
<p>　　这意味着规则应用到三个div的后代div元素，选择树上一条特定的路径去检查，这可能需要遍历节点树，最后却发现它只是两个div的后代，并不使用该规则，然后则需要沿着另一条路径去尝试</p>
<p>　　3. 应用规则涉及非常复杂的级联，它们定义了规则的层次</p>
<p>　　我们来看一下浏览器如何处理这些问题：</p>
<h3 id="共享样式数据（Sharing-style-data）"><a href="#共享样式数据（Sharing-style-data）" class="headerlink" title="共享样式数据（Sharing style data）"></a>共享样式数据（Sharing style data）</h3><p>　　WebkKit节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：</p>
<p>　　1. 这些元素必须处于相同的鼠标状态（比如不能一个处于hover，而另一个不是）</p>
<p>　　2. 不能有元素具有id</p>
<p>　　3. 标签名必须匹配</p>
<p>　　4. class属性必须匹配</p>
<p>　　5. 对应的属性必须相同</p>
<p>　　6. 链接状态必须匹配</p>
<p>　　7. 焦点状态必须匹配</p>
<p>　　8. 不能有元素被属性选择器影响</p>
<p>　　9. 元素不能有行内样式属性</p>
<p>　　10. 不能有生效的兄弟选择器，webcore在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似:first-child和:last-child这样的选择器。</p>
<h3 id="Firefox规则树（Firefox-rule-tree）"><a href="#Firefox规则树（Firefox-rule-tree）" class="headerlink" title="Firefox规则树（Firefox rule tree）"></a>Firefox规则树（Firefox rule tree）</h3><p>　　Firefox用两个树用来简化样式计算－规则树和样式上下文树，WebKit也有样式对象，但它们并没有存储在类似样式上下文树这样的树中，只是由Dom节点指向其相关的样式。</p>
<p><img src="/2017/10/28/browser-how-work/15.png" alt=""></p>
<p>图14：Firefox样式上下文树</p>
<p>　　样式上下文包含最终值，这些值是通过以正确顺序应用所有匹配的规则，并将它们由逻辑值转换为具体的值，例如，如果逻辑值为屏幕的百分比，则通过计算将其转化为绝对单位。样式树的使用确实很巧妙，它使得在节点中共享的这些值不需要被多次计算，同时也节省了存储空间。</p>
<p>　　所有匹配的规则都存储在规则树中，一条路径中的底层节点拥有最高的优先级，这棵树包含了所找到的所有规则匹配的路径（译注：可以取巧理解为每条路径对应一个节点，路径上包含了该节点所匹配的所有规则）。规则树并不是一开始就为所有节点进行计算，而是在某个节点需要计算样式时，才进行相应的计算并将计算后的路径添加到树中。</p>
<p>　　我们将树上的路径看成辞典中的单词，假如已经计算出了如下的规则树：</p>
<p><img src="/2017/10/28/browser-how-work/16.png" alt=""></p>
<p>　　假如需要为内容树中的另一个节点匹配规则，现在知道匹配的规则（以正确的顺序）为B-E-I，因为我们已经计算出了路径A-B-E-I-L，所以树上已经存在了这条路径，剩下的工作就很少了。</p>
<p>　　现在来看一下树如何保存。</p>
<h3 id="结构化"><a href="#结构化" class="headerlink" title="结构化"></a>结构化</h3><p>　　样式上下文按结构划分，这些结构包括类似border或color这样的特定分类的样式信息。一个结构中的所有特性不是继承的就是非继承的，对继承的特性，除非元素自身有定义，否则就从它的parent继承。非继承的特性（称为reset特性）如果没有定义，则使用默认的值。</p>
<p>　　样式上下文树缓存完整的结构（包括计算后的值），这样，如果底层节点没有为一个结构提供定义，则使用上层节点缓存的结构。</p>
<h3 id="使用规则树计算样式上下文"><a href="#使用规则树计算样式上下文" class="headerlink" title="使用规则树计算样式上下文"></a>使用规则树计算样式上下文</h3><p>　　当为一个特定的元素计算样式时，首先计算出规则树中的一条路径，或是使用已经存在的一条，然后使用路径中的规则去填充新的样式上下文，从样式的底层节点开始，它具有最高优先级（通常是最特定的选择器），遍历规则树，直到填满结构。如果在那个规则节点没有定义所需的结构规则，则沿着路径向上，直到找到该结构规则。</p>
<p>　　如果最终没有找到该结构的任何规则定义，那么如果这个结构是继承型的，则找到其在内容树中的parent的结构，这种情况下，我们也成功的共享了结构；如果这个结构是reset型的，则使用默认的值。</p>
<p>　　如果特定的节点添加了值，那么需要做一些额外的计算以将其转换为实际值，然后在树上的节点缓存该值，使它的children可以使用。</p>
<p>　　当一个元素和它的一个兄弟元素指向同一个树节点时，完整的样式上下文可以被它们共享。</p>
<p>　　来看一个例子：假设有下面这段html</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>this is a</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> big error <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">this is also a</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> verybigerror<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">error</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>another error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　以及下面这些规则<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1<span class="selector-class">.div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;</span><br><span class="line">2.<span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line">3.<span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;</span><br><span class="line">4<span class="selector-class">.div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;</span><br><span class="line">5.<span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;</span><br><span class="line">6.<span class="selector-id">#div2</span> &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　简化下问题，我们只填充两个结构——color和margin，color结构只包含一个成员－颜色，margin结构包含四边。<br>　　生成的规则树如下（节点名：指向的规则）</p>
<p><img src="/2017/10/28/browser-how-work/17.png" alt=""></p>
<p>　　上下文树如下（节点名：指向的规则节点）</p>
<p><img src="/2017/10/28/browser-how-work/18.png" alt=""></p>
<p>　　假设我们解析html，遇到第二个div标签，我们需要为这个节点创建样式上下文，并填充它的样式结构。</p>
<p>　　我们进行规则匹配，找到这个div匹配的规则为1、2、6，我们发现规则树上已经存在了一条我们可以使用的路径1、2，我们只需为规则6新增一个节点添加到下面（就是规则树中的F）。</p>
<p>　　然后创建一个样式上下文并将其放到上下文树中，新的样式上下文将指向规则树中的节点F。</p>
<p>　　现在我们需要填充这个样式上下文，先从填充margin结构开始，既然最后一个规则节点没有添加margin结构，沿着路径向上，直到找到缓存的前面插入节点计算出的结构，我们发现B是最近的指定margin值的节点。因为已经有了color结构的定义，所以不能使用缓存的结构，既然color只有一个属性，也就不需要沿着路径向上填充其他属性。计算出最终值（将字符串转换为RGB等），并缓存计算后的结构。</p>
<p>　　第二个span元素更简单，进行规则匹配后发现它指向规则G，和前一个span一样，既然有兄弟节点指向同一个节点，就可以共享完整的样式上下文，只需指向前一个span的上下文。</p>
<p>　　因为结构中包含继承自parent的规则，上下文树做了缓存（color特性是继承来的，但Firefox将其视为reset并在规则树中缓存）。</p>
<p>　　例如，如果我们为一个paragraph的文字添加规则：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　p &#123;font-family:Verdana;font size:10px;font-weight:bold&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　那么这个p在内容树中的子节点div，会共享和它parent一样的font结构，这种情况发生在没有为这个div指定font规则时。</p>
<p>　　Webkit中，并没有规则树，匹配的声明会被遍历四次，先是应用非important的高优先级属性（之所以先应用这些属性，是因为其他的依赖于它们－比如display），其次是高优先级important的，接着是一般优先级非important的，最后是一般优先级important的规则。这样，出现多次的属性将被按照正确的级联顺序进行处理，最后一个生效。</p>
<p>　　总结一下，共享样式对象（结构中完整或部分内容）解决了问题1和3，Firefox的规则树帮助以正确的顺序应用规则。</p>
<h3 id="对规则进行处理以简化匹配过程"><a href="#对规则进行处理以简化匹配过程" class="headerlink" title="对规则进行处理以简化匹配过程"></a>对规则进行处理以简化匹配过程</h3><p>　　样式规则有几个来源：</p>
<h4 id="外部样式表或style标签内的css规则"><a href="#外部样式表或style标签内的css规则" class="headerlink" title="外部样式表或style标签内的css规则"></a>外部样式表或style标签内的css规则</h4><h4 id="行内样式属性"><a href="#行内样式属性" class="headerlink" title="行内样式属性"></a>行内样式属性</h4><h4 id="html可视化属性（映射为相应的样式规则）"><a href="#html可视化属性（映射为相应的样式规则）" class="headerlink" title="html可视化属性（映射为相应的样式规则）"></a>html可视化属性（映射为相应的样式规则）</h4><p>　　后面两个很容易匹配到元素，因为它们所拥有的样式属性和html属性可以将元素作为key进行映射。</p>
<p>　　就像前面问题2所提到的，css的规则匹配可能很狡猾，为了解决这个问题，可以先对规则进行处理，以使其更容易被访问。</p>
<p>　　解析完样式表之后，规则会根据选择符添加一些hash映射，映射可以是根据id、class、标签名或是任何不属于这些分类的综合映射。如果选择符为id，规则将被添加到id映射，如果是class，则被添加到class映射，等等。</p>
<p>　　这个处理是匹配规则更容易，不需要查看每个声明，我们能从映射中找到一个元素的相关规则，这个优化使在进行规则匹配时减少了95+%的工作量。</p>
<p>　　来看下面的样式规则：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.error</span> &#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="selector-id">#messageDiv</span> &#123;<span class="attribute">height</span>:<span class="number">50px</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　第一条规则将被插入class映射，第二条插入id映射，第三条是标签映射。</p>
<p>　　下面这个html片段：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>an error occurred <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">" messageDiv"</span>&gt;</span>this is a message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　我们首先找到p元素对应的规则，class映射将包含一个“error”的key，找到p.error的规则，div在id映射和标签映射中都有相关的规则，剩下的工作就是找出这些由key对应的规则中哪些确实是正确匹配的。</p>
<p>　　例如，如果div的规则是<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　这也是标签映射产生的，因为key是最右边的选择符，但它并不匹配这里的div元素，因为这里的div没有table祖先。</p>
<p>　　Webkit和Firefox都会做这个处理。</p>
<h4 id="以正确的级联顺序应用规则"><a href="#以正确的级联顺序应用规则" class="headerlink" title="以正确的级联顺序应用规则"></a>以正确的级联顺序应用规则</h4><p>　　样式对象拥有对应所有可见属性的属性，如果特性没有被任何匹配的规则所定义，那么一些特性可以从parent的样式对象中继承，另外一些使用默认值。</p>
<p>　　这个问题的产生是因为存在不止一处的定义，这里用级联顺序解决这个问题。</p>
<h4 id="样式表的级联顺序"><a href="#样式表的级联顺序" class="headerlink" title="样式表的级联顺序"></a>样式表的级联顺序</h4><p>　　一个样式属性的声明可能在几个样式表中出现，或是在一个样式表中出现多次，因此，应用规则的顺序至关重要，这个顺序就是级联顺序。根据css2的规范，级联顺序为（从低到高）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　1. 浏览器声明</span><br><span class="line">　　2. 用户声明</span><br><span class="line">　　3. 作者的一般声明</span><br><span class="line">　　4. 作者的important声明</span><br><span class="line">　　5. 用户important声明</span><br></pre></td></tr></table></figure></p>
<p>　　浏览器声明是最不重要的，用户只有在声明被标记为important时才会覆盖作者的声明。具有同等级别的声明将根据specifity以及它们被定义时的顺序进行排序。Html可视化属性将被转换为匹配的css声明，它们被视为最低优先级的作者规则。</p>
<h4 id="Specifity"><a href="#Specifity" class="headerlink" title="Specifity"></a>Specifity</h4><p>　　Css2规范中定义的选择符specifity如下：</p>
<p>如果声明来自style属性，而不是一个选择器的规则，则计1，否则计0（＝a）</p>
<p>计算选择器中id属性的数量（＝b）</p>
<p>计算选择器中class及伪类的数量（＝c）</p>
<p>计算选择器中元素名及伪元素的数量（＝d）</p>
<p>　　连接a－b－c－d四个数量（用一个大基数的计算系统）将得到specifity。这里使用的基数由分类中最高的基数定义。例如，如果a为14，可以使用16进制。不同情况下，a为17时，则需要使用阿拉伯数字17作为基数，这种情况可能在这个选择符时发生html body div div …（选择符中有17个标签，一般不太可能）。</p>
<p>　　一些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*&#123;&#125;/* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span><br><span class="line">li&#123;&#125;/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span><br><span class="line">li:first-line &#123;&#125;/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line">ul li&#123;&#125;/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line">ul ol+li&#123;&#125;/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span><br><span class="line">h1 + *[rel=up]&#123;&#125;/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span><br><span class="line">ul ol li.red&#123;&#125;/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span><br><span class="line">li.red.level&#123;&#125;/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span><br><span class="line">#x34y&#123;&#125;/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span><br><span class="line">/* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span><br></pre></td></tr></table></figure></p>
<h4 id="规则排序"><a href="#规则排序" class="headerlink" title="规则排序"></a>规则排序</h4><p>　　规则匹配后，需要根据级联顺序对规则进行排序，WebKit先将小列表用冒泡排序，再将它们合并为一个大列表，WebKit通过为规则复写“&gt;”操作来执行排序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</span><br><span class="line">&#123;</span><br><span class="line">int spec1 = r1.selector()-&gt;specificity();</span><br><span class="line">int spec2 = r2.selector()-&gt;specificity();</span><br><span class="line"><span class="keyword">return</span> (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="逐步处理Gradual-process"><a href="#逐步处理Gradual-process" class="headerlink" title="逐步处理Gradual process"></a>逐步处理Gradual process</h4><p>　　webkit使用一个标志位标识所有顶层样式表都已加载，如果在attch时样式没有完全加载，则放置占位符，并在文档中标记，一旦样式表完成加载就重新进行计算。</p>
<h3 id="五、布局（Layout）"><a href="#五、布局（Layout）" class="headerlink" title="五、布局（Layout）"></a>五、布局（Layout）</h3><p>　　当渲染对象被创建并添加到树中，它们并没有位置和大小，计算这些值的过程称为layout或reflow。</p>
<p>　　Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中从右向左、自上而下的进行。也存在一些例外，比如html tables。</p>
<p>　　坐标系统相对于根frame，使用top和left坐标。</p>
<p>　　布局是一个递归的过程，由根渲染对象开始，它对应html文档元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。</p>
<p>　　根渲染对象的位置是0,0，它的大小是viewport－浏览器窗口的可见部分。</p>
<p>　　所有的渲染对象都有一个layout或reflow方法，每个渲染对象调用需要布局的children的layout方法。</p>
<h3 id="Dirty-bit系统"><a href="#Dirty-bit系统" class="headerlink" title="Dirty bit系统"></a>Dirty bit系统</h3><p>　　为了不因为每个小变化都全部重新布局，浏览器使用一个dirty bit系统，一个渲染对象发生了变化或是被添加了，就标记它及它的children为dirty——需要layout。存在两个标识——dirty及children are dirty，children are dirty说明即使这个渲染对象可能没问题，但它至少有一个child需要layout。</p>
<h3 id="全局和增量layout"><a href="#全局和增量layout" class="headerlink" title="全局和增量layout"></a>全局和增量layout</h3><p>　　当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：</p>
<p>　　1. 一个全局的样式改变影响所有的渲染对象，比如字号的改变。</p>
<p>　　2. 窗口resize。</p>
<p>　　layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局）。增量layout会在渲染对象dirty时异步触发，例如，当网络接收到新的内容并添加到Dom树后，新的渲染对象会添加到渲染树中。</p>
<p><img src="/2017/10/28/browser-how-work/19.png" alt=""></p>
<p>图20：增量layout</p>
<h4 id="异步和同步layout"><a href="#异步和同步layout" class="headerlink" title="异步和同步layout"></a>异步和同步layout</h4><p>　　增量layout的过程是异步的，Firefox为增量layout生成了reflow队列，以及一个调度执行这些批处理命令。WebKit也有一个计时器用来执行增量layout－遍历树，为dirty状态的渲染对象重新布局。</p>
<p>　　另外，当脚本请求样式信息时，例如“offsetHeight”，会同步的触发增量布局。</p>
<p>　　全局的layout一般都是同步触发。</p>
<p>　　有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>　　当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。</p>
<p>　　一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。</p>
<h4 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h4><p>　　layout一般有下面这几个部分：</p>
<p>　　1. parent渲染对象决定它的宽度</p>
<p>　　2. parent渲染对象读取chilidren，并：</p>
<p>　　　　a. 放置child渲染对象（设置它的x和y）</p>
<p>　　　　b. 在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度</p>
<p>　　　　c. parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用</p>
<p>　　　　d. 将dirty标识设置为false</p>
<p>　　Firefox使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。</p>
<p>　　Firefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。</p>
<h4 id="宽度计算"><a href="#宽度计算" class="headerlink" title="宽度计算"></a>宽度计算</h4><p>　　渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。例如，下面这个div的宽度：</p>
<p>　　<code>&lt;div /&gt;</code></p>
<p>　　webkit中宽度的计算过程是（RenderBox类的calcWidth方法）：</p>
<p>容器的宽度是容器的可用宽度和0中的最大值，这里的可用宽度为：contentWidth=clientWidth()-paddingLeft()-paddingRight()，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小</p>
<p>元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值</p>
<p>加上水平方向上的border和padding</p>
<p>　　到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。</p>
<h4 id="Line-breaking"><a href="#Line-breaking" class="headerlink" title="Line breaking"></a>Line breaking</h4><p>　　当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。</p>
<h3 id="六、绘制（Painting）"><a href="#六、绘制（Painting）" class="headerlink" title="六、绘制（Painting）"></a>六、绘制（Painting）</h3><p>　　绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件，这在UI的章节有更多的介绍。</p>
<h4 id="全局和增量"><a href="#全局和增量" class="headerlink" title="全局和增量"></a>全局和增量</h4><p>　　和布局一样，绘制也可以是全局的——绘制完整的树——或增量的。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统将其看作dirty区域，并产生一个paint事件，操作系统很巧妙的处理这个过程，并将多个区域合并为一个。Chrome中，这个过程更复杂些，因为渲染对象在不同的进程中，而不是在主进程中。Chrome在一定程度上模拟操作系统的行为，表现为监听事件并派发消息给渲染根，在树中查找到相关的渲染对象，重绘这个对象（往往还包括它的children）。</p>
<h4 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h4><p>　　css2定义了绘制过程的顺序—— <a href="http://www.w3.org/TR/CSS21/zindex.html" target="_blank" rel="external">http://www.w3.org/TR/CSS21/zindex.html</a> 。这个就是元素压入堆栈的顺序，这个顺序影响着绘制，堆栈从后向前进行绘制。</p>
<p>　　一个块渲染对象的堆栈顺序是：</p>
<p>　　1. 背景色</p>
<p>　　2. 背景图</p>
<p>　　3. border</p>
<p>　　4. children</p>
<p>　　5. outline</p>
<p>　　Firefox显示列表</p>
<p>　　Firefox读取渲染树并为绘制的矩形创建一个显示列表，该列表以正确的绘制顺序包含这个矩形相关的渲染对象。</p>
<p>　　用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。</p>
<p>　　Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。</p>
<h4 id="WebKit矩形存储"><a href="#WebKit矩形存储" class="headerlink" title="WebKit矩形存储"></a>WebKit矩形存储</h4><p>　　重绘前，WebKit将旧的矩形保存为位图，然后只绘制新旧矩形的差集。</p>
<h3 id="七、动态变化"><a href="#七、动态变化" class="headerlink" title="七、动态变化"></a>七、动态变化</h3><p>　　浏览器总是试着以最小的动作响应一个变化，所以一个元素颜色的变化将只导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个Dom节点，也会大致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致缓存失效，从而引起整数的布局和重绘。</p>
<h3 id="八、渲染引擎的线程"><a href="#八、渲染引擎的线程" class="headerlink" title="八、渲染引擎的线程"></a>八、渲染引擎的线程</h3><p>　　渲染引擎是单线程的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的主线程，Chrome中这是tab的主线程。</p>
<p>　　网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。</p>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>　　浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们。下面是Firefox的主要事件循环代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mExiting)</span><br><span class="line">NS_ProcessNextEvent(thread);</span><br></pre></td></tr></table></figure></p>
<h3 id="九、CSS2可视模型（CSS2-visual-module）"><a href="#九、CSS2可视模型（CSS2-visual-module）" class="headerlink" title="九、CSS2可视模型（CSS2 visual module）"></a>九、CSS2可视模型（CSS2 visual module）</h3><h4 id="画布The-Canvas"><a href="#画布The-Canvas" class="headerlink" title="画布The Canvas"></a>画布The Canvas</h4><p>　　根据CSS2规范，术语canvas用来描述格式化的结构所渲染的空间——浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。</p>
<p>　　根据 <a href="http://www.w3.org/TR/CSS2/zindex.html" target="_blank" rel="external">http://www.w3.org/TR/CSS2/zindex.html</a> 的定义，画布如果是包含在其他画布内则是透明的，否则浏览器会指定一个颜色。</p>
<h4 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h4><p>　　CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域。</p>
<p><img src="/2017/10/28/browser-how-work/20.jpg" alt=""></p>
<p>　　每个节点生成0－n个这样的box。</p>
<p>　　所有的元素都有一个display属性，用来决定它们生成box的类型，例如：</p>
<p>　　block －生成块状box</p>
<p>　　inline －生成一个或多个行内box</p>
<p>　　none －不生成box</p>
<p>　　默认的是inline，但浏览器样式表设置了其他默认值，例如，div元素默认为block。可以访问 <a href="http://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="external">http://www.w3.org/TR/CSS2/sample.html</a> 查看更多的默认样式表示例。</p>
<h4 id="定位策略Position-scheme"><a href="#定位策略Position-scheme" class="headerlink" title="定位策略Position scheme"></a>定位策略Position scheme</h4><p>　　这里有三种策略：</p>
<p>　　1. normal －对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。</p>
<p>　　2. float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。</p>
<p>　　3. absolute －对象在渲染树中的位置和Dom树中位置无关。</p>
<p>　　static和relative是normal，absolute和fixed属于absolute。</p>
<p>　　在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。</p>
<p>　　Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。</p>
<h4 id="Box类型"><a href="#Box类型" class="headerlink" title="Box类型"></a>Box类型</h4><p>　　Block box：构成一个块，即在浏览器窗口上有自己的矩形</p>
<p><img src="/2017/10/28/browser-how-work/21.png" alt=""></p>
<p>　　Inline box：并没有自己的块状区域，但包含在一个块状区域内</p>
<p><img src="/2017/10/28/browser-how-work/22.png" alt=""></p>
<p>　　block一个挨着一个垂直格式化，inline则在水平方向上格式化。</p>
<p><img src="/2017/10/28/browser-how-work/23.png" alt=""></p>
<p>　　Inline盒模型放置在行内或是line box中，每行至少和最高的box一样高，当box以baseline对齐时——即一个元素的底部和另一个box上除底部以外的某点对齐，行高可以比最高的box高。当容器宽度不够时，行内元素将被放到多行中，这在一个p元素中经常发生。</p>
<p><img src="/2017/10/28/browser-how-work/24.png" alt=""></p>
<h4 id="定位Position"><a href="#定位Position" class="headerlink" title="定位Position"></a>定位Position</h4><h4 id="Relative"><a href="#Relative" class="headerlink" title="Relative"></a>Relative</h4><p>　　相对定位——先按照一般的定位，然后按所要求的差值移动。</p>
<p><img src="/2017/10/28/browser-how-work/25.png" alt=""></p>
<h4 id="Floats"><a href="#Floats" class="headerlink" title="Floats"></a>Floats</h4><p>　　一个浮动的box移动到一行的最左边或是最右边，其余的box围绕在它周围。下面这段html：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/image.gif"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span>Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　将显示为：</p>
<p><img src="/2017/10/28/browser-how-work/26.png" alt=""></p>
<h4 id="Absolute和Fixed"><a href="#Absolute和Fixed" class="headerlink" title="Absolute和Fixed"></a>Absolute和Fixed</h4><p>　　这种情况下的布局完全不顾普通的文档流，元素不属于文档流的一部分，大小取决于容器。Fixed时，容器为viewport（可视区域）。</p>
<p><img src="/2017/10/28/browser-how-work/27.png" alt=""></p>
<p>图17：fixed</p>
<p>　　注意－fixed即使在文档流滚动时也不会移动。</p>
<h4 id="Layered-representation"><a href="#Layered-representation" class="headerlink" title="Layered representation"></a>Layered representation</h4><p>　　这个由CSS属性中的z-index指定，表示盒模型的第三个大小，即在z轴上的位置。Box分发到堆栈中（称为堆栈上下文），每个堆栈中靠后的元素将被较早绘制，栈顶靠前的元素离用户最近，当发生交叠时，将隐藏靠后的元素。堆栈根据z-index属性排序，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">div &#123;</span></span><br><span class="line"><span class="undefined">position: absolute;</span></span><br><span class="line"><span class="undefined">left: 2in;</span></span><br><span class="line"><span class="undefined">top: 2in;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DIV</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DIV</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　结果是：</p>
<p><img src="/2017/10/28/browser-how-work/28.png" alt=""></p>
<p>　　虽然绿色div排在红色div后面，可能在正常流中也已经被绘制在后面，但z-index有更高优先级，所以在根box的堆栈中更靠前。</p>
<p>来源：<a href="http://kb.cnblogs.com/page/129756/" target="_blank" rel="external">http://kb.cnblogs.com/page/129756/</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/28/nodejs-appjs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/nodejs-appjs/" itemprop="url">
                  Nodejs之目录介绍及app.js说明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-28 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-28T23:47:44+08:00">2017-10-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 15:35:42" itemprop="dateModified" datetime="2017-11-11T15:35:42+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Node-js/" itemprop="url" rel="index"><span itemprop="name">Node.js</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>新建的项目结构应该是这样</p>
<p><img src="/2017/10/28/nodejs-appjs/1.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bin：项目的启动文件，也可以放其他脚本。</span><br><span class="line">node_modules：用来存放项目的依赖库。</span><br><span class="line">public：用来存放静态文件(css,js,img)。</span><br><span class="line">routes：路由控制器。</span><br><span class="line">views：视图目录(相当于MVC中的V)。</span><br><span class="line">app.js：项目入口及程序启动文件。</span><br><span class="line">package.json：包描述文件及开发者信息。</span><br><span class="line">---------------------其他，自己创建使用---------------------</span><br><span class="line">models：数据模型(相当于MVC中的M)。</span><br><span class="line">controllers：控制器,对请求的操作(相当于MVC中的C)。</span><br><span class="line">tools：工具库。</span><br><span class="line">config：配置目录。</span><br><span class="line">test：测试目录。</span><br><span class="line">README.md：项目说明文件。</span><br></pre></td></tr></table></figure>
<p>app.js文件简单说明及设置app.js文件为启动文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块依赖</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> favicon = <span class="built_in">require</span>(<span class="string">'serve-favicon'</span>);</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> routes = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>);</span><br><span class="line"><span class="keyword">var</span> users = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>); </span><br><span class="line"><span class="comment">//添加,导入http模块</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express(); </span><br><span class="line"><span class="comment">//设置端口号</span></span><br><span class="line">app.set(<span class="string">'port'</span>, process.env.PORT || <span class="number">3000</span>);</span><br><span class="line"><span class="comment">//视图引擎设置</span></span><br><span class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>); </span><br><span class="line"><span class="comment">//加载环境变量</span></span><br><span class="line">app.use(logger(<span class="string">'dev'</span>));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>))); </span><br><span class="line"><span class="comment">//加载路由</span></span><br><span class="line">app.use(<span class="string">'/'</span>, routes);</span><br><span class="line">app.use(<span class="string">'/users'</span>, users); </span><br><span class="line"><span class="comment">//启动及端口</span></span><br><span class="line">http.createServer(app).listen(app.get(<span class="string">'port'</span>),<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Express server listening on port '</span> + app.get(<span class="string">'port'</span>));</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">//加载错误处理解决办法</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;  </span><br><span class="line">     <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Found'</span>);</span><br><span class="line">     err.status = <span class="number">404</span>;</span><br><span class="line">     next(err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (app.get(<span class="string">'env'</span>) === <span class="string">'development'</span>) &#123;  </span><br><span class="line">    app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;    </span><br><span class="line">    res.status(err.status || <span class="number">500</span>);</span><br><span class="line">    res.render(<span class="string">'error'</span>, &#123;      </span><br><span class="line">         message: err.message,      </span><br><span class="line">         error: err    </span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">      res.status(err.status || <span class="number">500</span>);  </span><br><span class="line">      res.render(<span class="string">'error'</span>, &#123; </span><br><span class="line">          message: err.message,</span><br><span class="line">          error: &#123;&#125;  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>//导出app对象<br>module.exports = app;<br>来源：<a href="http://www.cnblogs.com/Chen-xy/p/4466351.html" target="_blank" rel="external">http://www.cnblogs.com/Chen-xy/p/4466351.html</a> 、 <a href="http://nodejs.cn/" target="_blank" rel="external">Node.js中文官网</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/28/freemarker-views/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/freemarker-views/" itemprop="url">
                  Spring MVC视图解析器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-28 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-28T23:47:44+08:00">2017-10-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 16:32:54" itemprop="dateModified" datetime="2017-11-11T16:32:54+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Spring-Cloud/" itemprop="url" rel="index"><span itemprop="name">Spring Cloud</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、从freemarker谈起"><a href="#一、从freemarker谈起" class="headerlink" title="一、从freemarker谈起"></a>一、从freemarker谈起</h3><p>Freemarker使用模板技术进行视图的渲染。自从看了Struts标签、Freemarker、JSTL的性能对比后，我毅然决定放弃Struts标签了！效率太差……</p>
<p>Spring本身支持了对Freemarker的集成。只需要配置一个针对Freemarker的视图解析器即可。</p>
<h3 id="二、Spring-MVC视图解析器"><a href="#二、Spring-MVC视图解析器" class="headerlink" title="二、Spring MVC视图解析器"></a>二、Spring MVC视图解析器</h3><p>视图解析器的工作流程大致是这样的：</p>
<p>Controller的某个方法执行完成以后，返回一个视图（比如：listUser）<br>视图解析器要做的工作就是找到某个对象来完成视图的渲染，或者跳转到其他的逻辑视图。这里的渲染对象通常就是我们的jsp文件或者我们下面用的Freemarker(例如listUser.jsp或者listUser.ftl)。渲染完成以后，将解析结果发送到客户端浏览器</p>
<p>下面介绍一下本文需要用到的解析器<a href="http://e-freya.iteye.com/blog/384083" target="_blank" rel="external">更多解析器资料</a>：</p>
<p>InternalResourceViewResolver：这是一个最常用的解析器。通常使用它指定渲染对象为jsp页面</p>
<p>FreeMarkerViewResolver：这就是Spring与Freemarker整合需要用到的解析器</p>
<h3 id="三、配置多视图，支持freemarker"><a href="#三、配置多视图，支持freemarker" class="headerlink" title="三、配置多视图，支持freemarker"></a>三、配置多视图，支持freemarker</h3><p>我们通常不希望所有的动态页面请求都使用Freemarker来渲染，那就需要配置多个视图解析器。网上有很多这方面的帖子。我看到很多人的做法是在web.xml中配置两个DispatcherServlet,一个拦截.do，一个拦截.ftl;然后再写两个dispatcherServlet.xml,配置两个视图解析器；jsp页面、ftl模板就各司其职。 其实没有那么复杂。</p>
<p>1.Web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"2.4"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ======================================================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--                  Spring MVC Config Servlet               --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ======================================================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JSP DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/classes/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ======================================================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--                  Spring MVC Config Mapping               --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ======================================================== --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.dispatcherServlet.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">  http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">  http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">  http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">  http://www.springframework.org/schema/mvc  http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通用视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolverCommon"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/page/"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span><span class="comment">&lt;!--可为空,方便实现自已的依据扩展名来选择视图解释类的逻辑  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.springframework.web.servlet.view.InternalResourceView<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置freeMarker视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolverFtl"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerView"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"contentType"</span> <span class="attr">value</span>=<span class="string">"text/html; charset=utf-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cache"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".ftl"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置freeMarker的模板路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"freemarkerConfig"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"templateLoaderPath"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/WEB-INF/ftl/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"freemarkerVariables"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"xml_escape"</span> <span class="attr">value-ref</span>=<span class="string">"fmXmlEscape"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"freemarkerSettings"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"template_update_delay"</span>&gt;</span>3600<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"fmXmlEscape"</span> <span class="attr">class</span>=<span class="string">"freemarker.template.utility.XmlEscape"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注解支持 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对包中的所有类进行扫描，以完成Bean创建和自动依赖注入的功能 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.hl.usersmanager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 允许定义过滤器将基包下的某些类纳入或排除</span></span><br><span class="line"><span class="comment">        &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hl.usersmanager.controller;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> com.hl.usersmanager.model.Users;</span><br><span class="line"><span class="keyword">import</span> com.hl.usersmanager.service.IUserService;</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="comment">//  使用注解实现自动装配 不需要再写get set方法以及在context中配置bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"findUserByName.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserByName</span><span class="params">(String name,ModelMap model)</span> </span>&#123;</span><br><span class="line">        Users users = userService.findUserByName(name);</span><br><span class="line">        model.addAttribute(<span class="string">"userPhone"</span>,users.getPhone());</span><br><span class="line">        System.out.println(<span class="string">"userPhone："</span> + users.getPhone());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"showUser"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"findAllUsers.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAllUsers</span><span class="params">(ModelMap model)</span> </span>&#123;</span><br><span class="line">        List&lt;Users&gt; users = userService.findAllUsers();</span><br><span class="line">        model.addAttribute(<span class="string">"users"</span>,users);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"listUser"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在视图解析器中有一个<code>&lt;property name=&quot;order&quot; value=&quot;orderValue&quot;/&gt;</code>的配置，这个配置表示解析器的优先级别。我们将FreeMarkerViewResolver的级别设为0,将InternalResourceViewResolver的级别设为1。这样，解析器就会优先使用 FreeMarkerViewResolver 进行解析，如果找不到相应的模板，就使用InternalResourceViewResolver进行解析，如果还找不到页面，就会产生一个404错误！</p>
<p>在本例中，我们在/WEB-INF/page/下有一个showUser.jsp页面，在/WEB-INF/ftl/下有一个listUser.ftl的模板文件。那么当访问findAllUsers.do的时候，Controller返回一个listUser视图，根据解析器配置，先使用FreeMarkerViewResolver进行解析。它会根据模板路径templateLoaderPath的配置/WEB-INF/ftl/下去找是否有一个listUser并且以后缀配置suffix值.ftl，即listUser.ftl文件，如果找到则使用该模板进行解析。这里我们实现已经创建了这个模板文件，所以user列表成功被显示出来。</p>
<p>当用户访问findUserByName.do的时候，返回showUser视图，毅然先使用FreeMarkerViewResolver进行解析，结果发现在/WEB-INF/ftl/下并没有showUser.ftl这个模板文件，于是使用InternalResourceViewResolver进行解析，于是开始寻找/WEB-INF/page/下是否有showUser.jsp文件。由于我们已经创建了这个文件，于是最终使用showUser.jsp进行渲染。那么如果没有找到showUser.jsp，就会抛出404错误。</p>
<p>这里还要注意的是，如果Controller中返回视图加了后缀jsp或者ftl，在配置中就不要加入suffix配置，否则会找不到页面。</p>
<p>来源：<a href="http://www.tashan10.com/spring-mvcde-duo-shi-tu-jie-xi-qi-pei-zhi/" target="_blank" rel="external">http://www.tashan10.com/spring-mvcde-duo-shi-tu-jie-xi-qi-pei-zhi/</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/28/proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/proxy/" itemprop="url">
                  反向代理 Reverse Proxy
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-28 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-28T23:47:44+08:00">2017-10-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 16:28:42" itemprop="dateModified" datetime="2017-11-11T16:28:42+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在计算机世界里，由于单个服务器的处理客户端（用户）请求能力有一个极限，当用户的接入请求蜂拥而入时，会造成服务器忙不过来的局面，可以使用多个服务器来共同分担成千上万的用户请求，这些服务器提供相同的服务，对于用户来说，根本感觉不到任何差别。</p>
<h3 id="反向代理的实现"><a href="#反向代理的实现" class="headerlink" title="反向代理的实现"></a>反向代理的实现</h3><p>1）需要有一个负载均衡设备来分发用户请求，将用户请求分发到空闲的服务器上</p>
<p>2）服务器返回自己的服务到负载均衡设备</p>
<p>3）负载均衡将服务器的服务返回用户</p>
<p>以上的潜台词是：<strong>用户和负载均衡设备直接通信，也意味着用户做服务器域名解析时，解析得到的IP其实是负载均衡的IP，而不是服务器的IP</strong>，这样有一个好处是，当新加入/移走服务器时，仅仅需要修改负载均衡的服务器列表，而不会影响现有的服务。谈完反向代理服务，再来谈谈终端用户常用的代理服务。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>1）用户希望代理服务器帮助自己，和要访问服务器通信，为了实现此目标，需要以下工作：</p>
<p>a) 用户IP报文的目的IP = 代理服务器IP</p>
<p>b) 用户报文端口号 = 代理服务器监听端口号</p>
<p>c) HTTP 消息里的URL要提供服务器的链接</p>
<p>2）代理服务器可以根据c)里的链接与服务器直接通信</p>
<p>3）服务器返回网页</p>
<p>4）代理服务器打包3）中的网页，返回用户。</p>
<h3 id="代理服务器应用场景"><a href="#代理服务器应用场景" class="headerlink" title="代理服务器应用场景"></a>代理服务器应用场景</h3><h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h4><p>如果不采用代理，用户的IP、端口号直接暴露在Internet（尽管地址转换NAT），外部主机依然可以根据IP、端口号来开采主机安全漏洞，所以在企业网，一般都是采用代理服务器访问互联网。那有同学会有疑问，那代理服务器就没有安全漏洞吗？相比千千万万的用户主机，代理服务器数量有限，修补安全漏洞更方便快捷。</p>
<h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><p>在一个超大型局域网，德高望重的家长觉得小盆友们“幼稚”、“有时还有点单纯”，外部的世界是洪水猛兽，为了不让小盆友们学坏，决定不让小盆友们访问一些网站，可小盆友们有强烈的逆反心理，侬越是不让我看，我越是想看，于是小盆友们使用了代理服务器，这些代理服务器将禁止访问的网页打包好，然后再转交给小盆友，仅此而已。当然关键的关键是代理服务器不在禁止名单当中！</p>
<p>来源：<a href="https://www.zhihu.com/question/24723688" target="_blank" rel="external">https://www.zhihu.com/question/24723688</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/26/token/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/token/" itemprop="url">
                  基于token的多平台身份认证架构设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-26 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-26T23:47:44+08:00">2017-10-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 13:03:12" itemprop="dateModified" datetime="2017-11-11T13:03:12+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>在存在账号体系的信息系统中，对身份的鉴定是非常重要的事情。<br>随着移动互联网时代到来，客户端的类型越来越多， 逐渐出现了 一个服务器，N个客户端的格局 。</p>
<p><img src="/2017/10/26/token/1.png" alt=""></p>
<p>不同的客户端产生了不同的用户使用场景，这些场景：</p>
<ul>
<li><p>有不同的环境安全威胁</p>
</li>
<li><p>不同的会话生存周期</p>
</li>
<li><p>不同的用户权限控制体系</p>
</li>
<li><p>不同级别的接口调用方式</p>
</li>
</ul>
<p>综上所述，它们的身份认证方式也存在一定的区别。</p>
<p>本文将使用一定的篇幅对这些场景进行一些分析和梳理工作。</p>
<h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2 使用场景"></a>2 使用场景</h2><p>下面是一些在IT服务常见的一些使用场景:</p>
<ul>
<li><p>用户在web浏览器端登录系统,使用系统服务</p>
</li>
<li><p>用户在手机端（Android/iOS）登录系统,使用系统服务</p>
</li>
<li><p>用户使用开放接口登录系统,调用系统服务</p>
</li>
<li><p>用户在PC处理登录状态时通过手机扫码授权手机登录（使用得比较少）</p>
</li>
<li><p>用户在手机处理登录状态进通过手机扫码授权PC进行登录（比较常见）</p>
</li>
</ul>
<h4 id="通过对场景的细分-得到如下不同的认证token类别"><a href="#通过对场景的细分-得到如下不同的认证token类别" class="headerlink" title="通过对场景的细分,得到如下不同的认证token类别:"></a>通过对场景的细分,得到如下不同的认证token类别:</h4><h4 id="1-原始账号密码类别"><a href="#1-原始账号密码类别" class="headerlink" title="1- 原始账号密码类别"></a>1- 原始账号密码类别</h4><ul>
<li><p>用户名和密码</p>
</li>
<li><p>API应用ID/KEY</p>
</li>
</ul>
<h4 id="2-会话ID类别"><a href="#2-会话ID类别" class="headerlink" title="2- 会话ID类别"></a>2- 会话ID类别</h4><ul>
<li><p>浏览器端token</p>
</li>
<li><p>移动端token</p>
</li>
<li><p>API应用token</p>
</li>
</ul>
<h4 id="3-接口调用类别"><a href="#3-接口调用类别" class="headerlink" title="3- 接口调用类别"></a>3- 接口调用类别</h4><ul>
<li>接口访问token</li>
</ul>
<h4 id="4-身份授权类别"><a href="#4-身份授权类别" class="headerlink" title="4- 身份授权类别"></a>4- 身份授权类别</h4><ul>
<li>PC和移动端相互授权的token</li>
</ul>
<h2 id="3-token的类别"><a href="#3-token的类别" class="headerlink" title="3 token的类别"></a>3 token的类别</h2><h4 id="不同场景的token进行如下几个维度的对比"><a href="#不同场景的token进行如下几个维度的对比" class="headerlink" title="不同场景的token进行如下几个维度的对比:"></a>不同场景的token进行如下几个维度的对比:</h4><h3 id="天然属性-对比"><a href="#天然属性-对比" class="headerlink" title="天然属性 对比:"></a>天然属性 对比:</h3><h4 id="1-使用成本"><a href="#1-使用成本" class="headerlink" title="1- 使用成本"></a>1- 使用成本</h4><p>本认证方式在使用的时候,造成的不便性。比如:</p>
<p>账号密码需要用户打开页面然后逐个键入</p>
<p>二维码需要用户掏出手机进行扫码操作</p>
<h4 id="2-变化成本"><a href="#2-变化成本" class="headerlink" title="2- 变化成本"></a>2- 变化成本</h4><ul>
<li><p>本认证方式,token发生变化时,用户需要做出的相应更改的成本:</p>
</li>
<li><p>用户名和密码发生变化时,用户需要额外记忆和重新键入新密码</p>
</li>
<li><p>API应用ID/KEY发生变化时,第三方应用需要重新在代码中修改并部署</p>
</li>
<li><p>授权二维码发生变化时,需要用户重新打开手机应用进行扫码</p>
</li>
</ul>
<h4 id="3-环境风险"><a href="#3-环境风险" class="headerlink" title="3- 环境风险"></a>3- 环境风险</h4><ul>
<li><p>被偷窥的风险</p>
</li>
<li><p>被抓包的风险</p>
</li>
<li><p>被伪造的风险</p>
</li>
</ul>
<h3 id="可调控属性-对比"><a href="#可调控属性-对比" class="headerlink" title="可调控属性 对比:"></a>可调控属性 对比:</h3><h4 id="1-使用频率"><a href="#1-使用频率" class="headerlink" title="1- 使用频率"></a>1- 使用频率</h4><ul>
<li>在网路中传送的频率</li>
</ul>
<h4 id="2-有效时间"><a href="#2-有效时间" class="headerlink" title="2- 有效时间"></a>2- 有效时间</h4><ul>
<li>此token从创建到终结的生存时间</li>
</ul>
<p>最终的目标:安全和影响。</p>
<h4 id="安全和隐私性主要体现在"><a href="#安全和隐私性主要体现在" class="headerlink" title="安全和隐私性主要体现在:"></a>安全和隐私性主要体现在:</h4><ul>
<li>token 不容易被窃取和盗用（通过对传送频率控制）</li>
<li>token 即使被窃取,产生的影响也是可控的（通过对有效时间控制）</li>
</ul>
<h4 id="关于隐私及隐私破坏后的后果-有如下的基本结论"><a href="#关于隐私及隐私破坏后的后果-有如下的基本结论" class="headerlink" title="关于隐私及隐私破坏后的后果,有如下的基本结论:"></a>关于隐私及隐私破坏后的后果,有如下的基本结论:</h4><ul>
<li><p>1- 曝光频率高的容易被截获</p>
</li>
<li><p>2- 生存周期长的在被截获后产生的影响更严重和深远</p>
</li>
</ul>
<h4 id="遵守如下原则"><a href="#遵守如下原则" class="headerlink" title="遵守如下原则:"></a>遵守如下原则:</h4><ul>
<li><p>1- 变化成本高的token不要轻易变化</p>
</li>
<li><p>2-不轻易变化的token要减少曝光频率（网络传输次数）</p>
</li>
<li><p>3- 曝光频率高的token的生存周期要尽量短</p>
</li>
</ul>
<p>将各类token的固有特点及可控属性进行调控后, 对每个指标进行量化评分（1~5分），我们可以得到如下的对比表：</p>
<p><img src="/2017/10/26/token/2.png" alt=""></p>
<p><code>备注:user_name/passwd 和 app_id/app_key 是等价的效果</code></p>
<h2 id="4-token的层级关系"><a href="#4-token的层级关系" class="headerlink" title="4 token的层级关系"></a>4 token的层级关系</h2><p>参考上一节的对比表，可以很容易对这些不同用途的token进行分层，主要可以分为4层：</p>
<p>1- 密码层</p>
<ul>
<li>最传统的用户和系统之间约定的数字身份认证方式</li>
</ul>
<p>2- 会话层</p>
<ul>
<li>用户登录后的会话生命周期的会话认证</li>
</ul>
<p>3- 调用层</p>
<ul>
<li>用户在会话期间对应用程序接口的调用认证</li>
</ul>
<p>4- 应用层</p>
<ul>
<li>用户获取了接口访问调用权限后的一些场景或者身份认证应用</li>
</ul>
<p>token的分层图如下：</p>
<p><img src="/2017/10/26/token/3.png" alt=""></p>
<p>在一个多客户端的信息系统里面,这些token的产生及应用的内在联系如下:</p>
<ul>
<li><p>1- 用户输入用户名和用户口令进行一次性认证</p>
</li>
<li><p>2- 在 不同 的终端里面生成拥有 不同 生命周期的会话token</p>
</li>
<li><p>3- 客户端会话token从服务端交换生命周期短但曝光 频繁 的接口访问token</p>
</li>
<li><p>4- 会话token可以生成和刷新延长 access_token 的生存时间</p>
</li>
<li><p>5- access_token可以生成生存周期最短的用于授权的二维码的token</p>
</li>
</ul>
<p>使用如上的架构有如下的好处：</p>
<ul>
<li><p>1- 良好的统一性。可以解决不同平台上认证token的生存周期的 归一化 问题</p>
</li>
<li><p>2- 良好的解耦性。核心接口调用服务器的认证 access_token 可以完成独立的实现和部署</p>
</li>
<li><p>3- 良好的层次性。不同平台的可以有完全不同的用户权限控制系统，这个控制可以在 会话层 中各平台解决掉</p>
</li>
</ul>
<h4 id="4-1-账号密码"><a href="#4-1-账号密码" class="headerlink" title="4.1 账号密码"></a>4.1 账号密码</h4><p>广义的 账号/密码 有如下的呈现方式:</p>
<ul>
<li><p>1- 传统的注册用户名和密码</p>
</li>
<li><p>2- 应用程序的app_id/app_key</p>
</li>
</ul>
<p>它们的特点如下：</p>
<p>1- 会有特别的意义</p>
<p>比如：用户自己为了方便记忆，会设置有一定含义的账号和密码。</p>
<p>2- 不常修改</p>
<p>账号密码对用户有特别含义，一般没有特殊情况不会愿意修改。 而app_id/app_key则会写在应用程序中，修改会意味着重新发布上线的成本</p>
<p>3- 一旦泄露影响深远</p>
<p>正因为不常修改，只要泄露了基本相当于用户的网络身份被泄露，而且只要没被察觉这种身份盗用就会一直存在</p>
<p>所以在认证系统中应该尽量减少传输的机会，避免泄露。</p>
<h4 id="4-2-客户端会话token"><a href="#4-2-客户端会话token" class="headerlink" title="4.2 客户端会话token"></a>4.2 客户端会话token</h4><p>功能：充当着session的角色，不同的客户端有不同的生命周期。</p>
<p>使用步骤：</p>
<p>1- 用户使用账号密码，换取会话token</p>
<p>不同的平台的token有不同的特点。</p>
<p>Web平台生存周期短</p>
<p>主要原因：</p>
<p>1- 环境安全性</p>
<p>由于web登录环境一般很可能是公共环境，被他人盗取的风险值较大</p>
<p>2- 输入便捷性</p>
<p>在PC上使用键盘输入会比较便捷</p>
<h4 id="移动端生存周期长"><a href="#移动端生存周期长" class="headerlink" title="移动端生存周期长"></a>移动端生存周期长</h4><p>主要原因：</p>
<p>1- 环境安全性</p>
<p>移动端平台是个人用户极其私密的平台，它人接触的机会不大</p>
<p>2- 输入便捷性</p>
<p>在移动端上使用手指在小屏幕上触摸输入体验差，输入成本高</p>
<h4 id="4-3-access-token"><a href="#4-3-access-token" class="headerlink" title="4.3 access_token"></a>4.3 access_token</h4><p>功能：服务端应用程序api接口访问和调用的凭证。</p>
<p>使用步骤：</p>
<p>1- 使用具有较长生命周期的会话token来换取此接口访问token。</p>
<p>其曝光频率直接和接口调用频率有关，属于高频使用的凭证。 为了照顾到隐私性，尽量减少其生命周期，即使被截取了，也不至于产生严重的后果。</p>
<p>注意：在客户端token之下还加上一个access_token， 主要是为了让具有不同生命周期的客户端token最后在调用api的时候， 能够具有统一的认证方式。</p>
<h4 id="4-4-pam-token"><a href="#4-4-pam-token" class="headerlink" title="4.4 pam_token"></a>4.4 pam_token</h4><p>功能：由已经登录和认证的PC端生成的二维码的原始串号（Pc Auth Mobile）。</p>
<p>主要步骤如下：</p>
<p>1- PC上用户已经完成认证，登录了系统</p>
<p>2- PC端生成一组和此用户相关联的pam_token</p>
<p>3- PC端将此pam_token的使用链接生成二维码</p>
<p>4- 移动端扫码后，请求服务器，并和用户信息关联</p>
<p>5- 移动端获取refresh_token(长时效的会话)</p>
<p>6- 根据 refresh_token 获取 access_token</p>
<p>7- 完成正常的接口调用工作</p>
<p>备注:</p>
<ul>
<li><p>生存周期为2分钟,2分钟后过期删除</p>
</li>
<li><p>没有被使用时,每1分钟变一次</p>
</li>
<li><p>被使用后,立刻删除掉</p>
</li>
<li><p>此种认证模式一般不会被使用到</p>
</li>
</ul>
<h4 id="4-5-map-token"><a href="#4-5-map-token" class="headerlink" title="4.5 map_token"></a>4.5 map_token</h4><p>功能：由已经登录的移动app来扫码认证PC端系统，并完成PC端系统的登录（Mobile Auth Pc）。</p>
<p>主要步骤：</p>
<p>1- 移动端完成用户身份的认证登录app</p>
<p>2- 未登录的PC生成匿名的 map_token</p>
<p>3- 移动端扫码后在db中生成 map_token 和用户关联（完成签名）</p>
<p>4- db同时针对此用户生成 web_token</p>
<p>5- PC端一直以 map_token 为参数查找此命名用户的 web_token</p>
<p>6- PC端根据 web_token 去获取 access_token</p>
<p>7- 后续正常的调用接口调用工作</p>
<p>备注:</p>
<ul>
<li><p>生存周期为2分钟,2分钟后过期删除</p>
</li>
<li><p>没有被使用时,每1分钟变一次</p>
</li>
<li><p>被使用后,立刻删除掉</p>
</li>
</ul>
<h2 id="5-小结与展望"><a href="#5-小结与展望" class="headerlink" title="5 小结与展望"></a>5 小结与展望</h2><p>本文所设计的基于token的身份认证系统，主要解决了如下的问题：</p>
<ul>
<li><p>1- token的分类问题</p>
</li>
<li><p>2- token的隐私性参数设置问题</p>
</li>
<li><p>3- token的使用场景问题</p>
</li>
<li><p>4- 不同生命周期的token分层转化关系</p>
</li>
</ul>
<p>本文中提到的设计方法，在 应用层 中可以适用于且不限于如下场景中：</p>
<ul>
<li><p>1- 用户登录</p>
</li>
<li><p>2- 有时效的优惠券发放</p>
</li>
<li><p>3- 有时效的邀请码发放</p>
</li>
<li><p>4- 有时效的二维码授权</p>
</li>
<li><p>5- 具有时效 手机/邮件 验证码</p>
</li>
<li><p>6- 多个不同平台调用同一套API接口</p>
</li>
<li><p>7- 多个平台使用同一个身份认证中心</p>
</li>
</ul>
<p>至于更多的使用场景，就需要大家去发掘了。</p>
<p>关于如何在技术上实现不同token的生存周期问题，将在后续文章中进行介绍，敬请期待。</p>
<hr>
<h2 id="具备生命周期的数据的技术实现方案"><a href="#具备生命周期的数据的技术实现方案" class="headerlink" title="具备生命周期的数据的技术实现方案"></a>具备生命周期的数据的技术实现方案</h2><h3 id="1-数据生命周期"><a href="#1-数据生命周期" class="headerlink" title="1 数据生命周期"></a>1 数据生命周期</h3><p>所谓的 “数据生命周期” 是指：为数据设定一定的生存期限,过了这个时间后， 此数据就被删除掉（失效）。在进行web开发的时候,有很多需求场景是要求数据是具有一定的生命周期，比如:</p>
<p>具有一定时效的用户登录会话</p>
<p>邀请码系统的时效控制</p>
<p>具有时效的二维码/短信/邮件验证系统</p>
<p>接口调用认证的token有效期</p>
<p>第三方授权的期限控制</p>
<p>分享内容的时效控制</p>
<p>记录一段时间的日志</p>
<p>本文将以如下两种数据库特性为例子来对此功能的实现进行介绍:</p>
<p>mongodb</p>
<p>redis</p>
<h3 id="2-mongodb"><a href="#2-mongodb" class="headerlink" title="2 mongodb"></a>2 mongodb</h3><h4 id="2-1-实现方法"><a href="#2-1-实现方法" class="headerlink" title="2.1 实现方法"></a>2.1 实现方法</h4><p>在mongodb中有个 TTL（Time To Live 生存时间）索引 功能:</p>
<p>TTL索引是一种特殊索引，通过这种索引 MongoDB 会过一段时间后自动移除集合中的文档。 这对于某些类型的信息来说是一个很理想的特性，例如: 机器生成的事件数据，日志，会话信息等，这些数据都只需要在数据库中保存有限时间。</p>
<p>如果你可以设定这个生命周期是多久他只要过了这段时间之后，它就会自动删除掉</p>
<p>删除的周期就是一分钟左右（和mongodb服务的负载有关），mongodb后台会进行周期性地检查这些索引字段<br>在 mongodb 中的实现方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.ttl_log_session.createIndex( &#123; <span class="string">"lastModifiedDate"</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">expireAfterSeconds</span>: <span class="number">3600</span> &#125; )</span><br></pre></td></tr></table></figure>
<p>主要解释如下:</p>
<p>对 ttl_log_session 合集建立索引</p>
<p>索引字段为 lastModifiedDate</p>
<p>索引顺序是 升序</p>
<p>有效生存周期为 3600 秒</p>
<p>达到的效果:<br>以 lastModifiedDate 时刻开始,经过 3600 秒之后,此文档会失效被删除掉。</p>
<h4 id="2-2-过期时间精度"><a href="#2-2-过期时间精度" class="headerlink" title="2.2 过期时间精度"></a>2.2 过期时间精度</h4><p>删除操作的一些注意事项:</p>
<p>TTL索引 不能 保证过期数据会被立刻删除<br>在文档过期和MongoDB从数据库中删除文档之间，可能会有延迟。</p>
<p>删除过期数据的后台任务每隔60秒运行一次<br>在文档过期之后和后台任务运行或者结束之前，文档会依然存在于集合中（删除操作还没有完成）。</p>
<p>删除操作的持续实际取决于您的 mongod 实例的负载<br>在两次后台任务运行的间隔间，过期数据可能会继续留在数据库中超过60秒。</p>
<h3 id="3-redis"><a href="#3-redis" class="headerlink" title="3 redis"></a>3 redis</h3><p>redis是一个内存数据库,它具备快速IO的特点。在性能上会比Mongodb进行大幅度提升。</p>
<h4 id="3-1-实现方式"><a href="#3-1-实现方式" class="headerlink" title="3.1 实现方式"></a>3.1 实现方式</h4><p>通过如下方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key seconds</span><br></pre></td></tr></table></figure>
<p>为给定的key设置生存时间,当key过期时（生存时间为0）,它会被自动删除。</p>
<p>如下是一些设置生存时间相关的基本操作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET cache_page <span class="string">"www.google.com"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE cache_page 30  # 设置过期时间为 30 秒</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL cache_page    # 查看剩余生存时间</span><br><span class="line">(integer) <span class="number">23</span></span><br><span class="line">redis&gt; EXPIRE cache_page 30000   # 更新过期时间</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL cache_page</span><br><span class="line">(integer) <span class="number">29996</span></span><br></pre></td></tr></table></figure>
<p>注意事项:</p>
<ul>
<li><p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)</p>
</li>
<li><p>如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样</p>
</li>
<li><p>将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key</p>
</li>
</ul>
<h4 id="3-2-过期时间精度"><a href="#3-2-过期时间精度" class="headerlink" title="3.2 过期时间精度"></a>3.2 过期时间精度</h4><p>在 Redis 2.4 版本中，过期时间的延迟在 1s 之内<br>就算key已经过期，但它还是可能在过期之后一秒钟之内被访问到</p>
<p>在新的 Redis 2.6 以后的版本中，延迟被降低到 1ms 之内</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h3><p>在进行web开发过程中,很多场合都需要用到数据的生命周期的功能。 关于如何实现此功能时,可以参考如下结论后再进行相应的技术选型:</p>
<p>本文关于 <strong>“数据生命周期”</strong> 主题的主要结论如下:</p>
<p>可以通过在web应用层上面做一些定时任务,但是那样的效率远没有直接在数据库层做操作要效率高</p>
<p>内存数据库（Reids）在过期时间精度上面的控制要远比磁盘数据库（MongoDB）要强得多,可能达到6万倍<br>在进行技术选型时注意在如下几个特性上进行比较：</p>
<ul>
<li><p>1- IO速度</p>
</li>
<li><p>2- 数据持久化</p>
</li>
<li><p>3- 数据的备份和复制集</p>
</li>
<li><p>4- 数据库对多核心的利用</p>
</li>
<li><p>5- 数据库集群的部署的成本和难度</p>
</li>
<li><p>6- 开发的成本和难度</p>
</li>
</ul>
<p>最终能够得出合适自己的技术方案，实现自己系统的功能。</p>
<p>来源：<a href="http://www.cnblogs.com/beer/p/6029861.html" target="_blank" rel="external">http://www.cnblogs.com/beer/p/6029861.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/26/jni/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/jni/" itemprop="url">
                  Andoid NDK编程 － 注册native函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-26 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-26T23:47:44+08:00">2017-10-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 13:22:05" itemprop="dateModified" datetime="2017-11-11T13:22:05+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当java代码中执行native的代码时候，首先是通过一定的方法来找到这些native方法。而注册native函数的具体方法的不同，会导致系统在运行时采用不同的方式来寻找这些native方法。JNI有如下两种注册native方法的途径：静态和动态。其中：</p>
<p>静态：先由Java得到本地方法的声明，然后再通过JNI实现该声明方法。</p>
<p>动态：先通过JNI重载JNI_OnLoad()实现本地方法，然后直接在Java中调用本地方法。</p>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>根据函数名找到对应的JNI函数:Java层调用函数时，会从对应的JNI中寻找该函数，如果没有就会报错，如果存在则会建立一个关联联系，以后在调用时会直接使用这个函数，这部分的操作由虚拟机完成。<br>静态方法就是根据函数名来遍历java和jni函数之间的关联，而且要求jni层函数的名字必须遵循<br>特定的格式。</p>
<p>具体的实现很简单，首先在java代码中声明native函数，然后通过javah来生成native函数的具体形式，接下来在JNI代码中实现这些函数即可。</p>
<p>看个例子就更明了了：</p>
<p>Java层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   System.loadLibrary(<span class="string">"samplelib_jni"</span>);</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeFunc1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeFunc2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeFunc3</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>接下来通过javah来产生jni代码声明：</p>
<p>假设你的java文件的包名是com.jni.samle 而类名是JniSample。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -d ./jni/ -classpath /Users/YOUR_NAME/Library/Android/sdk/platforms/android<span class="number">-21</span>/android.jar:../../build/intermediates/classes/debug/ com.jni.samle.JniSample</span><br></pre></td></tr></table></figure>
<p>然后就会得到一个JNI的.h文件，里面包含这几个native函数的声明，观察一下文件名以及函数名，会有一定的规律，我会在下一篇文章中对此做一详细介绍，在此不再赘述。</p>
<p>最后实现jni层的native方法即可。</p>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>对Java程序员来说，可能我们总是会遵循：1.编写带有native方法的Java类；—-&gt;2.使用javah命令生成.h头文件；—-&gt;3.编写代码实现头文件中的方法，这样的标准流程，但也许有人无法忍受那“丑陋”的方法名称，所以我们可以采用动态注册方法，也就是通过RegisterNatives方法把c/c++中的方法隐射到Java中的native方法，而无需遵循特定的方法命名格式。</p>
<p>JNI 允许你提供一个函数映射表，注册给Jave虚拟机，这样Jvm就可以用函数映射表来调用相应的函数，<br>就可以不必通过函数名来查找需要调用的函数了。<br>Java与JNI通过JNINativeMethod的结构来建立联系，它在jni.h中被定义，其结构内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature; </span><br><span class="line">    <span class="keyword">void</span>* fnPtr; </span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>
<p>第一个变量name是Java中函数的名字。</p>
<p>第二个变量signature，用字符串是描述了函数的参数和返回值</p>
<p>第三个变量fnPtr是函数指针，指向C函数。</p>
<p>当java通过System.loadLibrary加载完JNI动态库后，紧接着会查找一个JNI_OnLoad的函数，如果有，就调用它， 而动态注册的工作就是在这里完成的。</p>
<p>一起来看一下具体的实现方法：</p>
<p>Java code:</p>
<p>比较简单，仅仅是加载so库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"samplelib_jni"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JNI code:</p>
<p>在JNI中实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span></span><br></pre></td></tr></table></figure></p>
<p>并且在这个函数里面去动态的注册native方法，完整的参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Log4Android.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *className = <span class="string">"com/zhixin/jnisample/JniManager"</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(JNIEnv *env, jobject, jlong handle)</span> </span>&#123;</span><br><span class="line">    LOGI(<span class="string">"JNI"</span>, <span class="string">"native: say hello ###"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gJni_Methods_table[] = &#123;</span><br><span class="line">    &#123;<span class="string">"sayHello"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*)sayHello&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jniRegisterNativeMethods</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line">    LOGI(<span class="string">"JNI"</span>,<span class="string">"Registering %s natives\n"</span>, className);</span><br><span class="line">    clazz = (env)-&gt;FindClass( className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"JNI"</span>,<span class="string">"Native registration unable to find class '%s'\n"</span>, className);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((env)-&gt;RegisterNatives(clazz, gJni_Methods_table, numMethods) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"JNI"</span>,<span class="string">"RegisterNatives failed for '%s'\n"</span>, className);</span><br><span class="line">        result = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (env)-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span>&#123;</span><br><span class="line">    LOGI(<span class="string">"JNI"</span>, <span class="string">"enter jni_onload"</span>);</span><br><span class="line">    JNIEnv* env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span>**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    jniRegisterNativeMethods(env, className, gJni_Methods_table, <span class="keyword">sizeof</span>(gJni_Methods_table) / <span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>下面我们来比较一下这两种不同的实现方法。</p>
<h4 id="首先是静态方法："><a href="#首先是静态方法：" class="headerlink" title="首先是静态方法："></a>首先是静态方法：</h4><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>实现起来比较简单，直接用javah就能将Java代码中的native函数的声明转化为native代码的函数。</p>
<h3 id="缺点在于："><a href="#缺点在于：" class="headerlink" title="缺点在于："></a>缺点在于：</h3><p>javah生成的jni层函数特别长；<br>初次调用native函数时要根据名字搜索对应的jni层函数来建立关联联系，这样影响效率。</p>
<h4 id="而动态方法的优缺点刚好和静态方法相反。"><a href="#而动态方法的优缺点刚好和静态方法相反。" class="headerlink" title="而动态方法的优缺点刚好和静态方法相反。"></a>而动态方法的优缺点刚好和静态方法相反。</h4><p>通过上面的介绍我们发现，尽管静态注册实现起来比较简单，但是会导致效率相对来说比较低。</p>
<p>所以在JNI层提供JNI_OnLoad是一个推荐的做法。如果不提供JNI_OnLoad，那么JNI函数的命名就需要符合规范，并且需要导出该函数。这样做很容易被别人反编译。相反，如果提供JNI_OnLoad，就可以在里面自己注册JNI函数给Dalvik VM，这样JNI函数的命名就可以按照自己的习惯了，而且也不用导出。</p>
<h3 id="一个巧妙的合作"><a href="#一个巧妙的合作" class="headerlink" title="一个巧妙的合作"></a>一个巧妙的合作</h3><p>在实际的应用中，我们可以巧妙的将静态注册和动态注册结合起来：也就是在java代码中仍然声明一个native函数，但是这个函数仅仅是用来去触发在JNI层的native函数的动态注册。说的有些绕，看看代码就明白了：</p>
<p>Java层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   System.loadLibrary(<span class="string">"samplelib_jni"</span>);</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>JNI层：</p>
<p>通过javah生成java层声明的native函数的文件，并且在实现代码中去动态注册JNI函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_zhixin_jni_JniSample_registerNatives</span><br><span class="line">(JNIEnv *env, jclass clazz)&#123;</span><br><span class="line">     (env)-&gt;RegisterNatives(clazz, gJni_Methods_table, <span class="keyword">sizeof</span>(gJni_Methods_table) / <span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：<a href="http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/" target="_blank" rel="external">http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">107</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
