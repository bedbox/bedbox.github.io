<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Codes Online">
<meta property="og:url" content="http://51codes.top/page/7/index.html">
<meta property="og:site_name" content="Codes Online">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Codes Online">






  <link rel="canonical" href="http://51codes.top/page/7/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Codes Online</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Codes Online</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _enjoying</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/11/04/h5-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/04/h5-intro/" itemprop="url">
                  初识HTML5
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-04 23:47:44" itemprop="dateCreated datePublished" datetime="2017-11-04T23:47:44+08:00">2017-11-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 20:22:14" itemprop="dateModified" datetime="2017-11-11T20:22:14+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、认识HTML5"><a href="#一、认识HTML5" class="headerlink" title="一、认识HTML5"></a>一、认识HTML5</h3><h3 id="1-什么是HTML5"><a href="#1-什么是HTML5" class="headerlink" title="1. 什么是HTML5"></a>1. 什么是HTML5</h3><p>HTML 5草案的前身名为Web Applications 1.0，是在2004年由WHATWG提出，再于2007年获W3C接纳，并成立了新的HTML工作团队。在2008年1月22日，第一份正式草案发布。WHATWG表示该规范是目前仍在进行的工作，仍须多年的努力。目前Firefox、Google Chrome、Opera、Safari（版本4以上）、Internet Explorer 9已支援HTML5技术。</p>
<p>HTML5本质并没有对之前HTML4版本的规范进行彻底的变革，而是一开始设计就考虑了跟之前的标准进行兼容，并且把最新的WEB开发的一些新技术新的规范引入进了新版本的标准中。</p>
<h3 id="2-HTML5新特性"><a href="#2-HTML5新特性" class="headerlink" title="2. HTML5新特性"></a>2. HTML5新特性</h3><h3 id="2-1-新增拥有具体含义的标签"><a href="#2-1-新增拥有具体含义的标签" class="headerlink" title="2.1 新增拥有具体含义的标签"></a>2.1 新增拥有具体含义的标签</h3><p>现在所有的站点基本上都是div+css布局，几乎所有的文章标题、内容、辅助介绍等都用div容器来承载。搜索引擎在抓取页面内容时，因为没有明确的容器的含义只能去猜测这些标签容器承载的是文章标题还是文章内容等。HTML5新标准中直接添加了拥有具体含义的HTML标签比如：<code>&lt;article&gt;、&lt;footer&gt;、&lt;header&gt;、&lt;nav&gt;、&lt;section&gt;</code>。</p>
<h3 id="2-2-新增更加智能的表单类型"><a href="#2-2-新增更加智能的表单类型" class="headerlink" title="2.2 新增更加智能的表单类型"></a>2.2 新增更加智能的表单类型</h3><p>之前的表单标签仅仅是简单的类型的约束，比如文本框、文本域、下拉列表等。而跟业务结合紧密的表单标签数据校验等控制都没有很好的支持，基本上都是跟第三方的JS控件进行结合使用，但是这些第三方总会涉及到版本控制、浏览器兼容性、非标准等一系列的问题。而在HTML5的标准中直接添加了智能表单，让这一切都变得那么的简单，比如calendar、date、time、email、url、search</p>
<h3 id="2-3-让Web程序更加的独立，减少了对第三方插件的依赖。"><a href="#2-3-让Web程序更加的独立，减少了对第三方插件的依赖。" class="headerlink" title="2.3 让Web程序更加的独立，减少了对第三方插件的依赖。"></a>2.3 让Web程序更加的独立，减少了对第三方插件的依赖。</h3><p>在HTML5标准中原生的就支持音频、视频、画布等技术。让WEB程序更加独立，更好的适应多种形式的客户端。</p>
<h3 id="2-4-对本地离线存储的更好的支持"><a href="#2-4-对本地离线存储的更好的支持" class="headerlink" title="2.4 对本地离线存储的更好的支持"></a>2.4 对本地离线存储的更好的支持</h3><p>HTML5 提供了两种在客户端存储数据的新方法：</p>
<p>localStorage - 没有时间限制的数据存储</p>
<p>sessionStorage- 针对一个 session 的数据存储</p>
<h3 id="2-5-HTML5即时二维绘图-既画布的引入"><a href="#2-5-HTML5即时二维绘图-既画布的引入" class="headerlink" title="2.5 HTML5即时二维绘图 ,既画布的引入"></a>2.5 HTML5即时二维绘图 ,既画布的引入</h3><p>HTML5 的canvas元素使用 JavaScript 在网页上绘制图像。并拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p>
<h3 id="2-6-JS支持多线程"><a href="#2-6-JS支持多线程" class="headerlink" title="2.6 JS支持多线程"></a>2.6 JS支持多线程</h3><p>在不影响UI update及浏览器与用户交互的情况下, 前端做大规模运算，只能通过setTimeout之类的去模拟多线程 。而新的标准中，JS新增的HTML5 Web Worker对象原生的就支持多线程。</p>
<h3 id="2-7-WebSockets让跨域请求、长连接、数据推送变得简单"><a href="#2-7-WebSockets让跨域请求、长连接、数据推送变得简单" class="headerlink" title="2.7 WebSockets让跨域请求、长连接、数据推送变得简单"></a>2.7 WebSockets让跨域请求、长连接、数据推送变得简单</h3><p>WebSockets是在一个(TCP)接口进行双向通信的技术，PUSH技术类型。WebSocket是html5规范新引入的功能，用于解决浏览器与后台服务器双向通讯的问题，使用WebSocket技术，后台可以随时向前端推送消息，以保证前后台状态统一，在传统的无状态HTTP协议中，这是“无法做到”的。</p>
<h3 id="2-8-更好的异常处理"><a href="#2-8-更好的异常处理" class="headerlink" title="2.8 更好的异常处理"></a>2.8 更好的异常处理</h3><p>HTML5(text/html)浏览器将在错误语法的处理上更加灵活。HTML5在设计时保证旧的浏览器能够安全地忽略掉新的HTML5代码。与HTML4.01相比，HTML5给出了解析的完整规则，让不同的浏览器即使在发生语法错误时也能返回完全相同的结果。</p>
<h3 id="2-9-文件API让文件上传和操纵文件变得那么简单"><a href="#2-9-文件API让文件上传和操纵文件变得那么简单" class="headerlink" title="2.9 文件API让文件上传和操纵文件变得那么简单"></a>2.9 文件API让文件上传和操纵文件变得那么简单</h3><p>由于项目中经常遇到用Web应用中控制操作本地文件，而之前都是使用一些富客户端技术比如flash，ActiveX，Silverlight等技术。在HTML5的新的提供的HTML5 File API让JS可以轻松上阵了。</p>
<h3 id="二、HTML5的新的结构元素介绍"><a href="#二、HTML5的新的结构元素介绍" class="headerlink" title="二、HTML5的新的结构元素介绍"></a>二、HTML5的新的结构元素介绍</h3><h3 id="1、HTML5与HTML4的区别"><a href="#1、HTML5与HTML4的区别" class="headerlink" title="1、HTML5与HTML4的区别"></a>1、HTML5与HTML4的区别</h3><p>取消了一些过时的HTML4的标签</p>
<p>其中包括纯粹显示效果的标记，如<font>和<center>，它们已经被CSS完全取代。</center></font></p>
<p>其他取消的属性:acronym,applet,basefont,big,center,dir,font,frame,frameset,isindex,noframes,strike,tt</p>
<p>添加了一些新的元素</p>
<p>更加智能的表单元素：date,email,url等; 更加合理的标签：<code>&lt;section&gt;,&lt;video&gt;,&lt;progress&gt;,&lt;nav&gt;,&lt;meter&gt;,&lt;time&gt;,&lt;aside&gt;,&lt;canvas&gt;</code>等。</p>
<p>文件类型声明</p>
<p>仅有一种类型，&lt;!DOCTYPE html&gt;</p>
<h3 id="2、HTML5的新结构标签"><a href="#2、HTML5的新结构标签" class="headerlink" title="2、HTML5的新结构标签"></a>2、HTML5的新结构标签</h3><p>普通的页面布局方式：</p>
<p><img src="/2017/11/04/h5-intro/1.png" alt=""></p>
<p>以上是很常见的div+css布局模式，通过class来区分不同的结构，包括头部、导航、文章内容、右边栏，还有底部模块。</p>
<p>而HTML5新标签带来的新的布局则是下面这种情况：</p>
<p><img src="/2017/11/04/h5-intro/2.png" alt=""></p>
<p>html5中心的布局方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">header</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">nav</span>&gt;</span>nav<span class="tag">&lt;/<span class="name">nav</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">section</span>&gt;</span>section<span class="tag">&lt;/<span class="name">section</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">article</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">footer</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>拥有具体含义的标签，使得代码有很直观的感受，搜索器也能很容易地抓取合适的信息。</p>
<p><code>&lt;section&gt;</code></p>
<p>定义文档中的节。它用来表现普通的文档内容或应用区块，但section元素标签并非一个普通的容器元素，它表示一段专题性的内容，一般会带有标题。</p>
<p><code>&lt;article&gt;</code></p>
<p>特殊的section标签，它比section具有更明确的语义，它代表一个独立的、完整的相关内容块。当我们描述一件具体的事物的时候，通常鼓励使用article来代替section。</p>
<p>article会有标题部分（通常包含在header内），也可以包含footer。</p>
<p>article可以嵌套，内层的article对外层的article标签有隶属关系。</p>
<p><code>&lt;nav&gt;</code></p>
<p>可以作为页面导航的链接组，其中的导航元素链接到其它页面或者当前页面的其它部分，使html代码在语义化方面更加精确，同时对于屏幕阅读器等设备的支持也更好。</p>
<p><code>&lt;aside&gt;</code></p>
<p>aside标签用来装载非正文的内容，被视为页面里面一个单独的部分。它包含的内容与页面的主要内容是分开的，可以被删除，而不会影响到网页的内容、章节或是页面所要传达的信息。例如广告，成组的链接，侧边栏等等。</p>
<p><code>&lt;header&gt;</code></p>
<p>header标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页头部，也可以写在网页内容里面。</p>
<p>通常header标签至少包含一个标题标记（h1-h6），还可以包括hgroup标签，还可以包括表格内容、标识、搜索表单、nav导航等。</p>
<p><code>&lt;footer&gt;</code></p>
<p>footer标签定义section或document的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。 它和header标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入footer，那么它就相当于该区段的页脚了。</p>
<p><code>&lt;hgroup&gt;</code></p>
<p>hgroup标签是对网页或区段section的标题元素（h1-h6）进行组合。例如，在一区段中你有连续的h系列的标签元素，则可以用hgroup将他们括起来。</p>
<p><code>&lt;figure&gt;</code></p>
<p>用于对元素进行组合。多用于图片与图片描述组合。</p>
<p>來源：<a href="http://www.jianshu.com/p/2bc035eabec3" target="_blank" rel="external">http://www.jianshu.com/p/2bc035eabec3</a></p>
<p>附：<a href="http://www.jianshu.com/p/4c81dcd44494" target="_blank" rel="external">12款设计精美HTML5网站模板（完全免费）</a> 、<a href="https://ke.qq.com/course/20945" target="_blank" rel="external">视频教程</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/11/02/vue-project/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/02/vue-project/" itemprop="url">
                  基于vue的全家桶小项目
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-02 23:47:44" itemprop="dateCreated datePublished" datetime="2017-11-02T23:47:44+08:00">2017-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 20:16:15" itemprop="dateModified" datetime="2017-11-11T20:16:15+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Node-js/" itemprop="url" rel="index"><span itemprop="name">Node.js</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="vn-pastime"><a href="#vn-pastime" class="headerlink" title="vn-pastime"></a>vn-pastime</h3><p>基于vue全家桶、mongodb和nodejs的全栈项目,其实是个大杂烩。通过这个项目，了解前后端的整合，以及产品上线的基本流程</p>
<p>前端使用axios与后台api交互获取数据，vue全家桶进行数据的管理和渲染，mongodb存储网上爬取的原始数据以及用户后期产生的数据，nodejs主要提供api接口以及token的签发与验证</p>
<p>线上使用阿里云服务器部署，nginx进行http反向代理，pm2管理Node应用的进程</p>
<p>线上地址： <a href="http://www.xxxuthus.cn" target="_blank" rel="external">http://www.xxxuthus.cn</a></p>
<p>仓库地址: <a href="https://github.com/xxxgitone/vue-node-pastime" target="_blank" rel="external">https://github.com/xxxgitone/vue-node-pastime</a></p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>这个项目本身并不复杂，最主要的是清扫了一些后台的盲区，满足了自己的好奇心，特别是在项目部署这一块。虽然还没有达到熟悉的地步，但提起也不至于什么也不知道。</p>
<p>后期将会优化前端的代码，比如代码的结构和书写规范，以及vue的组件规范，还有响应式的实现，也可能会添加一些新的模块。</p>
<p>主要目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── app.js   // 后台入口</span><br><span class="line">├── index.html</span><br><span class="line">├── server  // 服务端文件</span><br><span class="line">│   ├── api  // api借口</span><br><span class="line">│   ├── middlewares</span><br><span class="line">│   │   └── jwtMid.js  // token验证中间件</span><br><span class="line">│   ├── models  // mongodb的文档模型</span><br><span class="line">│   └── public</span><br><span class="line">├── src  // 前端主文件</span><br><span class="line">│   ├── api  // 前端api，与后台api的交互</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   ├── assets  // 静态资源</span><br><span class="line">│   │   ├── font</span><br><span class="line">│   │   ├── img</span><br><span class="line">│   │   └── scss</span><br><span class="line">│   ├── components // 单个组件</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   ├── router</span><br><span class="line">│   ├── store</span><br><span class="line">│   ├── utils // axios拦截器</span><br><span class="line">│   │   └── axiosService.js</span><br><span class="line">│   └── views // 页面级组件</span><br></pre></td></tr></table></figure></p>
<h3 id="主要功能-期待更多"><a href="#主要功能-期待更多" class="headerlink" title="主要功能(期待更多)"></a>主要功能(期待更多)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[x] 视频播放列表的展示</span><br><span class="line">[x] 视频播放器自定义样式</span><br><span class="line">[x] 视频评论功能，包括二级评论，自定义简单的富文本组件，用于评论的编辑</span><br><span class="line">[x] 基于token进行登录验证</span><br><span class="line">[x] 图片的展示列表</span><br><span class="line">[x] 图片滚动加载</span><br><span class="line">[x] 图片详情页展示，支持上下张切换以及评论</span><br><span class="line">[x] 使用socket.io进行简单聊天室</span><br><span class="line">[x] 图片上传预览</span><br></pre></td></tr></table></figure>
<h3 id="项目总结和感想"><a href="#项目总结和感想" class="headerlink" title="项目总结和感想"></a>项目总结和感想</h3><h3 id="组件编写应该规范"><a href="#组件编写应该规范" class="headerlink" title="组件编写应该规范"></a>组件编写应该规范</h3><p>vue上手容易，可以很轻松的实现一些功能。但是要让代码变得更加容易维护和扩展，还得做点其他工作。组件编写规范化便是一个非常有效的方法，组件一般分为基础组件和业务组件，组件应该各司其职，比如基础组件就不应该包含跟业务相关的具体代码，只是返回一个信息，给引用它的组件。这样可以降低组件的耦合度，提升组件的可复用性。</p>
<p>比如一个confirm组件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"confirm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-confirm"</span> <span class="attr">v-show</span>=<span class="string">"showFlag"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-header"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>提示信息<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-text"</span>&gt;</span></span><br><span class="line">        &#123;&#123; text &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-button"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"confirm"</span>&gt;</span>&#123;&#123; confirmBtnText &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"cancle"</span>&gt;</span>&#123;&#123; cancleBtnText &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  props: &#123;</span></span><br><span class="line"><span class="undefined">    text: &#123;</span></span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    confirmBtnText: &#123;</span></span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">'确定'</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    cancleBtnText: &#123;</span></span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">'取消'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      showFlag: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    hide () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.showFlag = <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    show () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.showFlag = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    confirm () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.hide()</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$emit(<span class="string">'confirm'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    cancle () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.hide()</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$emit(<span class="string">'cancle'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在点击确认后，不应该直接在这里组件里面处理接下来的逻辑（比如删除或着清空），而是应该通过this.$emit(‘confirm’)向父组件传递一个确认的信息，父组件监听这个方法，然后再处理接下来的逻辑</p>
<p>这个项目后续将会重点围绕这点来进行优化</p>
<h3 id="前后端如何分离"><a href="#前后端如何分离" class="headerlink" title="前后端如何分离"></a>前后端如何分离</h3><p>这是之前我最想知道的问题，听过很多前后端分离，但是都是只闻其声，不见其形。</p>
<p>之前同学问过我这样一个问题，<strong>为什么前端也要单独起一个服务</strong>，当时我脑海里，闪过的第一个答案就是，现在前端构建项目需要依赖很多包，需要通过node环境来安装各种依赖工作，帮助我们工作。</p>
<p>现在看来这个答案大错特错了，问的是服务，而不是node环境。其实这个问题的答案和前后端分离也和相关</p>
<p>在传统web开发的时候，前端和后端的工作比较耦合，后端人员要做着很多前端的工作，不停切换，比如发送后台请求。这样导致前后端分工不明确，效率反而更加低。不仅如此，而且前后端还要搭建同样的开发环境，让前端开发去搭建一个Java开发环境，显得有些复杂，而且确实没必要。</p>
<p>现代web开发，前后端各司其职，开发之前约定好数据接口和格式，就可以同时开发了。</p>
<p>前端负责静态样式的编写，以及发送ajax请求，后台负责api的开发和测试。双方都不用管对方具体怎么实现。</p>
<p><img src="/2017/11/02/vue-project/1.png" alt=""></p>
<p>前面也说到过前端不应该去搭建一个复杂的Java或者其他后台服务，我们可以通过nodejs来搭建一个服务器，寥寥几行代码，便可快速搭建，搭建nodejs服务器的好处</p>
<ul>
<li><p>可以模拟线上环境，毕竟本地静态文件和线上还是有些差别，比如路径等</p>
</li>
<li><p>发送ajax，还要处理跨域</p>
</li>
<li><p>部署线上，中间层，用于加载静态文件</p>
</li>
</ul>
<h3 id="前后端如何部署"><a href="#前后端如何部署" class="headerlink" title="前后端如何部署"></a>前后端如何部署</h3><p>在前后端完全分离的情况下，前端和后端当然是分别部署(本案例由于是自己一个人写的，并且后台语言正好是nodejs，所以没有将前后端分别部署），比如www.xxxuthus.cn， 那么后台api可以使用一个二级域名 api.xxxuthus.cn</p>
<p>前端部署，nodejs为一个中间层，作为静态文件服务器，比如将webpack打包后的dist作为静态资源</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> env = process.env.NODE_ENV || <span class="string">'development'</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line">app.use(express.static(<span class="string">'./dist'</span>))</span><br><span class="line"><span class="keyword">const</span> server = app.listen(<span class="number">4000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Express started in <span class="subst">$&#123;app.get(<span class="string">'env'</span>)&#125;</span> mode on http://localhsot:4000`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用nginx进行反向代理，当用户访问静态资源的时候，返回静态资源，当前台访问api的时候，转发到后台服务器</p>
<p>该配置文件是该项目的，该项目没有严格按照前后端分离部署，所以其它场景配置文件仅供参考</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  upstream xxxuthus &#123;</span><br><span class="line">  server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4000</span>;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen <span class="number">80</span>;</span><br><span class="line">  server_name www.xxxuthus.cn;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_set_header X-Nginx-Proxt <span class="literal">true</span>;</span><br><span class="line">    proxy_pass http:<span class="comment">//xxxuthus;</span></span><br><span class="line">    proxy_redirect off;</span><br><span class="line">  &#125;</span><br><span class="line">  location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt) &#123;</span><br><span class="line">    root /www/vnpastime/production/current/dist;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/11/02/vue-project/2.png" alt=""></p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>前后端分离，就会面临着跨域问题，比较常用的跨域CORS，proxy代理以及nginx反向代理</p>
<p>在开发环境中我一般使用proxy代理的方式，通过在config/index.js下面设置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  <span class="string">'/api'</span>:&#123;</span><br><span class="line">    target: <span class="string">'http://localhost:4000'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/auth'</span>:&#123;</span><br><span class="line">    target: <span class="string">'http://localhost:4000'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>我们前端服务为8080，当我们访问/api/**的时候，便会转发到端口为4000的服务上</p>
<p>生产环境我使用的是nginx代理，前面已经有所介绍</p>
<h3 id="Node-js项目部署工具pm2"><a href="#Node-js项目部署工具pm2" class="headerlink" title="Node.js项目部署工具pm2"></a>Node.js项目部署工具pm2</h3><p>pm2是node的一个进程管理器，能够保证进程永远或者，使用它部署变得相当容易</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure>
<p>配置文件，在项目根目录项新建文件ecosystem.json</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"apps"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"vnpastime"</span>,</span><br><span class="line">      <span class="string">"script"</span>: <span class="string">"app.js"</span>,</span><br><span class="line">      <span class="string">"env"</span>: &#123;</span><br><span class="line">        <span class="string">"COMMON_VARIABLE"</span>: <span class="string">"true"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"env_production"</span> : &#123;</span><br><span class="line">        <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"deploy"</span>: &#123;</span><br><span class="line">    <span class="string">"production"</span>: &#123;</span><br><span class="line">      <span class="string">"user"</span>: <span class="string">"xuthus_y"</span>,</span><br><span class="line">      <span class="string">"host"</span>: [<span class="string">"106.14.173.2"</span>],</span><br><span class="line">      <span class="string">"port"</span>: <span class="string">"22"</span>,</span><br><span class="line">      <span class="string">"ref"</span>: <span class="string">"origin/master"</span>,</span><br><span class="line">      <span class="string">"repo"</span>: <span class="string">"git@github.com:xxxgitone/vue-node-pastime.git"</span>,</span><br><span class="line">      <span class="string">"path"</span>: <span class="string">"/www/vnpastime/production"</span>,</span><br><span class="line">      <span class="string">"ssh_options"</span>: <span class="string">"StrictHostKeyChecking=no"</span>,</span><br><span class="line">      <span class="string">"post-deploy"</span> : <span class="string">"npm install &amp;&amp; npm run build &amp;&amp; pm2 startOrRestart ecosystem.json --env production"</span>,</span><br><span class="line">      <span class="string">"env"</span>  : &#123;</span><br><span class="line">        <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将该文件push到github中，初次启动执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.json production setup</span><br></pre></td></tr></table></figure>
<p>然后<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.json production</span><br></pre></td></tr></table></figure></p>
<p>可以在服务器，通过pm2 list和pm2 logs分别查看部署成功的应用和部署日志</p>
<p>以后每次修改的项目，push到github后，直接在本地通过<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.json production</span><br></pre></td></tr></table></figure></p>
<p>就可以更新线上的内容了</p>
<p><a href="https://github.com/xxxgitone/learningProcess/blob/master/linux/%E4%BA%91%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2.md" target="_blank" rel="external">这里</a>记录了我部署过程中的一些关键步骤，可以参考</p>
<h3 id="Build-Setup"><a href="#Build-Setup" class="headerlink" title="Build Setup"></a>Build Setup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone项目</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:xxxgitone/vue-node-pastime.git</span><br><span class="line"><span class="built_in">cd</span> vue-node-pastime</span><br><span class="line"><span class="comment"># install dependencies</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 还原数据，为了方便展示，我将数据库上传到了项目中，文件名为vnpastime</span></span><br><span class="line"><span class="comment"># --host 数据库服务</span></span><br><span class="line"><span class="comment"># -d 数据库名</span></span><br><span class="line"><span class="comment"># 最后面是备份文件的路径,如果不在该目录下记得填写绝对路径</span></span><br><span class="line">mongorestore --host 127.0.0.1:27017 -d vnpastime ./vnpastime/</span><br><span class="line"><span class="comment"># 启动mongodb服务</span></span><br><span class="line">mongo</span><br><span class="line"><span class="comment"># 启动后台服务</span></span><br><span class="line">node app.js</span><br><span class="line"><span class="comment"># 再启动前台</span></span><br><span class="line">npm run dev</span><br><span class="line"><span class="comment"># build for production with minification</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<p>来源：<a href="https://cnodejs.org/topic/59915bd8ee602e88524b421b" target="_blank" rel="external">https://cnodejs.org/topic/59915bd8ee602e88524b421b</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/11/02/uml-class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/02/uml-class/" itemprop="url">
                  UML类图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-02 23:47:44" itemprop="dateCreated datePublished" datetime="2017-11-02T23:47:44+08:00">2017-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 20:01:11" itemprop="dateModified" datetime="2017-11-11T20:01:11+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h3><p>实体之间一个“使用”关系暗示一个实体的规范发生变化后，可能影响依赖于它的其他实例（图D）。更具体地说，它可转换为对不在实例作用域内的一个类或对象的任何类型的引用。其中包括一个局部变量，对通过方法调用而获得的一个对象的引用（如下例所示），或者对一个类的静态方法的引用（同时不存在那个类的一个实例）。也可利用“依赖”来表示包和包之间的关系。由于包中含有类，所以你可根据那些包中的各个类之间的关系，表示出包和包的关系。</p>
<p><img src="/2017/11/02/uml-class/1.jpg" alt=""><br>图D</p>
<h3 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h3><p>实体之间的一个结构化关系表明对象是相互连接的。UML箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联（图E）转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。</p>
<p><img src="/2017/11/02/uml-class/2.jpg" alt=""><br>图E</p>
<h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>聚合（图F）是关联的一种形式，UML箭头代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。</p>
<p>关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。</p>
<p><img src="/2017/11/02/uml-class/3.jpg" alt=""><br>图F</p>
<h3 id="合成（Composition）"><a href="#合成（Composition）" class="headerlink" title="合成（Composition）"></a>合成（Composition）</h3><p>合成（图G）是聚合的一种特殊形式，UML箭头暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。<br>Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。</p>
<p><img src="/2017/11/02/uml-class/4.jpg" alt=""><br>图G</p>
<h3 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h3><p>泛化（图H）表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。</p>
<p><img src="/2017/11/02/uml-class/5.jpg" alt=""><br>图H</p>
<h3 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h3><p>实例（图I）关系UML箭头指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。</p>
<p><img src="/2017/11/02/uml-class/6.jpg" alt=""><br>图I</p>
<p>来源：<a href="http://blog.csdn.net/hewei0241/article/details/7674450" target="_blank" rel="external">http://blog.csdn.net/hewei0241/article/details/7674450</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/11/02/embedded-tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/02/embedded-tomcat/" itemprop="url">
                  基于内嵌Tomcat的应用开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-02 23:47:44" itemprop="dateCreated datePublished" datetime="2017-11-02T23:47:44+08:00">2017-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 20:08:11" itemprop="dateModified" datetime="2017-11-11T20:08:11+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Spring-Cloud/" itemprop="url" rel="index"><span itemprop="name">Spring Cloud</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为什么使用内嵌Tomcat开发"><a href="#为什么使用内嵌Tomcat开发" class="headerlink" title="为什么使用内嵌Tomcat开发?"></a>为什么使用内嵌Tomcat开发?</h3><p>开发人员无需搭建Tomcat的环境就可以使用内嵌式Tomcat进行开发，减少搭建J2EE容器环境的时间和开发时容器频繁启动所花时间，提高开发的效率.</p>
<h3 id="怎么搭建内嵌Tomcat环境呢？-以tomcat6和tomcat7为例"><a href="#怎么搭建内嵌Tomcat环境呢？-以tomcat6和tomcat7为例" class="headerlink" title="怎么搭建内嵌Tomcat环境呢？(以tomcat6和tomcat7为例)"></a>怎么搭建内嵌Tomcat环境呢？(以tomcat6和tomcat7为例)</h3><p>在开发工程（xxxx）的根目录下新建以下的目录：<br>xxxx/Embedded/conf<br>xxxx/Embedded/lib<br>xxxx/Embedded/webapps<br>xxxx/Embedded/work</p>
<h3 id="apache-tomcat-6-0-32"><a href="#apache-tomcat-6-0-32" class="headerlink" title="apache-tomcat-6.0.32"></a>apache-tomcat-6.0.32</h3><p><strong>apache官方只提供了apache-tomcat5和apache-tomcat7的内嵌版本，apache-tomcat6是没有的，但我们同样可以提供内嵌版本</strong>。</p>
<p>1.将apache-tomcat-6.0.32\lib下所有的jar包拷到xxxx/Embedded/lib下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">annotations-api.jar</span><br><span class="line">catalina.jar</span><br><span class="line">catalina-ant.jar</span><br><span class="line">catalina-ha.jar</span><br><span class="line">catalina-tribes.jar</span><br><span class="line">ecj-3.3.1.jar</span><br><span class="line">el-api.jar</span><br><span class="line">jasper.jar</span><br><span class="line">jasper-el.jar</span><br><span class="line">jsp-api.jar</span><br><span class="line">servlet-api.jar</span><br><span class="line">tomcat-coyote.jar</span><br><span class="line">tomcat-dbcp.jar</span><br><span class="line">tomcat-i18n-es.jar</span><br><span class="line">tomcat-i18n-fr.jar</span><br><span class="line">tomcat-i18n-ja.jar</span><br></pre></td></tr></table></figure></p>
<p>2.将apache-tomcat-6.0.32\bin下的tomcat-juli.jar包拷到xxxx/Embedded/lib下。</p>
<p>3.将JDK安装目录下的lib中的tools.jar包拷到xxxx/Embedded/lib下。</p>
<p>4.将apache-tomcat-6.0.32\conf下的context.xml和web.xml文件拷贝到xxxx/Embedded/conf下。</p>
<p>5.将xxxx/Embedded/lib下的所有Jar包都加到工程的classpath下。</p>
<p>6.在工程中新建EmbeddedTomcat类，该类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcat</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String CONTEXT_PATH = <span class="string">"/TestForTomcat6"</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PROJECT_PATH = System.getProperty(<span class="string">"user.dir"</span>);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String WEB_APP_PATH = PROJECT_PATH + File.separatorChar + <span class="string">"WebRoot"</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TOMCAT_HOME = PROJECT_PATH + File.separatorChar + <span class="string">"Embedded"</span> + File.separatorChar + <span class="string">"Tomcat"</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String ENCODING = <span class="string">"UTF-8"</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> TOMCAT_PORT = <span class="number">9080</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 开始嵌入式Tomcat服务器  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTomcat</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();  </span><br><span class="line">            Embedded tomcat = <span class="keyword">new</span> Embedded();  </span><br><span class="line">            <span class="comment">// 设置Tomcat的工作目录:工程根目录/Embedded/Tomcat  </span></span><br><span class="line">            tomcat.setCatalinaHome(TOMCAT_HOME);  </span><br><span class="line">            System.out.println(<span class="string">"TOMCAT_HOME:"</span> + TOMCAT_HOME);  </span><br><span class="line">              </span><br><span class="line">            <span class="comment">// 产生Tomcat引擎  </span></span><br><span class="line">            Engine engine = tomcat.createEngine();  </span><br><span class="line">            <span class="comment">//"localhost"对应的是work下的"Catalina"  </span></span><br><span class="line">            engine.setName(<span class="string">"Catalina"</span>);  </span><br><span class="line">              </span><br><span class="line">            <span class="comment">//创建Host，设置Host的工作目录  </span></span><br><span class="line">            Host host = tomcat.createHost(<span class="string">"localhost"</span>, tomcat.getCatalinaHome());  </span><br><span class="line">            host.setAutoDeploy(<span class="keyword">true</span>);  </span><br><span class="line">              </span><br><span class="line">            <span class="comment">//把Host加入Engine  </span></span><br><span class="line">            engine.addChild(host);  </span><br><span class="line">            engine.setDefaultHost(host.getName());  </span><br><span class="line">              </span><br><span class="line">            <span class="comment">//创建Context，并加入Host中  </span></span><br><span class="line">            Context context = <span class="keyword">null</span>;  </span><br><span class="line">            context = tomcat.createContext(CONTEXT_PATH, WEB_APP_PATH);  </span><br><span class="line">              </span><br><span class="line">            host.addChild(context);  </span><br><span class="line">            host.addChild(tomcat.createContext(<span class="string">""</span>, <span class="string">""</span>));  </span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">new</span> File(WEB_APP_PATH).exists()) &#123;  </span><br><span class="line">                System.err.println(<span class="string">"请检查应用的目录以及相关资源是否存在."</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            tomcat.addEngine(engine);  </span><br><span class="line">              </span><br><span class="line">            Connector connector = tomcat.createConnector((java.net.InetAddress) <span class="keyword">null</span>, TOMCAT_PORT, <span class="keyword">false</span>);  </span><br><span class="line">            connector.setURIEncoding(ENCODING);  </span><br><span class="line">            connector.setUseBodyEncodingForURI(<span class="keyword">true</span>);  </span><br><span class="line">            tomcat.addConnector(connector);  </span><br><span class="line">            AprLifecycleListener listener = <span class="keyword">new</span> AprLifecycleListener();  </span><br><span class="line">            tomcat.addLifecycleListener(listener);  </span><br><span class="line">            tomcat.start();  </span><br><span class="line">            <span class="comment">//停住一个小时(3600秒)  </span></span><br><span class="line">            Thread.sleep(<span class="number">3600000</span>);  </span><br><span class="line">            tomcat.stop();  </span><br><span class="line">            System.err.println(<span class="string">"Tomcat started in "</span> + (System.currentTimeMillis() - startTime) + <span class="string">" ms."</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            EmbeddedTomcat.startTomcat();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="apache-tomcat-7-0-22"><a href="#apache-tomcat-7-0-22" class="headerlink" title="apache-tomcat-7.0.22"></a>apache-tomcat-7.0.22</h3><p>1.请先到apache－tomcat官方网站下载apache-tomcat-7.0.23-embed内嵌版本，解压后将apache-tomcat-7.0.23-embed下的所有jar包拷贝到xxxx/Embedded/lib下，具体的jar如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ecj-3.7.jar</span><br><span class="line">tomcat-dbcp.jar</span><br><span class="line">tomcat-embed-core.jar</span><br><span class="line">tomcat-embed-jasper.jar</span><br><span class="line">tomcat-embed-logging-juli.jar</span><br><span class="line">tomcat-embed-logging-log4j.jar</span><br></pre></td></tr></table></figure></p>
<p>2.将apache-tomcat-7.0.23/conf下的context.xml和web.xml文件拷贝到xxxx/Embedded/conf下。</p>
<p>3.将xxxx/Embedded/lib下的所有Jar包都加到工程的classpath下。</p>
<p>4.在工程中新建EmbeddedTomcat类，该类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbededTomcat</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log=LogFactory.getLog(getClass());  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String CONTEXT_PATH = <span class="string">"/TestForTomcat7"</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PROJECT_PATH = System.getProperty(<span class="string">"user.dir"</span>);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String WEB_APP_PATH = PROJECT_PATH + File.separatorChar + <span class="string">"WebRoot"</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String CATALINA_HOME = PROJECT_PATH + <span class="string">"/Embedded/Tomcat"</span>;  </span><br><span class="line">    <span class="keyword">private</span> Tomcat tomcat = <span class="keyword">new</span> Tomcat();  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmbededTomcat</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.port=port;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line">        tomcat.setPort(port);  </span><br><span class="line">        tomcat.setBaseDir(CATALINA_HOME);  </span><br><span class="line">        tomcat.getHost().setAppBase(WEB_APP_PATH);  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            StandardServer server = (StandardServer)tomcat.getServer();  </span><br><span class="line">            AprLifecycleListener listener = <span class="keyword">new</span> AprLifecycleListener();  </span><br><span class="line">            server.addLifecycleListener(listener);  </span><br><span class="line">            tomcat.addWebapp(CONTEXT_PATH, WEB_APP_PATH);  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(ServletException e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            log.error(e.getMessage());  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            tomcat.start();  </span><br><span class="line">            tomcat.getServer().await();  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(LifecycleException e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            log.error(e.getMessage());  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125;  </span><br><span class="line">        log.info(<span class="string">"Tomcat started."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line">            <span class="keyword">try</span>&#123;  </span><br><span class="line">                tomcat.stop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span>(LifecycleException ex)&#123;  </span><br><span class="line">                ex.printStackTrace();  </span><br><span class="line">                log.error(ex.getMessage());  </span><br><span class="line">                <span class="keyword">throw</span> ex;  </span><br><span class="line">            &#125;  </span><br><span class="line">            log.info(<span class="string">"Tomcat stoped"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.port=port;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.port;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        EmbededTomcat embededTomcat = <span class="keyword">new</span> EmbededTomcat(<span class="number">7080</span>);  </span><br><span class="line">        embededTomcat.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遇到问题怎么办？"><a href="#遇到问题怎么办？" class="headerlink" title="遇到问题怎么办？"></a>遇到问题怎么办？</h3><p>1.内嵌Tomcat启动时报OutOfMemoryError异常，如何设置JVM的内存大小？</p>
<p>答：请按照以下步骤设置JVM的内存大小：</p>
<p>（1）点击“Window-&gt;Preferences-&gt;Java-&gt;Installed JREs”可以看到所有的JRE。</p>
<p>（2）点中当前使用的JRE，再点击右边的“Edit”。</p>
<p>（3）为该JRE的“Default VM Arguments”配置参数值：-Xmx1024M -Xms512M -XX:MaxPermSize=256m。</p>
<p>2．如何配置数据库的JNDI数据源？</p>
<p>答：打开XXXX\Embedded\Tomcat\conf\context.xml配置文件，添加节点的属性来新建数据源配置，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"xxxxDataSource"</span> <span class="attr">auth</span>=<span class="string">"Container"</span>  </span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span> <span class="attr">driverClassName</span>=<span class="string">"oracle.jdbc.OracleDriver"</span>  </span></span><br><span class="line"><span class="tag">              <span class="attr">url</span>=<span class="string">"jdbc:oracle:thin:@localhost:1521:xxxxx"</span>  </span></span><br><span class="line"><span class="tag">              <span class="attr">username</span>=<span class="string">"xxxx"</span> <span class="attr">password</span>=<span class="string">"xxxx"</span> <span class="attr">maxActive</span>=<span class="string">"15"</span> <span class="attr">maxIdle</span>=<span class="string">"10"</span> <span class="attr">initialSize</span>=<span class="string">"2"</span>  </span></span><br><span class="line"><span class="tag">              <span class="attr">testWhileIdle</span>=<span class="string">"true"</span> <span class="attr">validationQuery</span>=<span class="string">"select 1 from dual"</span> <span class="attr">testOnBorrow</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>来源：<a href="http://chenjc-it.iteye.com/blog/1370986" target="_blank" rel="external">http://chenjc-it.iteye.com/blog/1370986</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/11/02/android-custom-view/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/02/android-custom-view/" itemprop="url">
                  Android View 绘制流程 & 自定义View
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-02 23:47:44" itemprop="dateCreated datePublished" datetime="2017-11-02T23:47:44+08:00">2017-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 20:04:22" itemprop="dateModified" datetime="2017-11-11T20:04:22+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="View绘制流程调用链图"><a href="#View绘制流程调用链图" class="headerlink" title="View绘制流程调用链图"></a>View绘制流程调用链图</h3><p><img src="/2017/11/02/android-custom-view/1.jpg" alt=""></p>
<p>记清楚函数调用的顺序才能准确地进行调用。</p>
<p>根据调用链，可将整个绘制过程分为三部分：<strong>Measure - Layout - Draw</strong></p>
<h3 id="Measure-过程"><a href="#Measure-过程" class="headerlink" title="Measure 过程"></a>Measure 过程</h3><p>测量过程由上至下，在measure过程的最后，每个视图将存储自己的尺寸大小和测量规格。</p>
<p>measure过程会为一个View及其所有子节点的mMeasureWidth和mMeasuredHeight变量赋值， 该值可以通过getMeasuredWidth和getMeasuredHeight方法获得。</p>
<p>measure过程的核心方法: <strong>measure() - onMeasure() - setMeasuredDimension().</strong></p>
<p>setMeasuredDimension是测量阶段的终极方法，在onMeasure()方法中调用，将计算得到的尺寸，传递给该方法，测量阶段结束。在自定义 视图时，不需要关心系统复杂的Measure过程，只需要调用setMeasuredDimension()设置根据MeasureSpec计算得到的尺寸即可。同时, onMeasure()方法也必须调用setMeasuredDimension()方法来设置重新测量之后的</p>
<p>以measureChildren为例的调用链图:</p>
<p><img src="/2017/11/02/android-custom-view/2.jpg" alt=""></p>
<h3 id="Layout-过程"><a href="#Layout-过程" class="headerlink" title="Layout 过程"></a>Layout 过程</h3><p>子视图的具体位置都是相对于父视图而言的。View的onLayout()方法为空实现，而ViewGroup的onLayout为abstract，因此，自定义的View要继承ViewGroup时，必须实现onLayout函数。</p>
<p>在Layout过程中，子视图会调用getMeasuredWidth()和getMeasuredHeight()方法获取到measure过程得到mMeasuredWidth和mMeasuredHeight，作为自己的width和height。然后调用每一个子视图的layout()，来确定每个子视图在父视图中的位置。</p>
<h3 id="Draw-过程"><a href="#Draw-过程" class="headerlink" title="Draw 过程"></a>Draw 过程</h3><p>所有视图最终都是调用View的draw方法进行绘制。 在自定义视图中， 也不应该复写该方法， 而是复写onDraw（）方法进行绘制， 如果自定义的视图确实要复写该方法，先调用super.draw()完成系统的绘制，再进行自定义的绘制。</p>
<p>onDraw()方法默认是空实现，自定义绘制过程需要复写方法，绘制自身的内容。</p>
<p>dispatchDraw()发起对子视图的绘制，在View中默认为空实现，ViewGroup复写了dispatchDraw()来对其子视图进行绘制。自定义的ViewGroup不应该对dispatchDraw()进行复写。</p>
<h3 id="如何对自定义View进行控制"><a href="#如何对自定义View进行控制" class="headerlink" title="如何对自定义View进行控制"></a>如何对自定义View进行控制</h3><p>如果想控制View在屏幕上的渲染效果，就在重写onDraw()方法，在里面进行相应的处理。</p>
<p>如果想要控制用户同View之间的交互操作，则在onTouchEvent()方法中对手势进行控制处理。</p>
<p>如果想要控制View中内容在屏幕上显示的尺寸大小，就重写onMeasure()方法中进行处理。</p>
<p>在 XML文件中设置自定义View的XML属性。</p>
<p>如果想避免失去View的相关状态参数的话，就在onSaveInstanceState() 和 onRestoreInstanceState()方法中保存有关View的状态信息。</p>
<p>来源：<a href="http://www.jianshu.com/p/f0bc39dbfa26" target="_blank" rel="external">http://www.jianshu.com/p/f0bc39dbfa26</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/11/01/linux-keep-alive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/linux-keep-alive/" itemprop="url">
                  Linux的僵尸进程产生原因及解决方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-01 23:47:44" itemprop="dateCreated datePublished" datetime="2017-11-01T23:47:44+08:00">2017-11-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 19:52:01" itemprop="dateModified" datetime="2017-11-11T19:52:01+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-产生原因："><a href="#1-产生原因：" class="headerlink" title="1. 产生原因："></a>1. 产生原因：</h3><p>在UNIX 系统中，一个进程结束了，但是他的父进程没有等待（调用wait / waitpid）他，那么他将变成一个僵尸进程。通过ps命令查看其带有defunct的标志。僵尸进程是一个早已死亡的进程，但在进程表 （processs table）中仍占了一个位置（slot）。</p>
<p>但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程，看看有没有哪个 进程是刚刚结束的这个进程的子进程，如果是的话，就由Init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而Init进程会自动 wait其子进程，因此被Init接管的所有进程都不会变成僵尸进程。</p>
<h3 id="2-原理分析："><a href="#2-原理分析：" class="headerlink" title="2. 原理分析："></a>2. 原理分析：</h3><p>每个Unix进程在进程表里都有一个进入点（entry），核心进程执 行该进程时使用到的一切信息都存储在进入点。当用 ps 命令察看系统中的进程信息时，看到的就是进程表中的相关数据。当以fork（）系统调用建立一个新的进程后，核心进程就会在进程表中给这个新进程分配一个 进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。</p>
<p>子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。那么会不会因为父进程太忙来不及 wait 子进程，或者说不知道子进程什么时候结束，而丢失子进程结束时的状态信息呢？不会。因为UNIX提供了一种机制可以保证，只要父进程想知道子进程结束时的 状态信息，就可以得到。这种机制就是：当子进程走完了自己的生命周期后，它会执行exit（）系统调用，内核释放该进程所有的资源，包括打开的文件，占用 的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出码exit code，退出状态the terminationstatus of the process，运行时间the amount of CPU time taken by the process等），这些数据会一直保留到系统将它传递给它的父进程为止，直到父进程通过wait / waitpid来取时才释放。</p>
<h3 id="3-解决方法："><a href="#3-解决方法：" class="headerlink" title="3.解决方法："></a>3.解决方法：</h3><p>（1） 父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。执行wait（）或waitpid（）系统调用，则子进程在终止后会立即把它在进程表中的数据返回给父进程，此时系统会立即删除该进入点。在这种情形下就不会产生defunct进程。</p>
<p>（2） 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler。在子进程结束后，父进程会收到该信号，可以在handler中调用wait回收。</p>
<p>（3） 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCLD, SIG_IGN）或signal（SIGCHLD, SIG_IGN）通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号</p>
<p>（4）fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。</p>
<p>来源：<a href="http://www.blogdaren.com/post-882.html" target="_blank" rel="external">http://www.blogdaren.com/post-882.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/11/01/android-activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/android-activity/" itemprop="url">
                  免注册的Activity
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-01 23:47:44" itemprop="dateCreated datePublished" datetime="2017-11-01T23:47:44+08:00">2017-11-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 19:57:26" itemprop="dateModified" datetime="2017-11-11T19:57:26+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先思考一个问题，为什么我们的Activity需要在AndroidManifest.xml文件中注册？如果不注册能不能启动呢？</p>
<p>我们知道是AMS负责调起Activity。在启动之前他做了些什么事情呢？前面我们说过实际上AMS是给Zygote发送了消息，由Zygote进程fork一个虚拟机进程来。</p>
<p>那么其实在开机时Zygote进程在运行时第一个fork的进程是system_server的进程，这个服务用于管理系统级别的服务启动。</p>
<h3 id="System-server进程包含了以下顶级的系统服务"><a href="#System-server进程包含了以下顶级的系统服务" class="headerlink" title="System_server进程包含了以下顶级的系统服务"></a>System_server进程包含了以下顶级的系统服务</h3><ul>
<li><p>ActivityManagerService</p>
</li>
<li><p>PowerManagerService</p>
</li>
<li><p>MountService</p>
</li>
<li><p>NetworkManagementService</p>
</li>
<li><p>InputManagerService</p>
</li>
<li><p>WindowManagerService</p>
</li>
</ul>
<p>既然AMS承载了调用逻辑。我们是否可以对AMS动刀子来做到不注册Activity也能直接启动呢？</p>
<p>这里为什么我们前面要讲system_server服务，原因是我们要知道AMS进程不在我们自己的应用内，而是独立的远程服务进程。java层的上的反射是无法做到跨进程的。所以我们可以在自己的应用内利用AIDL的特性拿代理对象，去欺骗AMS服务。</p>
<h3 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a>流程如下：</h3><p>1.我们使用 startActivity(intent);来启动一个Activity。</p>
<p>2.hook住ActivityManager内的本地binder对象，拦截startActivity方法。</p>
<p>3.用动态代理方式将未被注册Activity的Intent替换成已注册的Activity的Intent，并将未被注册的Intent带过去。（替换壳Activity，躲避AMS服务的检查，也就是欺骗AMS）</p>
<p>4.对ActivityThread中的handle进行hook。因为前面替换的是壳子，替换真正要启动的Intent。</p>
<p>5.发送handleMessage消息，启动未被注册的Activity。<br>实现欺骗：</p>
<p>这里我们通过反射获取到AMS的代理本地代理对象Hook以后动态串改Intent为已注册的来躲避检测</p>
<p><img src="/2017/11/01/android-activity/1.png" alt=""></p>
<p>通过动态代理实现对startActivity中的Intent串改，具体逻辑见代码和注释。</p>
<p><img src="/2017/11/01/android-activity/2.png" alt=""></p>
<p>hook ActivityThread 中的 handle 在这里我们需要替换我们未被注册的Activity Intent</p>
<p><img src="/2017/11/01/android-activity/3.png" alt=""></p>
<p>拦截启动消息</p>
<p><img src="/2017/11/01/android-activity/4.png" alt=""></p>
<p>替换我们真实要被启动的Intent</p>
<p><img src="/2017/11/01/android-activity/5.png" alt=""></p>
<p>封装以后我们ASMHook将变得非常简单，简单到一行代码就可以实现不注册的情况下启动Activity。</p>
<p>其中HostActivity是我们的壳，OtherActivity是未被注册的。我们可以像平时正常调用API的条件下直接使用startActivity了。</p>
<p><img src="/2017/11/01/android-activity/6.png" alt=""></p>
<p>结果 启动了。</p>
<p><img src="/2017/11/01/android-activity/7.gif" alt=""></p>
<p>哎妈呀，好腻害的样子，喘口气看看刚刚发生了什么事情。</p>
<p><img src="/2017/11/01/android-activity/8.png" alt=""></p>
<p>献上封装好的HookAMS菊花(<a href="https://github.com/BolexLiu/AndroidHookStartActivity" target="_blank" rel="external">GitHubDemo</a>)</p>
<p>来源：<a href="http://www.jianshu.com/p/2ad105f54d07" target="_blank" rel="external">http://www.jianshu.com/p/2ad105f54d07</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/30/cglib-for-android/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/cglib-for-android/" itemprop="url">
                  将cglib动态代理思想带入Android开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-30 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-30T23:47:44+08:00">2017-10-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 16:57:56" itemprop="dateModified" datetime="2017-11-11T16:57:56+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://xsky.tech/2017/10/29/jdk-cglib-proxy/" target="_blank" rel="external">JDK和cglib的动态代理介绍</a></p>
<p><a href="https://github.com/zhangke3016/MethodInterceptProxy" target="_blank" rel="external">MethodInterceptProxy项目</a></p>
<p>在dexmaker和cglib-for-android库的基础上，修改部分代码后形成我们的类似cglib框架 MethodInterceptProxy ，实现上面需求只需这样写，和cglib写法一致:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String name = <span class="string">"张五"</span>;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(PeopleService.class);</span><br><span class="line"><span class="comment">//目标对象拦截器，实现MethodInterceptor </span></span><br><span class="line"><span class="comment">//Object object为目标对象 </span></span><br><span class="line"><span class="comment">//Method method为目标方法 </span></span><br><span class="line"><span class="comment">//Object[] args 为参数， </span></span><br><span class="line"><span class="comment">//MethodProxy proxy CGlib方法代理对象 </span></span><br><span class="line">MethodInterceptor interceptor = <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">"张三"</span>))&#123;</span><br><span class="line">             obj = methodProxy.invokeSuper(object, args); ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"----对不起，您没有权限----"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//NoOp.INSTANCE：这个NoOp表示no operator，即什么操作也不做，代理类直接调用被代理的方法不进行拦截</span></span><br><span class="line">enhancer.setCallbacks(<span class="keyword">new</span> MethodInterceptor[]&#123;interceptor,NoOp.INSTANCE&#125;);</span><br><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> CallbackFilter() &#123;</span><br><span class="line">    <span class="comment">//过滤方法 </span></span><br><span class="line">    <span class="comment">//返回的值为数字，代表了Callback数组中的索引位置，要到用的Callback </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">"select"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">PeopleService ps = (PeopleService) enhancer.create();</span><br><span class="line">ps.add();</span><br></pre></td></tr></table></figure>
<p>来源：<a href="http://blog.csdn.net/zhangke3016/article/details/71437287" target="_blank" rel="external">http://blog.csdn.net/zhangke3016/article/details/71437287</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/30/android-handler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/android-handler/" itemprop="url">
                  Android中的消息机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-30 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-30T23:47:44+08:00">2017-10-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 16:55:30" itemprop="dateModified" datetime="2017-11-11T16:55:30+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-Looper、Handler、MessageQueue与Message的关系与相关概念"><a href="#一-Looper、Handler、MessageQueue与Message的关系与相关概念" class="headerlink" title="一.Looper、Handler、MessageQueue与Message的关系与相关概念"></a>一.Looper、Handler、MessageQueue与Message的关系与相关概念</h3><h3 id="1-什么是Android消息处理机制？"><a href="#1-什么是Android消息处理机制？" class="headerlink" title="1.什么是Android消息处理机制？"></a>1.什么是Android消息处理机制？</h3><p>  “消息”是windows运行机制中一个基本而又重要的概念。消息是一个报告事件发生的通知，消息驱动是围绕消息的产生与处理展开的，并依靠消息循环机制来实现（百度百科）。与Windows系统一样，Android也是消息驱动型的系统。引用一下消息驱动机制的四要素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  ①接收消息的“消息队列”</span><br><span class="line"></span><br><span class="line">  ②阻塞式地从消息队列中接收消息并进行处理的“线程”</span><br><span class="line"></span><br><span class="line">  ③可发送的“消息的格式”</span><br><span class="line"></span><br><span class="line">  ④“消息发送函数”</span><br></pre></td></tr></table></figure></p>
<p>与之对应，Android系统中对应实现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  ①接收消息的“消息队列” ——　MessageQueue</span><br><span class="line"></span><br><span class="line">  ②阻塞式地从消息队列中接收消息并进行处理的“线程” ——　Thread+Looper</span><br><span class="line"></span><br><span class="line">  ③可发送的“消息的格式” ——　Message</span><br><span class="line"></span><br><span class="line">  ④“消息发送函数”——　Handler的post()和sendMessage()</span><br></pre></td></tr></table></figure></p>
<p>  Android有大量的消息驱动方式来进行交互，比如Android的四大组件——Activity, Service, Broadcast, ContentProvider的启动过程的交互，都离不开消息机制。</p>
<h3 id="2-Handler"><a href="#2-Handler" class="headerlink" title="2.Handler"></a>2.Handler</h3><p>  Android的消息机制，很多时候我们也称之为“Handler机制”，可见Handler这个东西是相当重要了～～那么Handler是用来干什么的呢？刚刚笔者在刷知乎的时候看到有大神怼(教导)一个Android菜鸟的时候其中就提到了一点“…以为Handler就是用来更新UI的…”——好吧，真是垂死病中惊坐起——开始学Android那会笔者也曾经这么认为(捂脸)。</p>
<p>  如果你也这么认为，那么从今天起你就要放弃这种狭隘的想法——Handler是Android消息机制的上层接口，因此我们在开发中与Handler打交道的机会最多。Handler并不是专门用来更新UI的，只是开发者常常用它来更新UI。</p>
<p><strong>Handler的主要用于同一个进程间的线程通信，Handler用于更新UI的时候是”子线程与主线程通信”；当然，Handler也可以用于子线程之间通信</strong>。</p>
<p>  Handler的消息机制主要是就指“Handler的运行机制”，Handler的运行机制时需要底层的MessageQueue和Looper支持的。</p>
<h3 id="3-MessageQueue"><a href="#3-MessageQueue" class="headerlink" title="3.MessageQueue"></a>3.MessageQueue</h3><p>  MessageQueue翻译过来是”消息队列”的意思，实际上它内部的数据结构不是队列，而是单向链表；MessageQueue中储存了大量的消息，由于一个线程同一时间只能处理一条消息，所以我们建了一个链表，将我们需要处理的消息按顺序储存起来，然后一项一项的交给需要的线程处理，这就是MessageQueue存在的价值。</p>
<p>  这里笔者想到一个问题——为什么MessageQueue要用链表而不用数组来作为数据结构呢？再经过网上查找博客＋源码阅读，笔者认为是这样的——之前我们在一片文章中有讲过，单链表更适合做增删的操作，数组更适合做随机访问的操作。再MessageQueue中，我们不止要做随机访问(这里不是真的随机访问，消息的读取是根据计算出来的时间顺序来的，后文会讲)跟多的我们做的是插入和删除操作，MessageQueue.enqueueMessage()就是插入消息(消息的插入需要根据时间发送的时间顺序来确定，不存在头插还是尾插)，而插入消息；而MessageQueue.next()则是读取消息，且读取的同时也伴随这删除的过程。试想一下，一个消息队列要循环起来，必然要频繁的进行插入/读取操作，假如采用数组的话，这两个操作的平均时间复杂度都是O(N/2)，而链表为O(1)，显然链表更合适。</p>
<h3 id="4-Looper"><a href="#4-Looper" class="headerlink" title="4.Looper"></a>4.Looper</h3><p>  Looper和MessageQueue的消息就像水泵和井(里边装的是水)的关系一样，我们有了消息(水)，但是为了把水从井中抽取出来(循环起来)，我们得有一个水泵作为动力，这个动力就是Looper。</p>
<p>  如果我们在一个线程中调用Looper.prepare()…Looper.loop()，那么你的线程就成功升级为了一个Looper线程，这意味着你的线程有了一个消息泵(Looper)和一个消息队列(MessageQueue),此时你就可以调用Handler来进行线程间的通信了。</p>
<p>  我们应用的UI线程也就是主线程，在应用启动的时候，系统会自动初始化一个Looper，也就是说，我们的UI线程默认是Looper线程。这也就是为什么主线程中直接调用Handler没什么事，但是再子线程中创建Handler需要哦手动调用Looper.prepare()…Looper.loop()的和原因。</p>
<h3 id="5-Message"><a href="#5-Message" class="headerlink" title="5.Message"></a>5.Message</h3><p>  Message也就是消息，井中的水。一个Message包括了消息类型(what),消息内容(arg1,arg2),发送它的Handler(target),Runnable回调接口等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;        <span class="comment">//数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1;         <span class="comment">//简单的整数值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;        <span class="comment">//简单的整数值可以直接发送，是一种替代setData（Bundle）的低成本方案，更加省资源</span></span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;            <span class="comment">//Handler发送一个消息之后，返回此消息的目标交付时间（以毫秒为单位）。</span></span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;        <span class="comment">//Bundle可以携带更复杂的数据类型</span></span><br><span class="line"><span class="comment">/*package*/</span> Handler target;        <span class="comment">//哪个Handler发送的消息</span></span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;</span><br><span class="line"><span class="comment">//可以看到，Message带了一个指向一下个节点的链，也就是说，MessageQueue内部维护的实际上是一个链表</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;        <span class="comment">//消息池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;    <span class="comment">//消息池的最大容量</span></span><br></pre></td></tr></table></figure>
<p>讲到这里，我们先上一张图加深一下大家对于这几个东西的直观认识：</p>
<p><img src="/2017/10/30/android-handler/1.png" alt=""></p>
<h3 id="二-子线程与主线程Handler通信原理-子线程是如何通过Handler更新UI的"><a href="#二-子线程与主线程Handler通信原理-子线程是如何通过Handler更新UI的" class="headerlink" title="二.子线程与主线程Handler通信原理(子线程是如何通过Handler更新UI的)"></a>二.子线程与主线程Handler通信原理(子线程是如何通过Handler更新UI的)</h3><h3 id="1-一些熟悉的场景"><a href="#1-一些熟悉的场景" class="headerlink" title="1.一些熟悉的场景"></a>1.一些熟悉的场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">     <span class="keyword">switch</span> (msg.what) &#123;      <span class="comment">//判断标志位</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="comment">//更新UI操作</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">//耗时操作</span></span><br><span class="line">      ｝</span><br><span class="line">    Message msg =Message.obtain();<span class="comment">//从全局池中返回一个message实例，避免多次创建（如new Message）</span></span><br><span class="line">    msg.obj = data;</span><br><span class="line">    msg.what=<span class="number">1</span>;   <span class="comment">//标志消息的标志</span></span><br><span class="line">    handler.sendMessage(msg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyThread().start();</span><br></pre></td></tr></table></figure>
<p>  上面代码是我们再Android开发中经常写的一段代码，其主要作用是再子线程中进行耗时操作，并通过Handler向主线程中发送消息，通知主线程做出相应的UI变化。注意这段代码中，Handler是再主线程中创建的，因此不需要手动调用Looper.prepare()添加Looper。</p>
<p>  如果我们试图再子线程中创建一个Handler，如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Handler handler ;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">//耗时操作</span></span><br><span class="line">      ｝</span><br><span class="line">    handler = <span class="keyword">new</span> Handler();</span><br><span class="line">    Message msg =Message.obtain();<span class="comment">//从全局池中返回一个message实例，避免多次创建（如new Message）</span></span><br><span class="line">    msg.obj = data;</span><br><span class="line">    msg.what=<span class="number">1</span>;   <span class="comment">//标志消息的标志</span></span><br><span class="line">    handler.sendMessage(msg);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">new</span> MyThread().start();</span><br></pre></td></tr></table></figure>
<p>那么很显然，这个时候就会出bug了～～为了解决这个bug，我们需要手动再子线程中创建Looper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handler = <span class="keyword">new</span> Handler();</span><br><span class="line">Looper.prepare();</span><br><span class="line">Message msg =Message.obtain();<span class="comment">//从全局池中返回一个message实例，避免多次创建（如new Message）</span></span><br><span class="line">msg.obj = data;</span><br><span class="line">msg.what=<span class="number">1</span>;   <span class="comment">//标志消息的标志</span></span><br><span class="line">handler.sendMessage(msg);</span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure>
<p>为什么是这样呢？接下来从源码的解读分析</p>
<h3 id="2-Looper"><a href="#2-Looper" class="headerlink" title="2.Looper"></a>2.Looper</h3><p>(frameworks/base/core/java/android/os/Looper)</p>
<p>(1)Looper.perpare()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Looper"</span>;</span><br><span class="line">    <span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Thread mThread;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看到Looper.prepare()方法中调用了prepare(ture)方法，其中true表示，该Looper是可以被终止的。因为我们是在子线程中创建的Looper，当子线程的消息处理完之后，理应把改Looper终止掉(MessageQueue.quit)。但是在主线程的Looper中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepareMainLooper就是给主线程添加Looper,可以看到，主线程中的prepare(false)中的参数false表示的是，主线程中的Looper不能被终止掉，毕竟它是整个应用的生命，需要时刻准备着处理或者正在处理应用中的各种消息。</p>
<p>  好了我们接着看上面的prepare()中干了什么。这里出现了一个新的重量级的东西：sThreadLocal，它是ThreadLocal类的实例，关于ThreadLocal类是干什么的，我们在这里不做过多解释，我们只需要知道他是用于储存不同线程唯一对象的一个东西,即多个线程在ThreadLocal类中，通过ThreadLocal.set()保存了自己的变量之后，那么我们再各个子线程中调用ThreadLocal.get()方法，得到的仍然是当前线程之前存进去的那个值。各个线程存取各自的值，不会产生冲突。</p>
<p>  知道了ThreadLocal的作用之后，我们在来看sThreadLocal.set(new Looper(quitAllowed));这句表示我们再ThreadLocal类中保存了一个Looper对象(new Looper())，根据上面对ThreadLocal类的介绍，如果我们再当前线程中调用ThreadLocal.get()方法，则会得到本线程之前保存的唯一的变量。因此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个if表示的是，如果sThreadLocal.get() != null，说明当前线程中已经存在一个Looper，我们不能在一个线程中同时创建多个，所以此时会抛出异常。为了避免这种异常，我们可以在Looper.prepare()之前调用Looper.myLooper()类来返回当前线程中的Looper对象，判断为空之后，再调用prepare()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Ok，比比了这么多，我们接着看new Looper()中Looper中的构造函数中做了什么:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出现了消息队列MessageQueue(quitAllowed)，其中参数就是表示是否允许Looper退出的标示符。可以看到，在Looper中我们创建了一个MessageQueue实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>，此时我们的Looper就拥有了MessageQueue的对象引用。</p>
<p>(2)Looper.Loop()</p>
<p>  在Looper.perpare()调用完即我们为线程准备好Looper之后，最后一步我们还需要调用Loop()让整个Looper循环起来，这样消息才能发送出去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        ......</span><br><span class="line">        msg.recycleUnchecked();        <span class="comment">//释放占据的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用了我们刚说过的myLooper()来获取当前线程再ThreadLcoal类中储存的Looper,如果Looper为空则会抛出异常，提示当前线程没有Looper。然后inal MessageQueue queue = me.mQueue;是获取当前线程的Looper中的MessageQueue对象。</p>
<p>  之后这个Looper便进入了一个无限循环的状态——for(;;)，Message msg = queue.next();是一条一条遍历整个消息队列，拿出msg消息。</p>
<p>  而msg.target.dispatchMessage(msg);这句中的msg.target实际上就是当前消息的目标Handler，也就是哪个线程中的Handler发送的消息，当然，这个发送它的Handler也要在自己所在的线程中接受这条消息。</p>
<p>  msg.recycleUnchecked();这句是将这天消息放入Message类中的消息池中。</p>
<p>从上面我们基本上可以得出——Looper &gt; MessageQueue &gt; Message的关系，也就是说，每个Looper中维护了一个消息队列，而一个消息队列中则以链表的形式排列着一条条消息。</p>
<h3 id="3-MessageQueue-next"><a href="#3-MessageQueue-next" class="headerlink" title="3.MessageQueue.next()"></a>3.MessageQueue.next()</h3><p>(frameworks/base/core/java/android/os/MessageQueue)<br>上面的Looper类中我们实例化了一个MessageQueue对象，并调用了MessageQueue.next()类方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;        <span class="comment">//当消息循环已经退出，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration　循环迭代的首次为-1，也就是初始值为-１</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;        <span class="comment">//消息队列开始无限循环</span></span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻塞操作的方法，当等待nextPollTimeoutMillis时长，或者消息队列里边有了消息被唤醒时，</span></span><br><span class="line">        <span class="comment">//只有满足这两个条件该方法才会返回，for循环才能往下执行下面的代码，否则就一直在这等着</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;    <span class="comment">//这一段同步块代码中就是再检索下一条message,如果找到了就返回</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();    <span class="comment">//手机开机到现在的时间(毫秒为单位)，手机睡眠的时间不包括再内</span></span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;            <span class="comment">//如果此时消息不为null,但是这个消息找不到发送它的Handler，说明为不合法消息，放弃并寻找下一条异步消息</span></span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;    <span class="comment">//如果消息不为null(这次是个正常消息)</span></span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 虽然消息是正常的，但是还没到发送的时间。msg.when表示消息发送的时间，因为我们可能调用了postDelay()</span></span><br><span class="line">                    <span class="comment">//延迟发送。我们之前说过，当等待nextPollTimeoutMillis时长后nativePollOnce()方法就会返回。</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//else则表示，成功抓到了一条消息</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;        <span class="comment">//单链表操作，下面讲</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">              ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个mPtr我们之前在MessageQueue的构造方法中提到过:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它通过mPtr = nativeInit();得到值，nativeInit()是一个native层的方法，根据注释来看，它主要是判断Looper目前的状态。if (ptr == 0) {表示的是当前线程的Looper已经退出或者被处理掉了，这种情况发生在“应用在退出之后试图重启Looper”的情况下，这种情况是不被允许的，因此此时return null;</p>
<p>  上面这段中还要讲的就是单链表的操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prevMsg.next = msg.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mMessages = msg.next;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.next = <span class="keyword">null</span>;</span><br><span class="line">    msg.markInUse();    <span class="comment">//表示这个消息已经被传递(使用了)</span></span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，再synchronized (this)同步块一开始的时候，有一个全局变量mMessages，这实际上就是等待处理消息,这个变量很重要，之后我们会多次遇到。这里还有一个叫prevMsg的Message,用于保存找不到msg.target的消息(废消息)。OK，回到链表操作中来，if (prevMsg != null)，很遗憾，有一个不合法的消息，此时上面已经经历了prevMsg = msg;　msg = msg.next;这两步，加上prevMsg.next = msg.next;这一步，实际上就是prevMsg的后继引用跳过了msg，直接指向了msg的下一位(注意prevMsg是不合法的，但是它的下一位msg是合法的)。</p>
<p>  再看else，说明没有不合法的消息，Message msg = mMessages;加上mMessages = msg.next;，这两步实际上和上面一样，也是工作指针后移，越过了msg。也就是msg出队，msg的下一条消息成为mMessages(待处理消息)，否则就进入一个阻塞状态，一直等到有新的消息入队。</p>
<p>  OK，上面if和else中越过的msg，就是我们要返回的正常消息，接着两句:msg.next = null;和return msg;就可以知道，前者是将msg的后继引用清空(将它从链表中删除)，然后return。</p>
<p>  通过上面的分析我们知道，MessageQueue.next()作用就是遍历链表，找出一个合法的msg，将它从链表中删除后返回，这实际上也就是一个消息出队的过程</p>
<h3 id="4-Handler"><a href="#4-Handler" class="headerlink" title="4.Handler"></a>4.Handler</h3><p>(1)Handler.post/sendMessage将一个消息添加到消息队列中</p>
<p>  上面我们已经讲完了Handler通信的两个重要的基础类——MessageQueue和Looper，接下来我们分析一下Handler是如何将一个消息发送出去的。</p>
<p>  我们从Handler的构造函数开始看起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Hnadler在发送消息的时候先获取当前线程的Looper，然后做一次looper的非空判断；接着获取了Looper中的MessageQueue对象。这样，我们的Handler已经和Looer以及MessageQueue取得了联系。</p>
<p>  接着回到文章最开始的时候举的那个例子中，handler.sendMessage()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面几个方法的逻辑都比较清晰，可以看到，最终调用了MessageQueue的enqueueMessage()方法，其中第一个参数为msg,第二个参数uptimeMillis = SystemClock.uptimeMillis() + delayMillis，也就是开机到现在的时间(不包括睡眠时间)+我们设定的delay时间，接下来我们看看enqueueMessage()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;    <span class="comment">//目标Handler为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;    <span class="comment">//msg已经用过了    </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;        <span class="comment">//如果这个Looper正在退出，回收msg，加入到消息池</span></span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            msg.recycle();        <span class="comment">//释放msg资源</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();        <span class="comment">//表示这个msg已经被使用了</span></span><br><span class="line">        <span class="comment">//这里我们可以知道，Message类的when属性实际上就是SystemClock.uptimeMillis() + delayMillis</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">        <span class="comment">//如果p == null，说明MessageQueue中没有消息；或者msg的时间是这个消息队列中最靠前的</span></span><br><span class="line">            msg.next = p;        <span class="comment">//将这个msg提取出来，并复制给mMessages，mMessages会在上面的</span></span><br><span class="line">            mMessages = msg;    <span class="comment">//MessageQueue.next()方法中进行一系列判断后返回</span></span><br><span class="line">            needWake = mBlocked;    <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;        <span class="comment">//elss,说明此时我们发送过来的消息需要按照一定规则插入到队列中</span></span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">  ①        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;        <span class="comment">//工作指针后移并且循环遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;    <span class="comment">//找到一个不为空并且发送时间大于当前发送时间的消息,</span></span><br><span class="line">                    <span class="keyword">break</span>;        <span class="comment">//跳出循环，准备把msg（要发送的消息）查到这条消息之前</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   ②       msg.next = p; <span class="comment">// 单链表插入</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<p>  上面代码中①处的for()循环就是在循环遍历MessageQueue以找到合适的msg插位置，②处的代码实际上就是一个单链表插入的过程，我们可以把整个插入的代码连起来，这样更容易看出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prev = p;</span><br><span class="line">p = p.next;</span><br><span class="line">msg.next = p;</span><br><span class="line">prev.next = msg;</span><br></pre></td></tr></table></figure>
<p>没骗你吧~~这就是把我们的要发送的消息msg插入到了链表中的p节点之前。</p>
<p>  我们需要明确的一点是，这里的Handler.post/sendMessage方法是和上面的MessageQueue.next()方法是对应的，他是消息的入队操作。</p>
<p>(2)Looper.loop()中调用Handler.dispatchMessage()接受并处理消息</p>
<p>  好了，讲到这里，我们可以看到，Handler.post或者Handler.sendMessage方法，最终是将他们要发送的消息添加到了消息队列中(Handler.post实际上也是调用了Handler.sendMessageDaley())。</p>
<p>  那么接受消息在哪呢？好吧看标题你也知道，Looper.loop()方法中我们实现了消息的重写与接收。我们回过头去看Looper类，在该类中MessageQueue.next()这个消息出队的方法调用完之后，出现了msg.target.dispatchMessage(msg);这句代码，我们说过这句代码中的msg.target就是消息的目标Handler,于是我们回到Handler中看下这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看到最终我们调用了一个空方法，为什么呢，因为消息的最终回调是由我们控制的，我们在创建handler的时候会在Handler所在的线程中(如果是子线程更新主线程UI的话，就在主线程中)重写handleMessage方法，然后根据msg.what进行消息处理(对照开始给出的Hanlder常见场景)。</p>
<p>我们梳理一下整个流程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">① handler = <span class="keyword">new</span> Handler();    <span class="comment">//创建Handler对象</span></span><br><span class="line">② Looper.prepare();        <span class="comment">//准备好Looper，初始化MessageQueue</span></span><br><span class="line">③ Message msg =Message.obtain();    <span class="comment">//从消息池中取出一个可用的Message实例</span></span><br><span class="line">④ msg.obj = data;            <span class="comment">//消息的数据</span></span><br><span class="line">   msg.what=<span class="number">1</span>;                <span class="comment">//标志消息的标志</span></span><br><span class="line">⑤ handler.sendMessage(msg);        <span class="comment">//发送消息，将一个消息添加到消息队列中去</span></span><br><span class="line">⑥ Looper.loop();        <span class="comment">//使用loop使消息队列循环起来，并进行消息的出队删除操作</span></span><br></pre></td></tr></table></figure>
<p>Looper.loop()中的消息出队之后，将调用Handler的dispatchMessage，最终大我们在代码中重写的handleMessage用以自定处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">       <span class="keyword">switch</span> (msg.what) &#123;      <span class="comment">//判断标志位</span></span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               <span class="comment">//更新UI操作</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>(3)Handler.post() &amp; View.post() &amp; Activity.runOnUiThread()</p>
<p>①Handler.post()</p>
<p>  上面我们说了Handler.sendMessage()方法，并且在文章开头的实例中展示了Handler.sendMessage()的使用方法，下面我们来说一下Handler.post()，该方法的具体使用还是略微的有一点不同的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Hander.post()方法还是调用了sendMessageDelayed方法，这跟之前的流程是一样的。这里我们要说的是sendMessageDelayed(getPostMessage(r), 0);中的getPostMessage(r)方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中将消息的callback字段的值指定为传入的Runnable对象。这个callback字段之前我们有遇到过——在Handler的dispatchMessage()方法中原来有做一个检查，如果Message的callback等于null才会去调用handleMessage()方法，否则就调用handleCallback()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handleCallback(msg)：</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的run也就是一开始的时候传入的run接口。也就是说，如果通过post(Runnable r)传递消息的话，我们直接就可以在post()方法中进行UI操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handler = <span class="keyword">new</span> Handler();  </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            handler.post(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    <span class="comment">// 在这里进行UI操作  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;).start();</span><br></pre></td></tr></table></figure>
<p>写法上简洁了很多，但是本质上都是一样的。</p>
<p>②View.post()<br>(source/android-24/android/view/View):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到同样调用了Handler的post方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Activity.runOnUiThread()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">            mHandler.post(action);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            action.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，否则就直接调用Runnable对象的run()方法。</p>
<h3 id="5-Message-obtain"><a href="#5-Message-obtain" class="headerlink" title="5.Message.obtain"></a>5.Message.obtain</h3><p>上面我们需要解释的一个东西便是Message msg =Message.obtain();这句，Message的obtain()方法中维护了一个消息池，其最大容量MAX_POOL_SIZE = 50</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment"> * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;    <span class="comment">//消息池不为空时从消息池中直接拿消息</span></span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;    <span class="comment">//工作指针后移，准备取出sPool</span></span><br><span class="line">            m.next = <span class="keyword">null</span>;    <span class="comment">//从sPool中取出一个Message对象，并消息链表断开</span></span><br><span class="line">            m.flags = <span class="number">0</span>;     <span class="comment">// 清除in-use flag</span></span><br><span class="line">            sPoolSize--;    <span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();    <span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Constructor (but the preferred way to get a Message is to call &#123;<span class="doctag">@link</span> #obtain() Message.obtain()&#125;).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们当然可以直接new Message()这样来创建消息，但是一般来讲我们还是应该调用Message.obtain()方法来返回一个消息实例，以避免Message对象的多次创建。</p>
<p>好了，到此为止，我们调用Handler发送消息更新UI的整个流程就说完了。</p>
<h3 id="三-Activity启动过程中UI线程的MainLooper的创建"><a href="#三-Activity启动过程中UI线程的MainLooper的创建" class="headerlink" title="三.Activity启动过程中UI线程的MainLooper的创建"></a>三.Activity启动过程中UI线程的MainLooper的创建</h3><p>  Actvity的启动流程我们之前在一片文章中有讲过，真正启动Activity的是ActiivtyThread类中的main()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    ......</span><br><span class="line">    Looper.loop();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在启动一个Activity之前,我们在ActivityThread.main()方法中，调用了Looper.prepareMainLooper()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法同上面的Looper.prepare()方法一样，只不过这里准备的是主线程中的Looper,因此prepare(false);其中的参数false表示的是，该线程的Looper不能退出。之后调用myLooper则是获取主线程中的Looper对象，这些和上面都没什么区别。</p>
<p>  我们回到ActivityThread.main()中，在准备完主线程的Looper之后，ActivityThread thread = new ActivityThread();创建一个ActivityThread实例。thread.attach(false);参数false表示这不是系统进程，是给普通应用程序使用的进程。</p>
<p>我们接着thread.attach(false);来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>
<p>注意到mgr.attachApplication(mAppThread);这句，其中mAppThread是ApplicationThread的对象，mgr为IActivityManager接口类，而真正实现IActivityManager接口的是在ActivityManagerService(AMS)类中,关于AMS类中的代码我们这里就先不详细解释了，我们只需要知道，在它当中经过一系列的处理~~最终：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r, System.identityHashCode(r),</span><br><span class="line">        r.info, r.icicle, results, newIntents, !andResume, isNextTransitionForward());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又回调到了ActivityThread类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法在ApplicationThread(Binder线程)中调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line">        updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line">        ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">        r.token = token;</span><br><span class="line">        r.ident = ident;</span><br><span class="line">        r.intent = intent;</span><br><span class="line">        r.referrer = referrer;</span><br><span class="line">        r.voiceInteractor = voiceInteractor;</span><br><span class="line">        r.activityInfo = info;</span><br><span class="line">        r.compatInfo = compatInfo;</span><br><span class="line">        r.state = state;</span><br><span class="line">        r.persistentState = persistentState;</span><br><span class="line">        r.pendingResults = pendingResults;</span><br><span class="line">        r.pendingIntents = pendingNewIntents;</span><br><span class="line">        r.startsNotResumed = notResumed;</span><br><span class="line">        r.isForward = isForward;</span><br><span class="line">        r.profilerInfo = profilerInfo;</span><br><span class="line">        r.overrideConfig = overrideConfig;</span><br><span class="line">        updatePendingConfiguration(curConfig);</span><br><span class="line">        sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里将一系列应用的信息封装在ActivityClientRecord中之后，最终调用了sendMessage(H.LAUNCH_ACTIVITY, r);发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的“H”实际上就是一个Handler类：private class H extends Handler {，而这里的mH则是H的子类。接着往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">           <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">               Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">               <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">               r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                       r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">               handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">               Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">               ......</span><br></pre></td></tr></table></figure>
<p>可以看到，这里handleMessage收到了我们发送的LAUNCH_ACTIVITY也就是启动Activity的请求，实际上这里还有PAUSE_ACTIVITY，RESUME_ACTIVITY等一系列请求的处理。</p>
<p>之后handleLaunchActivity(r, null, “LAUNCH_ACTIVITY”);–&gt;performLaunchActivity–&gt;mInstrumentation.callActivityOnCreate一系列流程之后，我们的Activity就启动了，这个我们在之前的文章中有讲过，这里不再獒述。</p>
<p>来源：<a href="http://www.jianshu.com/p/f1da1ed7bd7e" target="_blank" rel="external">http://www.jianshu.com/p/f1da1ed7bd7e</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2017/10/30/ssm-dubbo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/ssm-dubbo/" itemprop="url">
                  浅谈分布式架构演进
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-30 23:47:44" itemprop="dateCreated datePublished" datetime="2017-10-30T23:47:44+08:00">2017-10-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-11 19:34:14" itemprop="dateModified" datetime="2017-11-11T19:34:14+08:00">2017-11-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>现在越来越多的互联网公司还是将自己公司的项目进行服务化，这确实是今后项目开发的一个趋势，从历史的角度来分析一下就比较明了了。</p>
<p>我们拿一个电商系统来说：</p>
<h3 id="单系统"><a href="#单系统" class="headerlink" title="单系统"></a>单系统</h3><p><img src="/2017/10/30/ssm-dubbo/1.png" alt=""></p>
<p>对于一个刚起步的创业公司项目肯定是追求越快完成功能越好，并且用户量也不大。</p>
<p>这时候所有的业务逻辑都是在一个项目中就可以满足。</p>
<h3 id="垂直拆分-多应用"><a href="#垂直拆分-多应用" class="headerlink" title="垂直拆分-多应用"></a>垂直拆分-多应用</h3><p><img src="/2017/10/30/ssm-dubbo/2.png" alt=""></p>
<p>当业务量和用户量发展到一定地步的时候，这时一般会将应用同时部署到几台服务器上，在用户访问的时候使用Nginx进行反向代理和简单的负载均衡。</p>
<h3 id="SOA服务化"><a href="#SOA服务化" class="headerlink" title="SOA服务化"></a>SOA服务化</h3><p>当整个系统以及发展的足够大的时候，比如一个电商系统中存在有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用户系统</span><br><span class="line"></span><br><span class="line">订单系统</span><br><span class="line"></span><br><span class="line">支付系统</span><br><span class="line"></span><br><span class="line">物流系统</span><br><span class="line"></span><br><span class="line">等等系统</span><br></pre></td></tr></table></figure></p>
<p>如果每次修改了其中一个系统就要重新发布上线的话那么耦合就太严重了。</p>
<p>所以需要将整个项目拆分成若干个独立的应用，可以进行独立的开发上线实现快速迭代。</p>
<p><img src="/2017/10/30/ssm-dubbo/3.png" alt=""></p>
<p>来源：<a href="http://www.jianshu.com/p/db67973cae79" target="_blank" rel="external">http://www.jianshu.com/p/db67973cae79</a></p>
<hr>
<h3 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h3><p>手机应用是以聊天室为基础的，我们需要收集用户的操作行为，然后计算聊天室中在线人数，并实时在手机应用端显示人数，整个系统的架构如图所示：</p>
<p><img src="/2017/10/30/ssm-dubbo/4.png" alt=""></p>
<p>上图中，主要包括了两大主要流程：日志收集并实时处理流程、调用读取实时计算结果流程，我们使用基于Dubbo框架开发的服务来提供实时计算结果读取聊天人数的功能。上图中，实际上业务接口服务器集群也可以基于Dubbo框架构建服务，就看我们想要构建什么样的系统来满足我们的需要。</p>
<p>如果不使用注册中心，服务消费方也能够直接调用服务提供方发布的服务，这样需要服务提供方将服务地址暴露给服务消费方，而且也无法使用监控中心的功能，这种方式成为直连。</p>
<p>如果我们使用注册中心，服务提供方将服务发布到注册中心，而服务消费方可以通过注册中心订阅服务，接收服务提供方服务变更通知，这种方式可以隐藏服务提供方的细节，包括服务器地址等敏感信息，而服务消费方只能通过注册中心来获取到已注册的提供方服务，而不能直接跨过注册中心与服务提供方直接连接。这种方式的好处是还可以使用监控中心服务，能够对服务的调用情况进行监控分析，还能使用Dubbo服务管理中心，方便管理服务，我们在这里使用的是这种方式，也推荐使用这种方式。使用注册中心的Dubbo分布式服务相关组件结构，如下图所示：</p>
<p><img src="/2017/10/30/ssm-dubbo/5.png" alt=""></p>
<p>来源：<a href="http://shiyanjun.cn/archives/1075.html" target="_blank" rel="external">http://shiyanjun.cn/archives/1075.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">107</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
