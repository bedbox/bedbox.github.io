<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Codes Online">
<meta property="og:url" content="http://51codes.top/index.html">
<meta property="og:site_name" content="Codes Online">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Codes Online">






  <link rel="canonical" href="http://51codes.top/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Codes Online</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Codes Online</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _enjoying</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/06/01/ngrok-auth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/ngrok-auth/" itemprop="url">
                  解决Ngrok Server无法认证AuthTokens问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-01 22:44:46 / 修改时间：22:46:21" itemprop="dateCreated datePublished" datetime="2018-06-01T22:44:46+08:00">2018-06-01</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/环境搭建/" itemprop="url" rel="index"><span itemprop="name">环境搭建</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"ngrok/conn"</span></span><br><span class="line">	<span class="string">"ngrok/msg"</span></span><br><span class="line">	<span class="string">"ngrok/util"</span></span><br><span class="line">	<span class="string">"ngrok/version"</span></span><br><span class="line">	<span class="string">"runtime/debug"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	pingTimeoutInterval = <span class="number">30</span> * time.Second</span><br><span class="line">	connReapInterval = <span class="number">10</span> * time.Second</span><br><span class="line">	controlWriteTimeout = <span class="number">10</span> * time.Second</span><br><span class="line">	proxyStaleDuration = <span class="number">60</span> * time.Second</span><br><span class="line">	proxyMaxPoolSize = <span class="number">10</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Control <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// auth message</span></span><br><span class="line">	auth            *msg.Auth</span><br><span class="line"></span><br><span class="line">	<span class="comment">// actual connection</span></span><br><span class="line">	conn            conn.Conn</span><br><span class="line"></span><br><span class="line">	<span class="comment">// put a message in this channel to send it over</span></span><br><span class="line">	<span class="comment">// conn to the client</span></span><br><span class="line">	out             <span class="keyword">chan</span> (msg.Message)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read from this channel to get the next message sent</span></span><br><span class="line">	<span class="comment">// to us over conn by the client</span></span><br><span class="line">	in              <span class="keyword">chan</span> (msg.Message)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the last time we received a ping from the client - for heartbeats</span></span><br><span class="line">	lastPing        time.Time</span><br><span class="line"></span><br><span class="line">	<span class="comment">// all of the tunnels this control connection handles</span></span><br><span class="line">	tunnels         []*Tunnel</span><br><span class="line"></span><br><span class="line">	<span class="comment">// proxy connections</span></span><br><span class="line">	proxies         <span class="keyword">chan</span> conn.Conn</span><br><span class="line"></span><br><span class="line">	<span class="comment">// identifier</span></span><br><span class="line">	id              <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controlled shutdown of writer()</span></span><br><span class="line">	writerShutdown  *util.Shutdown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controlled shutdown of reader()</span></span><br><span class="line">	readerShutdown  *util.Shutdown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controlled shutdown of manager()</span></span><br><span class="line">	managerShutdown *util.Shutdown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controller shutdown of entire Control</span></span><br><span class="line">	shutdown        *util.Shutdown</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCurrentPath</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	file, err := exec.LookPath(os.Args[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	path, err := filepath.Abs(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	i := strings.LastIndex(path, <span class="string">"/"</span>)</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">		i = strings.LastIndex(path, <span class="string">"\\"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">`error: Can't find "/" or "\".`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(path[<span class="number">0</span> : i+<span class="number">1</span>]), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControl</span><span class="params">(ctlConn conn.Conn, authMsg *msg.Auth)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create the object</span></span><br><span class="line">	c := &amp;Control&#123;</span><br><span class="line">		auth:            authMsg,</span><br><span class="line">		conn:            ctlConn,</span><br><span class="line">		out:             <span class="built_in">make</span>(<span class="keyword">chan</span> msg.Message),</span><br><span class="line">		in:              <span class="built_in">make</span>(<span class="keyword">chan</span> msg.Message),</span><br><span class="line">		proxies:         <span class="built_in">make</span>(<span class="keyword">chan</span> conn.Conn, <span class="number">10</span>),</span><br><span class="line">		lastPing:        time.Now(),</span><br><span class="line">		writerShutdown:  util.NewShutdown(),</span><br><span class="line">		readerShutdown:  util.NewShutdown(),</span><br><span class="line">		managerShutdown: util.NewShutdown(),</span><br><span class="line">		shutdown:        util.NewShutdown(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	failAuth := <span class="function"><span class="keyword">func</span><span class="params">(e error)</span></span> &#123;</span><br><span class="line">		_ = msg.WriteMsg(ctlConn, &amp;msg.AuthResp&#123;Error: e.Error()&#125;)</span><br><span class="line">		ctlConn.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	readLine := <span class="function"><span class="keyword">func</span><span class="params">(token <span class="keyword">string</span>, filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">		tokenpath, err := GetCurrentPath()</span><br><span class="line">		<span class="keyword">if</span>  err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"----------&gt;current path faild"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> token == <span class="string">""</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"----------&gt;token="</span> + token)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		f, err := os.Open(tokenpath + filename)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"----------&gt;open token file fail="</span> + filename + <span class="string">", path="</span> + tokenpath)</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		buf := bufio.NewReader(f)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			line, err := buf.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">			line = strings.TrimSpace(line)</span><br><span class="line">			fmt.Println(<span class="string">"----------&gt;open token file line="</span> + line)</span><br><span class="line">			<span class="keyword">if</span> line == token &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">					fmt.Println(<span class="string">"----------&gt;read token file io.EOF"</span>)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				fmt.Println(<span class="string">"----------&gt;read token file err"</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"----------&gt;read token and none equals"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// register the clientid</span></span><br><span class="line">	c.id = authMsg.ClientId</span><br><span class="line">	<span class="keyword">if</span> c.id == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// it's a new session, assign an ID</span></span><br><span class="line">		<span class="keyword">if</span> c.id, err = util.SecureRandId(<span class="number">16</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			failAuth(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set logging prefix</span></span><br><span class="line">	ctlConn.SetType(<span class="string">"ctl"</span>)</span><br><span class="line">	ctlConn.AddLogPrefix(c.id)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> authMsg.Version != version.Proto &#123;</span><br><span class="line">		failAuth(fmt.Errorf(<span class="string">"Incompatible versions. Server %s, client %s. Download a new version at http://ngrok.com"</span>, version.MajorMinor(), authMsg.Version))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	authd, err := readLine(authMsg.User, <span class="string">"authtokens.txt"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> authd != <span class="literal">true</span> &#123;</span><br><span class="line">		failAuth(fmt.Errorf(<span class="string">"authtoken %s invalid"</span>, <span class="string">"is"</span>));</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// register the control</span></span><br><span class="line">	<span class="keyword">if</span> replaced := controlRegistry.Add(c.id, c); replaced != <span class="literal">nil</span> &#123;</span><br><span class="line">		replaced.shutdown.WaitComplete()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start the writer first so that the following messages get sent</span></span><br><span class="line">	<span class="keyword">go</span> c.writer()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Respond to authentication</span></span><br><span class="line">	c.out &lt;- &amp;msg.AuthResp&#123;</span><br><span class="line">		Version:   version.Proto,</span><br><span class="line">		MmVersion: version.MajorMinor(),</span><br><span class="line">		ClientId:  c.id,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// As a performance optimization, ask for a proxy connection up front</span></span><br><span class="line">	c.out &lt;- &amp;msg.ReqProxy&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// manage the connection</span></span><br><span class="line">	<span class="keyword">go</span> c.manager()</span><br><span class="line">	<span class="keyword">go</span> c.reader()</span><br><span class="line">	<span class="keyword">go</span> c.stopper()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a new tunnel on this control connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">registerTunnel</span><span class="params">(rawTunnelReq *msg.ReqTunnel)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, proto := <span class="keyword">range</span> strings.Split(rawTunnelReq.Protocol, <span class="string">"+"</span>) &#123;</span><br><span class="line">		tunnelReq := *rawTunnelReq</span><br><span class="line">		tunnelReq.Protocol = proto</span><br><span class="line"></span><br><span class="line">		c.conn.Debug(<span class="string">"Registering new tunnel"</span>)</span><br><span class="line">		t, err := NewTunnel(&amp;tunnelReq, c)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.out &lt;- &amp;msg.NewTunnel&#123;Error: err.Error()&#125;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(c.tunnels) == <span class="number">0</span> &#123;</span><br><span class="line">				c.shutdown.Begin()</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// we're done</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// add it to the list of tunnels</span></span><br><span class="line">		c.tunnels = <span class="built_in">append</span>(c.tunnels, t)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// acknowledge success</span></span><br><span class="line">		c.out &lt;- &amp;msg.NewTunnel&#123;</span><br><span class="line">			Url:      t.url,</span><br><span class="line">			Protocol: proto,</span><br><span class="line">			ReqId:    rawTunnelReq.ReqId,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rawTunnelReq.Hostname = strings.Replace(t.url, proto + <span class="string">"://"</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">manager</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// don't crash on panics</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.conn.Info(<span class="string">"Control::manager failed with error %v: %s"</span>, err, debug.Stack())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kill everything if the control manager stops</span></span><br><span class="line">	<span class="keyword">defer</span> c.shutdown.Begin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// notify that manager() has shutdown</span></span><br><span class="line">	<span class="keyword">defer</span> c.managerShutdown.Complete()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// reaping timer for detecting heartbeat failure</span></span><br><span class="line">	reap := time.NewTicker(connReapInterval)</span><br><span class="line">	<span class="keyword">defer</span> reap.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-reap.C:</span><br><span class="line">			<span class="keyword">if</span> time.Since(c.lastPing) &gt; pingTimeoutInterval &#123;</span><br><span class="line">				c.conn.Info(<span class="string">"Lost heartbeat"</span>)</span><br><span class="line">				c.shutdown.Begin()</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> mRaw, ok := &lt;-c.in:</span><br><span class="line">		<span class="comment">// c.in closes to indicate shutdown</span></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> m := mRaw.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *msg.ReqTunnel:</span><br><span class="line">				c.registerTunnel(m)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> *msg.Ping:</span><br><span class="line">				c.lastPing = time.Now()</span><br><span class="line">				c.out &lt;- &amp;msg.Pong&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">writer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.conn.Info(<span class="string">"Control::writer failed with error %v: %s"</span>, err, debug.Stack())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kill everything if the writer() stops</span></span><br><span class="line">	<span class="keyword">defer</span> c.shutdown.Begin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// notify that we've flushed all messages</span></span><br><span class="line">	<span class="keyword">defer</span> c.writerShutdown.Complete()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write messages to the control channel</span></span><br><span class="line">	<span class="keyword">for</span> m := <span class="keyword">range</span> c.out &#123;</span><br><span class="line">		c.conn.SetWriteDeadline(time.Now().Add(controlWriteTimeout))</span><br><span class="line">		<span class="keyword">if</span> err := msg.WriteMsg(c.conn, m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">reader</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.conn.Warn(<span class="string">"Control::reader failed with error %v: %s"</span>, err, debug.Stack())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kill everything if the reader stops</span></span><br><span class="line">	<span class="keyword">defer</span> c.shutdown.Begin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// notify that we're done</span></span><br><span class="line">	<span class="keyword">defer</span> c.readerShutdown.Complete()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read messages from the control channel</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg, err := msg.ReadMsg(c.conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				c.conn.Info(<span class="string">"EOF"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// this can also panic during shutdown</span></span><br><span class="line">			c.in &lt;- msg</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">stopper</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.conn.Error(<span class="string">"Failed to shut down control: %v"</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait until we're instructed to shutdown</span></span><br><span class="line">	c.shutdown.WaitBegin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// remove ourself from the control registry</span></span><br><span class="line">	controlRegistry.Del(c.id)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shutdown manager() so that we have no more work to do</span></span><br><span class="line">	<span class="built_in">close</span>(c.in)</span><br><span class="line">	c.managerShutdown.WaitComplete()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shutdown writer()</span></span><br><span class="line">	<span class="built_in">close</span>(c.out)</span><br><span class="line">	c.writerShutdown.WaitComplete()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// close connection fully</span></span><br><span class="line">	c.conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shutdown all of the tunnels</span></span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> c.tunnels &#123;</span><br><span class="line">		t.Shutdown()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shutdown all of the proxy connections</span></span><br><span class="line">	<span class="built_in">close</span>(c.proxies)</span><br><span class="line">	<span class="keyword">for</span> p := <span class="keyword">range</span> c.proxies &#123;</span><br><span class="line">		p.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.shutdown.Complete()</span><br><span class="line">	c.conn.Info(<span class="string">"Shutdown complete"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">RegisterProxy</span><span class="params">(conn conn.Conn)</span></span> &#123;</span><br><span class="line">	conn.AddLogPrefix(c.id)</span><br><span class="line"></span><br><span class="line">	conn.SetDeadline(time.Now().Add(proxyStaleDuration))</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c.proxies &lt;- conn:</span><br><span class="line">		conn.Info(<span class="string">"Registered"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		conn.Info(<span class="string">"Proxies buffer is full, discarding."</span>)</span><br><span class="line">		conn.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove a proxy connection from the pool and return it</span></span><br><span class="line"><span class="comment">// If not proxy connections are in the pool, request one</span></span><br><span class="line"><span class="comment">// and wait until it is available</span></span><br><span class="line"><span class="comment">// Returns an error if we couldn't get a proxy because it took too long</span></span><br><span class="line"><span class="comment">// or the tunnel is closing</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">GetProxy</span><span class="params">()</span> <span class="params">(proxyConn conn.Conn, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// get a proxy connection from the pool</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> proxyConn, ok = &lt;-c.proxies:</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">"No proxy connections available, control is closing"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">// no proxy available in the pool, ask for one over the control channel</span></span><br><span class="line">		c.conn.Debug(<span class="string">"No proxy in pool, requesting proxy from control . . ."</span>)</span><br><span class="line">		<span class="keyword">if</span> err = util.PanicToError(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.out &lt;- &amp;msg.ReqProxy&#123;&#125;</span><br><span class="line">		&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> proxyConn, ok = &lt;-c.proxies:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					err = fmt.Errorf(<span class="string">"No proxy connections available, control is closing"</span>)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(pingTimeoutInterval):</span><br><span class="line">				err = fmt.Errorf(<span class="string">"Timeout trying to get proxy connection"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when this control is replaced by another control</span></span><br><span class="line"><span class="comment">// this can happen if the network drops out and the client reconnects</span></span><br><span class="line"><span class="comment">// before the old tunnel has lost its heartbeat</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">Replaced</span><span class="params">(replacement *Control)</span></span> &#123;</span><br><span class="line">	c.conn.Info(<span class="string">"Replaced by control: %s"</span>, replacement.conn.Id())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set the control id to empty string so that when stopper()</span></span><br><span class="line">	<span class="comment">// calls registry.Del it won't delete the replacement</span></span><br><span class="line">	c.id = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// tell the old one to shutdown</span></span><br><span class="line">	c.shutdown.Begin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/05/31/ngrok/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/ngrok/" itemprop="url">
                  内网穿透 ngrok 服务器和客户端配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-31 12:49:49 / 修改时间：13:04:33" itemprop="dateCreated datePublished" datetime="2018-05-31T12:49:49+08:00">2018-05-31</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/环境搭建/" itemprop="url" rel="index"><span itemprop="name">环境搭建</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="ngrok-简介及作用"><a href="#ngrok-简介及作用" class="headerlink" title="ngrok 简介及作用"></a>ngrok 简介及作用</h4><p>ngrok 是一款用 go 语言开发的开源软件，它是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。</p>
<h4 id="server-环境配置"><a href="#server-环境配置" class="headerlink" title="server 环境配置"></a>server 环境配置</h4><ul>
<li><p>git 上下载</p>
</li>
<li><p>生成证书</p>
</li>
<li><p>生成服务器版本 server 上安装的 ngrokd</p>
</li>
<li><p>生成各个平台上的 client 上安装的 ngrok</p>
</li>
</ul>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>有一些要点要特别注意，我就是在这些东西上面绕了很久，配置的时候需要特别注意的地方：</p>
<h4 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置:"></a>防火墙设置:</h4><p>服务器和客户端都要关闭对应端口的防火墙，否则不能链接会一直显示 connecting</p>
<h4 id="证书一定要设置正确："><a href="#证书一定要设置正确：" class="headerlink" title="证书一定要设置正确："></a>证书一定要设置正确：</h4><p>证书会被编译到可执行文件中去，所以设置的时候需要正确设置地址，如果设置错误，最好是重新 git clone 一份代码来配置，make clean 在这里面似乎不能清除原有的配置。<br>交叉编译的时候要注意平台是 32 位系统（386）、64 位系统（amd64）或者 arm ，设置错了不能运行</p>
<h4 id="server-配置"><a href="#server-配置" class="headerlink" title="server 配置"></a>server 配置</h4><p>首先要安装 server 必须要的软件, 因为现在的阿里云自己的镜像带了 rhel 的源，所以可以直接偷懒用 yum 安装所有的东西。</p>
<h4 id="git-下载"><a href="#git-下载" class="headerlink" title="git 下载"></a>git 下载</h4><p>我安装的时候用的 root, 所以比较偷懒的在目录 /root/ 下配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root</span><br></pre></td></tr></table></figure>
<h4 id="官方地址，可能会报错，最近应该已经修复"><a href="#官方地址，可能会报错，最近应该已经修复" class="headerlink" title="官方地址，可能会报错，最近应该已经修复"></a>官方地址，可能会报错，最近应该已经修复</h4><p>git clone <a href="https://github.com/inconshreveable/ngrok.git" target="_blank" rel="external">https://github.com/inconshreveable/ngrok.git</a></p>
<h4 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h4><p>在使用官方服务的时候，我们使用的是官方的 SSL 证书，所以如果直接编译的话，默认的链接地址会到官方的 ngrok.com 去，所以我们需要自己生成证书。 <strong> 证书非常关键，所有编译的文件都会携带证书文件在程序内部 </strong> 所以证书生成的时候要保证所有的地方都是对应的。</p>
<p>首先我们要确定我们要使用的地址，这是受到域名解析服务的影响的。最简单的办法就是 ping 一下这个地址看是不是能够获得自己的服务器 ip 。这个服务一定是架设在当前的服务器上的，所以 dns 一定是 ping 了之后指向当前的服务器。</p>
<p>我使用的域名是 www.example.com ， ip 地址就是我自己的服务器。最好先 ping 一下确定一下，有一些 dns 没有绑定，会导致不能访问；如果更换域名，又需要重新来一遍全过程，非常繁琐。所以一定要先确定好。</p>
<p>当域名为 www.example.com 的时候，最终效果是远程机器的设置子域名为 abc 时，访问 abc.www.example.com: 端口 就可以。端口是由运行的时候配置的，并不需要确定某一个端口，都是可以设置的。</p>
<p>大概的原理和效果讲清楚之后就开始写怎么做了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/ngrok</span><br></pre></td></tr></table></figure>
<h4 id="这里修改为自己的域名"><a href="#这里修改为自己的域名" class="headerlink" title="这里修改为自己的域名"></a>这里修改为自己的域名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NGROK_DOMAIN=<span class="string">"www.example.com"</span></span><br><span class="line"></span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj <span class="string">"/CN=<span class="variable">$NGROK_DOMAIN</span>"</span> -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj <span class="string">"/CN=<span class="variable">$NGROK_DOMAIN</span>"</span> -out device.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br></pre></td></tr></table></figure>
<p>首先进入到 ngrok 的目录，然后设定域名地址，这里需要修改为自己的。openssl 就是生成 SSL 证书文件的过程，之后会在 ngrok 目录下生成 root,device 等六个文件。 然后需要拷贝到配置的目录中，在编译的时候会使用这些文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -r rootCA.pem assets/client/tls/ngrokroot.crt </span><br><span class="line">cp -r device.crt assets/server/tls/snakeoil.crt </span><br><span class="line">cp -r device.key assets/server/tls/snakeoil.key</span><br></pre></td></tr></table></figure>
<h4 id="生成服务器的-ngrokd"><a href="#生成服务器的-ngrokd" class="headerlink" title="生成服务器的 ngrokd"></a>生成服务器的 ngrokd</h4><p>前面的配置工作已经完成，后面的就比较简单轻松了。由于是 go 语言写的，所以使用 golang 的 make 选项就好。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/ngrok</span><br><span class="line">make release-server</span><br></pre></td></tr></table></figure>
<p>等待下载和构建，如果下载失败什么的，估计是因为链接国外的服务器会断线的问题，重新运行一遍 make release-server 就好。</p>
<p>构建完成以后可以在 bin 目录下看到 ngrokd 这个文件，这个就是我们后面要开启的服务器端，现在先不要运行。</p>
<h4 id="编译客户端的-ngrok"><a href="#编译客户端的-ngrok" class="headerlink" title="编译客户端的 ngrok"></a>编译客户端的 ngrok</h4><p>这里我们需要交叉编译，使用不同的编译选项来选择编译以后生成的平台</p>
<p>这里我主要是生成了 windows 、 arm 和 Linux 的版本。继续在原先的目录下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 make release-client</span><br><span class="line">GOOS=windows GOARCH=amd64 make release-client</span><br><span class="line">GOOS=linux GOARCH=arm make release-client</span><br></pre></td></tr></table></figure>
<p>不同平台使用不同的 GOOS 和 GOARCH，前面的编译选项就是指 go os , go 编译出来的操作系统 (windows,linux,darwin) ；go arch, 对应的构架 (386,amd64,arm)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Linux 平台 32 位系统：GOOS=linux GOARCH=386</span><br><span class="line">Linux 平台 64 位系统：GOOS=linux GOARCH=amd64</span><br><span class="line"></span><br><span class="line">Windows 平台 32 位系统：GOOS=windows GOARCH=386</span><br><span class="line">Windows 平台 64 位系统：GOOS=windows GOARCH=amd64</span><br><span class="line"></span><br><span class="line">MAC 平台 32 位系统：GOOS=darwin GOARCH=386</span><br><span class="line">MAC 平台 64 位系统：GOOS=darwin GOARCH=amd64</span><br><span class="line"></span><br><span class="line">ARM 平台：GOOS=linux GOARCH=arm</span><br></pre></td></tr></table></figure>
<p>通过前面的步骤，就会在bin目录里面生成所有的客户端文件，客户端平台是文件夹的名字，客户端放在对应的目录下，当前Linux平台客户端在bin目录下。然后我们就可以打个包，把所有文件下载到自己的本机了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/ngrok</span><br><span class="line">zip -r bin/</span><br></pre></td></tr></table></figure>
<p>然后生成了Bin.zip的文件，通过scp之类的工具下载。</p>
<p>这个里面的注意</p>
<p>服务端叫 ngrokd</p>
<p>客户端叫 ngrok</p>
<p>所以以后要放到对应的平台，就只需要对应平台里面的ngrok文件就可以了。</p>
<h4 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h4><p>在server端直接执行就可以了，其中NGROK_DOMAIN对应的就是一开始设置过的域名地址。</p>
<p>但是有一点要重点注意，就是httpAddr等端口的设置。</p>
<p>httpAddr 是访问普通的http使用的端口号，用后面用 子域名.www.aiesst.com:6060 来访问服务</p>
<p>httpsAddr 是访问的https使用的端口号,同上，只不过是需要https的服务访问才用这个端口</p>
<p>tunnelAddr 是通道的端口号，这个端口是Ngrok用来通信的，所以这个端口在服务器上和客户端上设置必须要对应才可以正常的链接，默认不填写好像是4433</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/ngrok</span><br><span class="line">NGROK_DOMAIN=<span class="string">"www.aiesst.com"</span></span><br><span class="line"><span class="comment">#http,https,tcp, 注意：如果不需要http/https支持,可以直接类似-httpAddr=""来表示</span></span><br><span class="line">bin/ngrokd -domain=<span class="string">"<span class="variable">$NGROK_DOMAIN</span>"</span> -httpAddr=<span class="string">":6060"</span> -httpsAddr=<span class="string">":6061"</span> -tunnelAddr=<span class="string">":6062"</span> </span><br><span class="line"><span class="comment">#https设置了tls</span></span><br><span class="line"><span class="comment">#bin/ngrokd -domain="www.aiesst.com" -httpAddr=":6060" -httpsAddr=":6061" -tunnelAddr=":6062" -tlsKey=./device.key -tlsCrt=./device.crt</span></span><br></pre></td></tr></table></figure>
<h4 id="验证端口是否打开的问题"><a href="#验证端口是否打开的问题" class="headerlink" title="验证端口是否打开的问题"></a>验证端口是否打开的问题</h4><p>当打开了服务端程序之后，如果有疑问可以测试一下，因为有时候可能会遇到这个问题。我在一开始的时候并没有注意到防火墙问题，所以一直导致不能成功。除了这个问题之外，使用阿里云还有一些问题，就是我使用的系统是CentOS，默认是没有打开对应的端口的，如果遇到这个问题需要先验证一下端口是否打开。我使用了工具nc来测试。</p>
<p>使用的命令是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -v -w 10 -z 127.0.0.1 6060-6062</span><br></pre></td></tr></table></figure>
<p>如果显示的3个端口都有响应（都显示了 succeeded 就是正常），那么就可以继续开始后面的步骤。</p>
<h4 id="打开防火墙"><a href="#打开防火墙" class="headerlink" title="打开防火墙"></a>打开防火墙</h4><p>如果是centOS的系统，防火墙应该是 firewall-cmd 来控制。对应的命令就是，其中端口号要写自己的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=6060-6062/tcp  //永久</span><br><span class="line"><span class="comment">#firewall-cmd  --zone=public --add-port=6060-6062/tcp   //临时</span></span><br></pre></td></tr></table></figure>
<p>如果是ubuntu之类的系统，防火墙一般是iptables来控制，对应的命令就是，也要修改自己的端口号才可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 6060-6062 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 6060-6062 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>打开了服务器的端口，然后就可以继续配置客户端。</p>
<h4 id="配置windows客户端"><a href="#配置windows客户端" class="headerlink" title="配置windows客户端"></a>配置windows客户端</h4><p>这里的客户端就是指另外一台电脑，这一台电脑可以链接到服务器的电脑上，客户端常常是我们内网的电脑，这个就是ngrok实现的最大意义，可以和在公网的服务器通信之后，再直接访问内网电脑提供的服务，实现内网穿透。</p>
<p>这里我先使用了windows来测试，因为平时用的系统，有各种工具，相对会比较方便。</p>
<p>先找到一开始通过 scp 下载的 Bin.zip 文件，解压到任意目录。然后找到window版本的客户端 ngrok.exe。复制到任意目录，自己方便操作就好。我使用了 D:\tmp\ 文件夹</p>
<p>先在这个目录下建立一个文件 ngrok.cfg ,然后写入内容:</p>
<p>地址和服务器设置的 NGROK_DOMAIN=”www.aiesst.com” 中的地址保持一致<br>端口和服务器设置的通道端口 tunnelAddr=”:6062” 保持一致</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server_addr: <span class="string">"www.aiesst.com:6062"</span></span><br><span class="line">trust_host_root_certs: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>然后 ctrl-r 打开运行，运行 cmd，输入：</p>
<p>日志： -log=ngrok_log.txt 是记录ngrok的日志，如果前期调试的时候加上这个参数，如果不能访问就可以查看到底是什么问题</p>
<p>子域名： -subdomain=abc 是定义访问的时候的子域名，现在访问 </p>
<p>abc.www.aiesst.com:6060 就可以访问到这一台机器上80端口的服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:</span><br><span class="line"><span class="built_in">cd</span> tmp</span><br><span class="line">ngrok.exe -<span class="built_in">log</span>=ngrok_log.txt -subdomain=abc -config=<span class="string">"ngrok.cfg"</span> 80</span><br></pre></td></tr></table></figure></p>
<p>稍微等待5秒钟，如果看到显示有 tunnel status: online ,那么后面的 forwarding 对应的内容就是访问本机的地址。</p>
<p>当然在windows上面，你需要再跑一个其他的服务在80端口可以看到访问的效果。</p>
<p>总之就是如果显示了 tunnel status: online 就是服务器和客户端是正常链接的，通过浏览器访问 abc.www.aiesst.com:6060 就可以链接到现在的内网主机上的服务。</p>
<h4 id="TCP转发"><a href="#TCP转发" class="headerlink" title="TCP转发"></a>TCP转发</h4><p>这里以转发ssh为例，重新改写客户端配置文件ngrok.cfg</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server_addr: ngrok.sfantree.com:4443</span><br><span class="line">trust_host_root_certs: <span class="literal">false</span></span><br><span class="line">tunnels:</span><br><span class="line">    http:</span><br><span class="line">        proto:</span><br><span class="line">            http: 80</span><br><span class="line">        subdomain: pi</span><br><span class="line">    ssh:</span><br><span class="line">        remote_port: 10086</span><br><span class="line">        proto:</span><br><span class="line">            tcp: 22</span><br></pre></td></tr></table></figure>
<p>这里我把需要转发的http和ssh都写入配置文件，其他tcp服务语法格式和ssh相似，remote_port为远程端口，等下外网连接的时候用的就是这个remote_port，tcp:22为需要转发的本地端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok-for-arm -config=ngrok.cfg start http ssh</span><br></pre></td></tr></table></figure>
<p>重新运行客户端，start指明需要的服务类型，建议开一个screen。</p>
<p>ssh popy32@ngrok.sfantree.com -p 10086<br>连接时指明远程端口</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从Ngrok强大的反向代理功能可以看出Go语言独特魅力,除了glibc的版本有一定要求,其跨平台编译为部署省去了不少时间,当然Go还有更多的优点，本文提到的也只是Ngrok的冰山一角，利用其TCP转发也可以远程SSH树莓派，更多玩法就自行百谷了。</p>
<p>来源：<a href="https://blog.csdn.net/y_xianjun/article/details/73194622" target="_blank" rel="external">https://blog.csdn.net/y_xianjun/article/details/73194622</a></p>
<h4 id="注意：使用Vue开发时候，调试时候会报“Invalid-Host-Header”，-工程需要在webpack-dev-conf-js文件的devServer字段设置disableHostCheck-true才能允许代理访问"><a href="#注意：使用Vue开发时候，调试时候会报“Invalid-Host-Header”，-工程需要在webpack-dev-conf-js文件的devServer字段设置disableHostCheck-true才能允许代理访问" class="headerlink" title="注意：使用Vue开发时候，调试时候会报“Invalid Host Header”， 工程需要在webpack.dev.conf.js文件的devServer字段设置disableHostCheck: true才能允许代理访问"></a>注意：使用Vue开发时候，调试时候会报<code>“Invalid Host Header”</code>， 工程需要在<code>webpack.dev.conf.js</code>文件的devServer字段设置<code>disableHostCheck: true</code>才能允许代理访问</h4>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/05/27/node-update/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/27/node-update/" itemprop="url">
                  Node升级的正确方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-27 08:55:04 / 修改时间：16:07:34" itemprop="dateCreated datePublished" datetime="2018-05-27T08:55:04+08:00">2018-05-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Node-js/" itemprop="url" rel="index"><span itemprop="name">Node.js</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法:"></a>安装方法:</h4><h4 id="1-产看node版本，没安装的请先安装"><a href="#1-产看node版本，没安装的请先安装" class="headerlink" title="1.产看node版本，没安装的请先安装"></a>1.产看node版本，没安装的请先安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  node -v</span><br></pre></td></tr></table></figure>
<h4 id="2-清楚node缓存"><a href="#2-清楚node缓存" class="headerlink" title="2.清楚node缓存"></a>2.清楚node缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo npm cache clean -f</span><br></pre></td></tr></table></figure>
<h4 id="3-安装node版本管理工具’n’"><a href="#3-安装node版本管理工具’n’" class="headerlink" title="3.安装node版本管理工具’n’"></a>3.安装node版本管理工具’n’</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo npm install n -g</span><br></pre></td></tr></table></figure>
<h4 id="4-使用版本管理工具安装指定node或者升级到最新node版本"><a href="#4-使用版本管理工具安装指定node或者升级到最新node版本" class="headerlink" title="4.使用版本管理工具安装指定node或者升级到最新node版本"></a>4.使用版本管理工具安装指定node或者升级到最新node版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$  sudo n stable  （安装node最新版本）</span><br><span class="line"></span><br><span class="line">$  sudo n 8.9.4 （安装node指定版本8.9.4）</span><br></pre></td></tr></table></figure>
<h4 id="5-使用node-v查看node版本，如果版本号改变为你想要的则升级成功"><a href="#5-使用node-v查看node版本，如果版本号改变为你想要的则升级成功" class="headerlink" title="5.使用node -v查看node版本，如果版本号改变为你想要的则升级成功"></a>5.使用node -v查看node版本，如果版本号改变为你想要的则升级成功</h4><p>若版本号未改变则还需配置node环境变量</p>
<h4 id="1-查看通过n安装的node的位置"><a href="#1-查看通过n安装的node的位置" class="headerlink" title="1.查看通过n安装的node的位置"></a>1.查看通过n安装的node的位置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">which</span> node  (如：/usr/<span class="built_in">local</span>/n/versions/node/6.12.3）</span><br></pre></td></tr></table></figure>
<h4 id="2-cd进入-usr-local-n-versions-node-你应该能看到你刚通过n安装的node版本这里如：8-9-4；编辑-etc-profile"><a href="#2-cd进入-usr-local-n-versions-node-你应该能看到你刚通过n安装的node版本这里如：8-9-4；编辑-etc-profile" class="headerlink" title="2.cd进入/usr/local/n/versions/node/ 你应该能看到你刚通过n安装的node版本这里如：8.9.4；编辑/etc/profile"></a>2.cd进入/usr/local/n/versions/node/ 你应该能看到你刚通过n安装的node版本这里如：8.9.4；编辑/etc/profile</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  vim /etc/profile</span><br></pre></td></tr></table></figure>
<h4 id="3-将node安装的路径（这里为：-usr-local-n-versions-node-8-9-4）添加到文件末尾"><a href="#3-将node安装的路径（这里为：-usr-local-n-versions-node-8-9-4）添加到文件末尾" class="headerlink" title="3.将node安装的路径（这里为：/usr/local/n/versions/node/8.9.4）添加到文件末尾"></a>3.将node安装的路径（这里为：/usr/local/n/versions/node/8.9.4）添加到文件末尾</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set node path</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/usr/<span class="built_in">local</span>/n/versions/node/8.9.4</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$NODE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<h4 id="4-wq退出保存文件，编译-etc-profile"><a href="#4-wq退出保存文件，编译-etc-profile" class="headerlink" title="4.wq退出保存文件，编译/etc/profile"></a>4.wq退出保存文件，编译/etc/profile</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<h4 id="5-再次使用node-v查看node版本，不出意外版本号应该变为你想要的"><a href="#5-再次使用node-v查看node版本，不出意外版本号应该变为你想要的" class="headerlink" title="5.再次使用node -v查看node版本，不出意外版本号应该变为你想要的"></a>5.再次使用node -v查看node版本，不出意外版本号应该变为你想要的</h4><p>来源：<a href="https://blog.csdn.net/tlbaba/article/details/79412433" target="_blank" rel="external">https://blog.csdn.net/tlbaba/article/details/79412433</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/05/05/linux-event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/linux-event/" itemprop="url">
                  Linux内核基础--事件通知链(notifier chain)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-05 19:53:30 / 修改时间：20:07:33" itemprop="dateCreated datePublished" datetime="2018-05-05T19:53:30+08:00">2018-05-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="内核通知链"><a href="#内核通知链" class="headerlink" title="内核通知链"></a>内核通知链</h4><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h4><p>Linux内核中各个子系统相互依赖，当其中某个子系统状态发生改变时，就必须使用一定的机制告知使用其服务的其他子系统，以便其他子系统采取相应的措施。为满足这样的需求，内核实现了事件通知链机制（notificationchain）。</p>
<p>通知链只能用在各个子系统之间，而不能在内核和用户空间进行事件的通知。组成内核的核心系统代码均位于kernel目录下，通知链表位于kernel/notifier.c中，对应的头文件为include/linux/notifier.h。通知链表机制并不复杂，实现它的代码只有区区几百行。</p>
<p>事件通知链表是一个事件处理函数的列表，每个通知链都与某个或某些事件有关，当特定的事件发生时，就调用相应的事件通知链中的回调函数，进行相应的处理。</p>
<h4 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h4><p>Linux内核驱动开发之KGDB原理介绍及kgdboe方式配置 <a href="http://www.linuxidc.com/Linux/2013-06/86406.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2013-06/86406.htm</a></p>
<p>Linux内核中memcpy和memmove函数的区别和实现 <a href="http://www.linuxidc.com/Linux/2013-06/85344.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2013-06/85344.htm</a></p>
<p><img src="/2018/05/05/linux-event/1.png" alt="">图 1</p>
<h4 id="1-2．数据结构"><a href="#1-2．数据结构" class="headerlink" title="1.2．数据结构"></a>1.2．数据结构</h4><p>如图 1中所示，Linux的网络子系统一共有3个通知链：表示ipv4地址发生变化时的inetaddr_chain；表示ipv6地址发生变化的inet6addr_chain；还有表示设备注册、状态变化的netdev_chain。</p>
<p>在这些链中都是一个个notifier_block结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> (*notifier_call)(struct notifier_block *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">void</span> *);</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">next</span>;</span></span><br><span class="line">      <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，</p>
<ol>
<li><p>notifier_call：当相应事件发生时应该调用的函数，由被通知方提供，如other_subsys_1；</p>
</li>
<li><p>notifier_block *next：用于链接成链表的指针；</p>
</li>
<li><p>priority：回调函数的优先级，一般默认为0。</p>
</li>
</ol>
<p>内核代码中一般把通知链命名为xxx_chain, xxx_nofitier_chain这种形式的变量名。围绕核心数据结构notifier_block，内核定义了四种通知链类型：</p>
<ol>
<li><p>原子通知链（ Atomic notifier chains ）：通知链元素的回调函数（当事件发生时要执行的函数）在中断或原子操作上下文中运行，不允许阻塞。对应的链表头结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="keyword">spinlock_t</span>  lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可阻塞通知链（ Blocking notifier chains ）：通知链元素的回调函数在进程上下文中运行，允许阻塞。对应的链表头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">blocking_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">rw_semaphore</span>  <span class="title">rwsem</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>  *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原始通知链（ Raw notifierchains ）：对通知链元素的回调函数没有任何限制，所有锁和保护机制都由调用者维护。对应的链表头：</p>
</li>
</ol>
<p>网络子系统就是该类型，通过以下宏实现head的初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">RAW_NOTIFIER_HEAD</span><span class="params">(netdev_chain)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_NOTIFIER_INIT(name)    &#123;      \</span></span><br><span class="line">              .head= <span class="literal">NULL</span> &#125;</span><br><span class="line">#define RAW_NOTIFIER_HEAD(name)        \      <span class="comment">//调用他就好了</span></span><br><span class="line">struct raw_notifier_head name =        \</span><br><span class="line">                    RAW_NOTIFIER_INIT(name)  </span><br><span class="line">即：</span><br><span class="line">struct raw_notifier_head netdev_chain = &#123;</span><br><span class="line">          .head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而其回调函数的注册，比如向netdev_chain的注册函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">register_netdevice_notifier。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">raw_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>  *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>SRCU 通知链（ SRCU notifier chains ）：可阻塞通知链的一种变体。对应的链表头：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">srcu_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">srcu_struct</span>  <span class="title">srcu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>  *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="1-3-运行机理"><a href="#1-3-运行机理" class="headerlink" title="1.3. 运行机理"></a>1.3. 运行机理</h4><p>被通知一方（other_subsys_x）通过notifier_chain_register向特定的chain注册回调函数，并且一般而言特定的子系统会用特定的notifier_chain_register包装函数来注册，比如路由子系统使用的是网络子系统的：register_netdevice_notifier来注册他的notifier_block。</p>
<h4 id="1-3-1-向事件通知链注册的步骤"><a href="#1-3-1-向事件通知链注册的步骤" class="headerlink" title="1.3.1. 向事件通知链注册的步骤"></a>1.3.1. 向事件通知链注册的步骤</h4><ol>
<li><p>申明struct notifier_block结构</p>
</li>
<li><p>编写notifier_call函数</p>
</li>
<li><p>调用特定的事件通知链的注册函数，将notifier_block注册到通知链中</p>
</li>
</ol>
<p>如果内核组件需要处理够某个事件通知链上发出的事件通知，其就该在初始化时在该通知链上注册回调函数。</p>
<h4 id="1-3-2-通知子系统有事件发生"><a href="#1-3-2-通知子系统有事件发生" class="headerlink" title="1.3.2. 通知子系统有事件发生"></a>1.3.2. 通知子系统有事件发生</h4><p>inet_subsys是通过notifier_call_chain来通知其他的子系统（other_subsys_x）的。</p>
<p>notifier_call_chain会按照通知链上各成员的优先级顺序执行回调函数（notifier_call_x）；回调函数的执行现场在notifier_call_chain进程地址空间；其返回值是NOTIFY_XXX的形式，在include/linux/notifier.h中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_DONE            0x0000        <span class="comment">/* 对事件视而不见 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_OK          0x0001        <span class="comment">/* 事件正确处理 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_STOP_MASK  0x8000        <span class="comment">/*由notifier_call_chain检查，看继续调用回调函数，还是停止，_BAD和_STOP中包含该标志 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_BAD        (NOTIFY_STOP_MASK|0x0002)      <span class="comment">/*事件处理出错，不再继续调用回调函数 */</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Clean way to return from the notifier and stop further calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_STOP            (NOTIFY_OK|NOTIFY_STOP_MASK)    <span class="comment">/*  回调出错，不再继续调用该事件回调函数 */</span></span></span><br></pre></td></tr></table></figure></p>
<p>notifier_call_chain捕获并返回最后一个事件处理函数的返回值；注意：notifier_call_chain可能同时被不同的cpu调用，故而调用者必须保证互斥。</p>
<h4 id="1-3-3-事件列表"><a href="#1-3-3-事件列表" class="headerlink" title="1.3.3. 事件列表"></a>1.3.3. 事件列表</h4><p>对于网络子系统而言，其事件常以NETDEV_XXX命名；描述了网络设备状态（dev-&gt;flags）、传送队列状态（dev-&gt;state）、设备注册状态（dev-&gt;reg_state），以及设备的硬件功能特性（dev-&gt;features）：</p>
<p>include/linux/notifier.h中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* netdevice notifier chain */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_UP  0x0001  <span class="comment">/* 激活一个网络设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_DOWN  0x0002f <span class="comment">/* 停止一个网络设备，所有对该设备的引用都应释放 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_REBOOT      0x0003      <span class="comment">/* 检查到网络设备接口硬件崩溃，硬件重启 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGE      0x0004  <span class="comment">/* 网络设备的数据包队列状态发生改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_REGISTER  0x0005  <span class="comment">/*一个网络设备事例注册到系统中，但尚未激活 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_UNREGISTER      0x0006      <span class="comment">/*网络设备驱动已卸载 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGEMTU      0x0007  <span class="comment">/*MTU发生了改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGEADDR    0x0008  <span class="comment">/*硬件地址发生了改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_GOING_DOWN  0x0009  <span class="comment">/*网络设备即将注销，有dev-&gt;close报告，通知相关子系统处理 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGENAME  0x000A  <span class="comment">/*网络设备名改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_FEAT_CHANGE    0x000B  <span class="comment">/*feature网络硬件功能改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_FAILOVER 0x000C  <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_PRE_UP        0x000D  <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_OLDTYPE  0x000E              <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_NEWTYPE  0x000F      <span class="comment">/*    */</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="1-4-简单一例："><a href="#1-4-简单一例：" class="headerlink" title="1.4. 简单一例："></a>1.4. 简单一例：</h4><p>通过上面所述，notifier_chain机制只能在内核个子系统间使用，因此，这里使用3个模块：test_notifier_chain_0、test_notifier_chain_1、test_notifier_chain_2；当 test_notifier_chain_2通过module_init初始化模块时发出事件TESTCHAIN_2_INIT；然后 test_notifier_chain_1作出相应的处理：打印 test_notifier_chain_2正在初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_0.c ：0. 申明一个通知链；1. 向内核注册通知链；2. 定义事件；3. 导出符号，因而必需最后退出*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; /* printk() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt; /* everything() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">RAW_NOTIFIER_HEAD</span><span class="params">(test_chain)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* define our own notifier_call_chain */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call_test_notifiers</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> raw_notifier_call_chain(&amp;test_chain, val, v);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(call_test_notifiers);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* define our own notifier_chain_register func */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">err = raw_notifier_chain_register(&amp;test_chain, nb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(register_test_notifier);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_0_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_DEBUG <span class="string">"I'm in test_chain_0\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_0_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_DEBUG <span class="string">"Goodbye to test_chain_0\n"</span>);</span><br><span class="line"><span class="comment">// call_test_notifiers(TESTCHAIN_EXIT, (int *)NULL);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL v2"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"></span><br><span class="line">module_init(test_chain_0_init);</span><br><span class="line">module_exit(test_chain_0_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* test_chain_1.c ：1. 定义回调函数；2. 定义notifier_block；3. 向chain_0注册notifier_block；*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; /* printk() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt; /* everything() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* realize the notifier_call func */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_init_event</span><span class="params">(struct notifier_block *nb, <span class="keyword">unsigned</span> <span class="keyword">long</span> event,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(event)&#123;</span><br><span class="line"><span class="keyword">case</span> TESTCHAIN_INIT:</span><br><span class="line">printk(KERN_DEBUG <span class="string">"I got the chain event: test_chain_2 is on the way of init\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NOTIFY_DONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* define a notifier_block */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">test_init_notifier</span> = &#123;</span></span><br><span class="line">.notifier_call = test_init_event,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_1_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_DEBUG <span class="string">"I'm in test_chain_1\n"</span>);</span><br><span class="line">register_test_notifier(&amp;test_init_notifier);&lt;SPAN style=<span class="string">"WHITE-SPACE: pre"</span>&gt; &lt;/SPAN&gt;<span class="comment">// 由chain_0提供的设施</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_1_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_DEBUG <span class="string">"Goodbye to test_clain_l\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"></span><br><span class="line">module_init(test_chain_1_init);</span><br><span class="line">module_exit(test_chain_1_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* test_chain_2.c：发出通知链事件*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; /* printk() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt; /* everything() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">call_test_notifiers</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_2_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_DEBUG <span class="string">"I'm in test_chain_2\n"</span>);</span><br><span class="line">call_test_notifiers(TESTCHAIN_INIT, <span class="string">"no_use"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_2_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_DEBUG <span class="string">"Goodbye to test_chain_2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL v2"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"></span><br><span class="line">module_init(test_chain_2_init);</span><br><span class="line">module_exit(test_chain_2_exit);</span><br><span class="line"></span><br><span class="line"># Makefile</span><br><span class="line"></span><br><span class="line"># Comment/uncomment the following line to disable/enable debugging</span><br><span class="line"># DEBUG = y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Add your debugging flag (<span class="keyword">or</span> <span class="keyword">not</span>) to CFLAGS</span><br><span class="line">ifeq ($(DEBUG),y)</span><br><span class="line">DEBFLAGS = -O -g -DSCULL_DEBUG # <span class="string">"-O"</span> is needed to expand inlines</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">DEBFLAGS = -O2</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ifneq ($(KERNELRELEASE),)</span><br><span class="line"># call from kernel build system</span><br><span class="line"></span><br><span class="line">obj-m := test_chain_0.o test_chain_1.o test_chain_2.o</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">KERNELDIR ?= /lib/modules/$(shell uname -r)/build</span><br><span class="line">PWD := $(shell pwd)</span><br><span class="line"></span><br><span class="line">modules:</span><br><span class="line">$(MAKE) -C $(KERNELDIR) M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br><span class="line"></span><br><span class="line">depend .depend dep:</span><br><span class="line">$(CC) $(CFLAGS) -M *.c &gt; .depend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ifeq (.depend,$(wildcard .depend))</span><br><span class="line">include .depend</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">[wang2@iwooing: notifier_chian]$ sudo insmod./test_chain_0.ko</span><br><span class="line">[wang2@iwooing: notifier_chian]$ sudo insmod./test_chain_1.ko</span><br><span class="line">[wang2@iwooing: notifier_chian]$ sudo insmod./test_chain_2.ko</span><br><span class="line"></span><br><span class="line">[wang2@iwooing: notifier_chian]$ dmesg</span><br><span class="line"></span><br><span class="line">[ <span class="number">5950.112649</span>] I'm in test_chain_0</span><br><span class="line">[ <span class="number">5956.766610</span>] I'm in test_chain_1</span><br><span class="line">[ <span class="number">5962.570003</span>] I'm in test_chain_2</span><br><span class="line">[ <span class="number">5962.570008</span>] I got the chain event: test_chain_2 is on the way of init</span><br><span class="line"></span><br><span class="line">[ <span class="number">6464.042975</span>] Goodbye to test_chain_2</span><br><span class="line">[ <span class="number">6466.368030</span>] Goodbye to test_clain_l</span><br><span class="line">[ <span class="number">6468.371479</span>] Goodbye to test_chain_0</span><br></pre></td></tr></table></figure>
<h4 id="内核通知链-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt"><a href="#内核通知链-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt" class="headerlink" title="内核通知链&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"></a>内核通知链&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</h4><p>最近在看《深入理解Linux网络内幕》一书，学习了一下书中讲到的内核通知链方面的知识，写了一个读书笔记和一点代码来加深理解，希望能够对大家有一点帮助。内核通知链在网络方面得到了广泛的使用。 </p>
<h4 id="1-通知链表简介"><a href="#1-通知链表简介" class="headerlink" title="1.通知链表简介"></a>1.通知链表简介</h4><p>大多数内核子系统都是相互独立的，因此某个子系统可能对其它子系统产生的事件感兴趣。为了满足这个需求，也即是让某个子系统在发生某个事件时通知其它的子系统，Linux内核提供了通知链的机制。通知链表只能够在内核的子系统之间使用，而不能够在内核与用户空间之间进行事件的通知。 </p>
<p>通知链表是一个函数链表，链表上的每一个节点都注册了一个函数。当某个事情发生时，链表上所有节点对应的函数就会被执行。所以对于通知链表来说有一个通知方与一个接收方。在通知这个事件时所运行的函数由被通知方决定，实际上也即是被通知方注册了某个函数，在发生某个事件时这些函数就得到执行。其实和系统调用signal的思想差不多。 </p>
<h4 id="2-通知链表数据结构"><a href="#2-通知链表数据结构" class="headerlink" title="2.通知链表数据结构"></a>2.通知链表数据结构</h4><p>通知链表的节点类型为notifier_block，其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*notifier_call)(struct notifier_block *self, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中最重要的就是notifier_call这个函数指针，表示了这个节点所对应的要运行的那个函数。next指向下一个节点，即当前事件发生时还要继续执行的那些节点。 </p>
<h4 id="3-注册通知链"><a href="#3-注册通知链" class="headerlink" title="3.注册通知链"></a>3.注册通知链</h4><p>在通知链注册时，需要有一个链表头，它指向这个通知链表的第一个元素。这样，之后的事件对该链表通知时就会根据这个链表头而找到这个链表中所有的元素。 </p>
<p>注册的函数是： </p>
<p>int notifier_chain_register(struct notifier_block <em>*nl, struct notifier_block </em>n) </p>
<p>也即是将新的节点n加入到nl所指向的链表中去。 </p>
<p>卸载的函数是： </p>
<p>int notifier_chain_unregister(strut notifier_block <em>*nl, struct notifier_block </em>n) </p>
<p>也即是将节点n从nl所指向的链表中删除。 </p>
<h4 id="4-通知链表"><a href="#4-通知链表" class="headerlink" title="4.通知链表"></a>4.通知链表</h4><p>当有事件发生时，就使用notifier_call_chain向某个通知链表发送消息。</p>
<p>int notifier_call_chain(struct notifier_block <em>*nl, unsigned long val, void </em>v) </p>
<p>这个函数是按顺序运行nl指向的链表上的所有节点上注册的函数。简单地说，如下所示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">nb</span> = *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nb)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ret = nb-&gt;notifier_call(nb, val, v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &amp; NOTIFY_STOP_MASK)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nb = nb-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5.示例"></a>5.示例</h4><p>在这里，写了一个简单的通知链表的代码。 </p>
<p>实际上，整个通知链的编写也就两个过程：</p>
<pre><code>首先是定义自己的通知链的头节点，并将要执行的函数注册到自己的通知链中。 

其次则是由另外的子系统来通知这个链，让其上面注册的函数运行。 
</code></pre><p>我这里将第一个过程分成了两步来写，第一步是定义了头节点和一些自定义的注册函数（针对该头节点的），第二步则是使用自定义的注册函数注册了一些通知链节点。分别在代码buildchain.c与regchain.c中。 发送通知信息的代码为notify.c。 </p>
<h4 id="代码1-buildchain-c"><a href="#代码1-buildchain-c" class="headerlink" title="代码1 buildchain.c"></a>代码1 buildchain.c</h4><p>它的作用是自定义一个通知链表test_chain，然后再自定义两个函数分别向这个通知链中加入或删除节点，最后再定义一个函数通知这个test_chain链。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 定义自己的通知链头结点以及注册和卸载通知链的外包函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * RAW_NOTIFIER_HEAD是定义一个通知链的头部结点，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 通过这个头部结点可以找到这个链中的其它所有的notifier_block</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">RAW_NOTIFIER_HEAD</span><span class="params">(test_chain)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 自定义的注册函数，将notifier_block节点加到刚刚定义的test_chain这个链表中来</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * raw_notifier_chain_register会调用notifier_chain_register</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> raw_notifier_chain_register(&amp;test_chain, nb);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(register_test_notifier);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unregister_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> raw_notifier_chain_unregister(&amp;test_chain, nb);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(unregister_test_notifier);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 自定义的通知链表的函数，即通知test_chain指向的链表中的所有节点执行相应的函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_notifier_call_chain</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> raw_notifier_call_chain(&amp;test_chain, val, v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(test_notifier_call_chain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * init and exit </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_notifier</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"init_notifier\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">exit_notifier</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"exit_notifier\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_notifier);</span><br><span class="line"></span><br><span class="line">module_exit(exit_notifier);</span><br></pre></td></tr></table></figure></p>
<h4 id="代码2-regchain-c"><a href="#代码2-regchain-c" class="headerlink" title="代码2 regchain.c"></a>代码2 regchain.c</h4><p>该代码的作用是将test_notifier1 test_notifier2 test_notifier3这三个节点加到之前定义的test_chain这个通知链表上，同时每个节点都注册了一个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 注册通知链</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block*)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">unregister_test_notifier</span><span class="params">(struct notifier_block*)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_event1</span><span class="params">(struct notifier_block *<span class="keyword">this</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span> event, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"In Event 1: Event Number is %d\n"</span>, event);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_event2</span><span class="params">(struct notifier_block *<span class="keyword">this</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span> event, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"In Event 2: Event Number is %d\n"</span>, event);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_event3</span><span class="params">(struct notifier_block *<span class="keyword">this</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span> event, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"In Event 3: Event Number is %d\n"</span>, event);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 事件1，该节点执行的函数为test_event1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">test_notifier1</span> =</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">	.notifier_call = test_event1,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 事件2，该节点执行的函数为test_event1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">test_notifier2</span> =</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">	.notifier_call = test_event2,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 事件3，该节点执行的函数为test_event1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">test_notifier3</span> =</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">	.notifier_call = test_event3,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 对这些事件进行注册</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">reg_notifier</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"Begin to register:\n"</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	err = register_test_notifier(&amp;test_notifier1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		printk(<span class="string">"register test_notifier1 error\n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"register test_notifier1 completed\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	err = register_test_notifier(&amp;test_notifier2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		printk(<span class="string">"register test_notifier2 error\n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"register test_notifier2 completed\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	err = register_test_notifier(&amp;test_notifier3);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		printk(<span class="string">"register test_notifier3 error\n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"register test_notifier3 completed\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 卸载刚刚注册了的通知链</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">unreg_notifier</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"Begin to unregister\n"</span>);</span><br><span class="line"></span><br><span class="line">	unregister_test_notifier(&amp;test_notifier1);</span><br><span class="line"></span><br><span class="line">	unregister_test_notifier(&amp;test_notifier2);</span><br><span class="line"></span><br><span class="line">	unregister_test_notifier(&amp;test_notifier3);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"Unregister finished\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(reg_notifier);</span><br><span class="line"></span><br><span class="line">module_exit(unreg_notifier);</span><br></pre></td></tr></table></figure></p>
<h4 id="代码3-notify-c"><a href="#代码3-notify-c" class="headerlink" title="代码3 notify.c"></a>代码3 notify.c</h4><p>该代码的作用就是向test_chain通知链中发送消息，让链中的函数运行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">test_notifier_call_chain</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 向通知链发送消息以触发注册了的函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">call_notifier</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"Begin to notify:\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 调用自定义的函数，向test_chain链发送消息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"==============================\n"</span>);</span><br><span class="line"></span><br><span class="line">	err = test_notifier_call_chain(<span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"==============================\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line"></span><br><span class="line">		printk(<span class="string">"notifier_call_chain error\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">uncall_notifier</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"End notify\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(call_notifier);</span><br><span class="line"></span><br><span class="line">module_exit(uncall_notifier);</span><br></pre></td></tr></table></figure></p>
<h4 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h4><p>obj-m:=buildchain.o regchain.o notify.o</p>
<p>KERNELDIR:=/lib/modules/$(shell uname -r)/build</p>
<p>default:</p>
<pre><code>make -C $(KERNELDIR) M=$(shell pwd) modules
</code></pre><h4 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h4><p>make</p>
<p>insmod buildchain.ko</p>
<p>insmod regchain.ko</p>
<p>insmod notify.ko</p>
<p>这样就可以看到通知链运行的效果了 </p>
<p>下面是我在自己的机器上面运行得到的结果:<br>引用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">init_notifier </span><br><span class="line">Begin to register: </span><br><span class="line">register test_notifier1 completed </span><br><span class="line">register test_notifier2 completed </span><br><span class="line">register test_notifier3 completed </span><br><span class="line">Begin to notify: </span><br><span class="line">============================== </span><br><span class="line">In Event 1: Event Number is 1 </span><br><span class="line">In Event 2: Event Number is 1 </span><br><span class="line">In Event 3: Event Number is 1</span><br></pre></td></tr></table></figure></p>
<p>来源：<a href="https://blog.csdn.net/cheng_fangang/article/details/17350261" target="_blank" rel="external">https://blog.csdn.net/cheng_fangang/article/details/17350261</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/05/05/linux-dma/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/linux-dma/" itemprop="url">
                  什么是DMA
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-05 19:51:28 / 修改时间：19:52:55" itemprop="dateCreated datePublished" datetime="2018-05-05T19:51:28+08:00">2018-05-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>DMA（Direct Memory Access），即直接存储器存取，是一种快速传送数据的机制。数据传递可以从适配卡到内存，从内存到适配卡或从一段内存到另一段内存。
　　</p>
<p>　　利用它进行数据传送时不需要CPU的参与。每台电脑主机板上都有DMA控制器，通常计算机对其编程，并用一个适配器上的ROM(如软盘驱动控制器上的ROM)来储存程序，这些程序控制DMA传送数据。一旦控制器初始化完成，数据开始传送，DMA就可以脱离CPU，独立完成数据传送。</p>
<p>在DMA传送开始的短暂时间内，基本上有两个处理器为它工作，一个执行程序代码，一个传送数据。利用DMA传送数据的另一个好处是，数据直接在源地址和目的地址之间传送，不需要中间媒介。如果通过CPU把一个字节从适配卡传送至内存，需要两步操作。首先，CPU把这个字节从适配卡读到内部寄存器中，然后再从寄存器传送到内存的适当地址。DMA控制器将这些操作简化为一步，它操作总线上的控制信号，使写字节一次完成。这样大大提高了计算机运行速度和工作效率。</p>
<p>计算机发展到今天，DMA已不再用于内存到内存的数据传送，因为CPU速度非常快，做这件事，比用DMA控制还要快，但要在适配卡和内存之间传送数据，仍然是非DMA莫属。要从适配卡到内存传送数据，DMA同时触发从适配卡读数据总线(即I/O读操作)和向内存写数据的总线。激活I/O读操作就是让适配卡把一个数据单位(通常是一个字节或一个字)放到PC数据总线上，因为此时内存写总线也被激活，数据就被同时从PC总线上拷贝到内存中。</p>
<p>直接内存访问（DMA）方式是一种完全由硬件执行I/O交换的工作方式。DMA控制器从CPU完全接管对总线的控制。数据交换不经过CPU，而直接在内存和I/O设备之间进行。DMA控制器采用以下三种方式：</p>
<pre><code>①停止CPU访问内存：当外设要求传送一批数据时，由DMA控制器发一个信号给CPU。DMA控制器获得总线控制权后，开始进行数据传送。一批数据传送完毕后，DMA控制器通知CPU可以使用内存，并把总线控制权交还给CPU。

②周期挪用：当I/O设备没有 DMA请求时，CPU按程序要求访问内存：一旦 I/O设备有DMA请求，则I/O设备挪用一个或几个周期。

③DMA与CPU交替访内：一个CPU周期可分为2个周期，一个专供DMA控制器访内，另一个专供CPU访内。不需要总线使用权的申请、建立和归还过程。
</code></pre><p>来源：<a href="https://blog.csdn.net/dadalan/article/details/2802979" target="_blank" rel="external">https://blog.csdn.net/dadalan/article/details/2802979</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/05/05/java-nio2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/java-nio2/" itemprop="url">
                  Java NIO原理分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-05 19:46:17 / 修改时间：20:11:20" itemprop="dateCreated datePublished" datetime="2018-05-05T19:46:17+08:00">2018-05-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里主要围绕着Java NIO展开，从Java NIO的基本使用，到介绍Linux下NIO API，再到Java Selector其底层的实现原理。</p>
<ul>
<li>Java NIO基本使用</li>
<li>Linux下的NIO系统调用介绍</li>
<li>Selector原理</li>
<li>Channel和Buffer之间的堆外内存</li>
</ul>
<h4 id="Java-NIO基本使用"><a href="#Java-NIO基本使用" class="headerlink" title="Java NIO基本使用"></a>Java NIO基本使用</h4><p>从JDK NIO文档里面可以发现，Java将其划分成了三大块：Channel，Buffer以及多路复用Selector。Channel的存在，封装了对什么实体的连接通道（如网络/文件）；Buffer封装了对数据的缓冲存储，最后对于Selector则是提供了一种可以以单线程非阻塞的方式，来处理多个连接。</p>
<h4 id="基本应用示例"><a href="#基本应用示例" class="headerlink" title="基本应用示例"></a>基本应用示例</h4><p>NIO的基本步骤是，创建Selector和ServerSocketChannel，然后注册channel的ACCEPT事件，调用select方法，等待连接的到来，以及接收连接后将其注册到Selector中。下面的为Echo Server的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel socketChannel = ServerSocketChannel.open();</span><br><span class="line">        socketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ready = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (ready == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel accept = channel.accept();</span><br><span class="line">                    <span class="keyword">if</span> (accept == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    accept.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    accept.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 读事件</span></span><br><span class="line">                    deal((SocketChannel) key.channel(), key);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="comment">// 写事件</span></span><br><span class="line">                    resp((SocketChannel) key.channel(), key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注：处理完成后要从中移除掉</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selector.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deal</span><span class="params">(SocketChannel channel, SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        ByteBuffer responseBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            responseBuffer.put(buffer);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"socket close"</span>);</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        key.attach(responseBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resp</span><span class="params">(SocketChannel channel, SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">            key.attach(<span class="keyword">null</span>);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Linux下的NIO系统调用介绍"><a href="#Linux下的NIO系统调用介绍" class="headerlink" title="Linux下的NIO系统调用介绍"></a>Linux下的NIO系统调用介绍</h4><p>在Linux环境下，提供了几种方式可以实现NIO，如epoll，poll，select等。对于select/poll，每次调用，都是从外部传入FD和监听事件，这就导致每次调用的时候，都需要将这些数据从用户态复制到内核态，就导致了每次调用代价比较大，而且每次从select/poll返回回来，都是全量的数据，需要自行去遍历检查哪些是READY的。对于epoll，则为增量式的，系统内部维护了所需要的FD和监听事件，要注册的时候，调用epoll_ctl即可，而每次调用，不再需要传入了，返回的时候，只返回READY的监听事件和FD。下面作个简单的伪代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建server socket</span></span><br><span class="line"><span class="comment">// 2. 绑定地址</span></span><br><span class="line"><span class="comment">// 3. 监听端口</span></span><br><span class="line"><span class="comment">// 4. 创建epoll</span></span><br><span class="line"><span class="keyword">int</span> epollFd = epoll_create(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 5. 注册监听事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLRDHUP | EPOLLET;</span><br><span class="line">event.data.fd = serverFd;</span><br><span class="line">epoll_ctl(epollFd, EPOLL_CTL_ADD, serverFd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    readyNums = epoll_wait( epollFd, events, <span class="number">1024</span>, <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( readyNums &lt; <span class="number">0</span> )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"epoll_wait error\n"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;  readyNums; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> ( events[i].data.fd == serverFd )</span><br><span class="line">         &#123;</span><br><span class="line">             clientFd = accept( serverFd, <span class="literal">NULL</span>, <span class="literal">NULL</span> );</span><br><span class="line">             <span class="comment">// 注册监听事件</span></span><br><span class="line">             ...</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( events[i].events &amp; EPOLLIN )</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// 处理读事件</span></span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( events[i].events &amp; EPOLLRDHUP )</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// 关闭连接事件</span></span><br><span class="line">            close( events[i].data.fd );</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Selector原理"><a href="#Selector原理" class="headerlink" title="Selector原理"></a>Selector原理</h4><h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p>从Java顶层使用者角度来看，channel通过注册，返回SelectionKey，而Selector.select方法，也是通过返回SelectionKey来使用。那么这里为什么会需要这个类呢？这个类有什么作用？无论是任何语言，其实都脱离不了系统底层的支持，通过上述Linux下的基本应用，可以知道，通过系统调用，向其传递和返回的都是FD以及事件这些参数，那么站在设计角度来看，就需要有一个映射关系，使得可以关联起来，这里有Channel封装的是通过，如果将READY事件这些参数放在里面，不太合适，这个时候，SelectionKey出现了，在SelectionKey内部，保存Channel的引用以及一些事件信息，然后Selector通过FD找到SelectionKey来进行关联。在底层EP里面，就有一个属性：Map<integer,selectionkeyimpl> fdToKey。</integer,selectionkeyimpl></p>
<h4 id="EPollSelectorImpl"><a href="#EPollSelectorImpl" class="headerlink" title="EPollSelectorImpl"></a>EPollSelectorImpl</h4><p>在Linux 2.6+版本，Java NIO采用的epoll（即EPollSelectorImpl类），对于2.4.x的，则使用poll（即PollSelectorImpl类）,这里以epoll为例。</p>
<h4 id="select方法"><a href="#select方法" class="headerlink" title="select方法"></a>select方法</h4><p>顶层Selector，通过调用select方法，最终会调用到EPollSelectorImpl.doSelect方法，通过该方法，可以看到，其首先会处理一些不再注册的事件，调用pollWrapper.poll(timeout);，然后再进行一次清理，最后，可以看到需要处理映射关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">    throws IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    <span class="comment">// 处理一些不再注册的事件</span></span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        begin();</span><br><span class="line">        pollWrapper.poll(timeout);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再进行一次清理</span></span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = updateSelectedKeys();</span><br><span class="line">    <span class="keyword">if</span> (pollWrapper.interrupted()) &#123;</span><br><span class="line">        <span class="comment">// Clear the wakeup pipe</span></span><br><span class="line">        pollWrapper.putEventOps(pollWrapper.interruptedIndex(), <span class="number">0</span>);</span><br><span class="line">        synchronized (interruptLock) &#123;</span><br><span class="line">            pollWrapper.clearInterrupted();</span><br><span class="line">            IOUtil.drain(fd0);</span><br><span class="line">            interruptTriggered = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">updateSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> entries = pollWrapper.updated;</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;entries; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取FD</span></span><br><span class="line">        <span class="keyword">int</span> nextFD = pollWrapper.getDescriptor(i);</span><br><span class="line">        <span class="comment">// 根据FD找到对应的SelectionKey</span></span><br><span class="line">        SelectionKeyImpl ski = fdToKey.get(Integer.valueOf(nextFD));</span><br><span class="line">        <span class="comment">// ski is null in the case of an interrupt</span></span><br><span class="line">        <span class="keyword">if</span> (ski != null) &#123;</span><br><span class="line">            <span class="comment">// 找到该FD的READY事件</span></span><br><span class="line">            <span class="keyword">int</span> rOps = pollWrapper.getEventOps(i);</span><br><span class="line">            <span class="keyword">if</span> (selectedKeys.contains(ski)) &#123;</span><br><span class="line">                <span class="comment">// 将底层的事件转换为Java封装的事件,SelectionKey.OP_READ等</span></span><br><span class="line">                <span class="keyword">if</span> (ski.channel.translateAndSetReadyOps(rOps, ski)) &#123;</span><br><span class="line">                    numKeysUpdated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有在原有的SelectedKey里面，说明是在等待过程中加入的</span></span><br><span class="line">                ski.channel.translateAndSetReadyOps(rOps, ski);</span><br><span class="line">                <span class="keyword">if</span> ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要更新selectedKeys集合</span></span><br><span class="line">                    selectedKeys.add(ski);</span><br><span class="line">                    numKeysUpdated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回Ready的Channel个数</span></span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EPollArrayWrapper"><a href="#EPollArrayWrapper" class="headerlink" title="EPollArrayWrapper"></a>EPollArrayWrapper</h4><p>EpollArrayWrapper封装了底层的调用，里面包含几个native方法，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">epollCreate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">epollCtl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> opcode, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">epollWait</span><span class="params">(<span class="keyword">long</span> pollAddress, <span class="keyword">int</span> numfds, <span class="keyword">long</span> timeout, <span class="keyword">int</span> epfd)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p>
<p>在openjdk的native目录（native/sun/nio/ch）里面可以找到对应的实现EPollArrayWrapper.c。<br>（这里顺带提一下，要实现native方法，可以在类里的方法加上native关键字，然后编译成class文件，再转换输出.h，c/c++底层实现该头文件的方法，编译成so库，放到对应目录即可）<br>在初始化文件方法里面，可以看到，是通过动态解析加载进来的，最终调用的epoll_create等方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_sun_nio_ch_EPollArrayWrapper_init(JNIEnv *env, jclass <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">    epoll_create_func = (<span class="keyword">epoll_create_t</span>) dlsym(RTLD_DEFAULT, <span class="string">"epoll_create"</span>);</span><br><span class="line">    epoll_ctl_func    = (<span class="keyword">epoll_ctl_t</span>)    dlsym(RTLD_DEFAULT, <span class="string">"epoll_ctl"</span>);</span><br><span class="line">    epoll_wait_func   = (<span class="keyword">epoll_wait_t</span>)   dlsym(RTLD_DEFAULT, <span class="string">"epoll_wait"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((epoll_create_func == <span class="literal">NULL</span>) || (epoll_ctl_func == <span class="literal">NULL</span>) ||</span><br><span class="line">        (epoll_wait_func == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        JNU_ThrowInternalError(env, <span class="string">"unable to get address of epoll functions, pre-2.6 kernel?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Channel和Buffer之间的堆外内存"><a href="#Channel和Buffer之间的堆外内存" class="headerlink" title="Channel和Buffer之间的堆外内存"></a>Channel和Buffer之间的堆外内存</h4><p>经常会听见别人说，堆外内存容易泄漏，以及Netty框架里面采用了堆外内存，减少拷贝提高性能。那么这里面的堆外内存指的是什么?之前怀着一个好奇心，通过read方法，最后追踪到SocketChannelImpl里面read方法，里面调用了IOUtil的read方法。里面会首先判断传入的Buffer是不是DirectBuffer，如果不是（则是HeapByteBuffer），则会创建一个临时的DirectBuffer，然后再将其复制到堆内。IOUtil.read方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="keyword">long</span> var2, NativeDispatcher var4, Object var5)</span> throws IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(var1.isReadOnly()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Read-only buffer"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(var1 instanceof DirectBuffer) &#123;</span><br><span class="line">        <span class="comment">// 为堆外内存，则直接读取</span></span><br><span class="line">        <span class="keyword">return</span> readIntoNativeBuffer(var0, var1, var2, var4, var5);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 为堆内内存，先获取临时堆外内存</span></span><br><span class="line">        ByteBuffer var6 = Util.getTemporaryDirectBuffer(var1.remaining());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> var8;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取到堆外内存</span></span><br><span class="line">            <span class="keyword">int</span> var7 = readIntoNativeBuffer(var0, var6, var2, var4, var5);</span><br><span class="line">            var6.flip();</span><br><span class="line">            <span class="keyword">if</span>(var7 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 复制到堆内</span></span><br><span class="line">                var1.put(var6);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var8 = var7;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="comment">// 释放临时堆外内存</span></span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var6);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一个问题就是，为什么会需要DirectBuffer以及堆外内存？通过对DirectByteBuffer的创建来分析，可以知道，通过unsafe.allocateMemory(size);来分配内存的，而对于该方法来说，可以说是直接调用malloc返回，这一块内存是不受GC管理的，也就是所说的：堆外内存容易泄漏。但是对于使用DirectByteBuffer来说，会创建一个Deallocator，注册到Cleaner里面，当对象被回收的时候，则会被直接，从而释放掉内存，减少内存泄漏。要用堆外内存，从上面的创建来看，堆外内存创建后，以long型地址保存的，而堆内内存会受到GC影响，对象会被移动，如果采用堆内内存，进行系统调用的时候，那么GC就需要停止，否则就会有问题，基于这一点，采用了堆外内存。</p>
<p>注：堆外内存的创建（unsafe.cpp）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅仅作了对齐以及将长度放在数组前方就返回了</span></span><br><span class="line">UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_AllocateMemory"</span>);</span><br><span class="line">  <span class="keyword">size_t</span> sz = (<span class="keyword">size_t</span>)size;</span><br><span class="line">  <span class="keyword">if</span> (sz != (julong)size || size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sz = round_to(sz, HeapWordSize);</span><br><span class="line">  <span class="keyword">void</span>* x = os::<span class="built_in">malloc</span>(sz);</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_OutOfMemoryError());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);</span></span><br><span class="line">  <span class="keyword">return</span> addr_to_java(x);</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure></p>
<p>来源：<a href="https://www.linuxidc.com/Linux/2017-06/145195.htm" target="_blank" rel="external">https://www.linuxidc.com/Linux/2017-06/145195.htm</a></p>
<h4 id="gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt"><a href="#gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt-gt" class="headerlink" title="&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"></a>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</h4><h4 id="Java-NIO-由以下几个核心部分组成："><a href="#Java-NIO-由以下几个核心部分组成：" class="headerlink" title="Java NIO 由以下几个核心部分组成："></a>Java NIO 由以下几个核心部分组成：</h4><ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。因此，在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。</p>
<h4 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h4><p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。这里有个图示：</p>
<p><img src="/2018/05/05/java-nio2/1.png" alt=""></p>
<p>Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p>
<p>与这些类一起的有一些有趣的接口，但为简单起见，我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。</p>
<p>以下是Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。</p>
<p>Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件， 我也不打算在概述中说明。</p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。</p>
<p>这是在一个单线程中使用一个Selector处理3个Channel的图示：</p>
<p><img src="/2018/05/05/java-nio2/2.png" alt=""></p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p>
<p>来源：<a href="http://ifeve.com/overview/" target="_blank" rel="external">http://ifeve.com/overview/</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/05/05/java-nio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/java-nio/" itemprop="url">
                  JAVA IO 以及 NIO 理解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-05 19:19:10 / 修改时间：19:45:09" itemprop="dateCreated datePublished" datetime="2018-05-05T19:19:10+08:00">2018-05-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于<a href="http://netty.io/" target="_blank" rel="external">Netty</a>，了解了一些异步IO的知识，JAVA里面NIO就是原来的IO的一个补充，本文主要记录下在JAVA中IO的底层实现原理，以及对<a href="http://www.ibm.com/developerworks/library/j-zerocopy/" target="_blank" rel="external">Zerocopy</a>技术介绍。</p>
<p>IO，其实意味着：数据不停地搬入搬出缓冲区而已（使用了缓冲区）。比如，用户程序发起读操作，导致“ syscall read ”系统调用，就会把数据搬入到 一个buffer中；用户发起写操作，导致 “syscall write ”系统调用，将会把一个 buffer 中的数据 搬出去(发送到网络中 or 写入到磁盘文件)</p>
<p>上面的过程看似简单，但是底层操作系统具体如何实现以及实现的细节就非常复杂了。正是因为实现方式不同，有针对普通情况下的文件传输(暂且称普通IO吧)，也有针对大文件传输或者批量大数据传输的实现方式，比如zerocopy技术。</p>
<p>先来看一张普通的IO处理的流程图：</p>
<p><img src="/2018/05/05/java-nio/1.png" alt=""></p>
<h4 id="整个IO过程的流程如下："><a href="#整个IO过程的流程如下：" class="headerlink" title="整个IO过程的流程如下："></a>整个IO过程的流程如下：</h4><p>1）程序员写代码创建一个缓冲区（这个缓冲区是用户缓冲区）：哈哈。然后在一个while循环里面调用read()方法读数据(触发”syscall read”系统调用)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] b = <span class="keyword">new</span> byte[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((read = inputStream.read(b))&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        total = total + read;</span><br><span class="line">            <span class="comment">// other code....</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>2)当执行到read()方法时，其实底层是发生了很多操作的：</p>
<p>①内核给磁盘控制器发命令说：我要读磁盘上的某某块磁盘块上的数据。–kernel issuing a command to the disk controller hardware to fetch the data from disk.</p>
<p>②在DMA的控制下，把磁盘上的数据读入到内核缓冲区。–The disk controller writes the data directly into a kernel memory buffer by DMA</p>
<p>③内核把数据从内核缓冲区复制到用户缓冲区。–kernel copies the data from the temporary buffer in kernel space</p>
<p>这里的用户缓冲区应该就是我们写的代码中 new 的 byte[] 数组。</p>
<h4 id="从上面的步骤中可以分析出什么？"><a href="#从上面的步骤中可以分析出什么？" class="headerlink" title="从上面的步骤中可以分析出什么？"></a>从上面的步骤中可以分析出什么？</h4><p>ⓐ对于操作系统而言，JVM只是一个用户进程，处于用户态空间中。而处于用户态空间的进程是不能直接操作底层的硬件的。而IO操作就需要操作底层的硬件，比如磁盘。因此，IO操作必须得借助内核的帮助才能完成(中断，trap)，即：会有用户态到内核态的切换。</p>
<p>ⓑ我们写代码 new byte[] 数组时，一般是都是“随意” 创建一个“任意大小”的数组。比如，new byte[128]、new byte[1024]、new byte[4096]….</p>
<p>但是，对于磁盘块的读取而言，每次访问磁盘读数据时，并不是读任意大小的数据的，而是：每次读一个磁盘块或者若干个磁盘块(这是因为访问磁盘操作代价是很大的，而且我们也相信局部性原理) 因此，就需要有一个“中间缓冲区”–即内核缓冲区。先把数据从磁盘读到内核缓冲区中，然后再把数据从内核缓冲区搬到用户缓冲区。</p>
<p>这也是为什么我们总感觉到第一次read操作很慢，而后续的read操作却很快的原因吧。因为，对于后续的read操作而言，它所需要读的数据很可能已经在内核缓冲区了，此时只需将内核缓冲区中的数据拷贝到用户缓冲区即可，并未涉及到底层的读取磁盘操作，当然就快了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The kernel tries to cache and/or prefetch data, so the data being requested by the process may already be available in kernel space.</span><br><span class="line">If so, the data requested by the process is copied out. </span><br><span class="line">If the data isn't available, the process is suspended while the kernel goes about bringing the data into memory.</span><br></pre></td></tr></table></figure>
<p>如果数据不可用，process将会被挂起，并需要等待内核从磁盘上把数据取到内核缓冲区中。</p>
<p>那我们可能会说：DMA为什么不直接将磁盘上的数据读入到用户缓冲区呢？一方面是 ⓑ中提到的内核缓冲区作为一个中间缓冲区。用来“适配”用户缓冲区的“任意大小”和每次读磁盘块的固定大小。另一方面则是，用户缓冲区位于用户态空间，而DMA读取数据这种操作涉及到底层的硬件，硬件一般是不能直接访问用户态空间的（OS的原因吧）</p>
<p>综上，由于DMA不能直接访问用户空间(用户缓冲区)，普通IO操作需要将数据来回地在 用户缓冲区 和 内核缓冲区移动，这在一定程序上影响了IO的速度。那有没有相应的解决方案呢？</p>
<p>那就是直接内存映射IO，也即JAVA NIO中提到的内存映射文件，或者说 直接内存….总之，它们表达的意思都差不多。示例图如下：</p>
<p><img src="/2018/05/05/java-nio/2.png" alt=""></p>
<p>从上图可以看出：内核空间的 buffer 与 用户空间的 buffer 都映射到同一块 物理内存区域。</p>
<p>它的主要特点如下：</p>
<p>①对文件的操作不需要再发read 或者 write 系统调用了—The user process sees the file data asmemory, so there is no need to issue read() or write() system calls.</p>
<p>②当用户进程访问“内存映射文件”地址时，自动产生缺页错误，然后由底层的OS负责将磁盘上的数据送到内存。关于页式存储管理，可参考：<a href="http://www.cnblogs.com/hapjin/p/5689049.html" target="_blank" rel="external">内存分配与内存管理的一些理解</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">As the user process touches the mapped memory space, page faults will be generated automatically to bring in the file data from disk. </span><br><span class="line">If the user modifies the mapped memory space, the affected page is automatically marked as dirty and will be subsequently </span><br><span class="line">flushed to disk to update the file.</span><br></pre></td></tr></table></figure>
<p>这就是是JAVA NIO中提到的内存映射缓冲区（Memory-Mapped-Buffer）它类似于JAVA NIO中的直接缓冲区(Directed Buffer)。MemoryMappedBuffer可以通过java.nio.channels.FileChannel.java(通道)的 map方法创建。</p>
<p>使用内存映射缓冲区来操作文件，它比普通的IO操作读文件要快得多。甚至比使用文件通道(FileChannel)操作文件 还要快。因为，使用内存映射缓冲区操作文件时，没有显示的系统调用(read,write)，而且OS还会自动缓存一些文件页(memory page)</p>
<h4 id="zerocopy技术介绍"><a href="#zerocopy技术介绍" class="headerlink" title="zerocopy技术介绍"></a>zerocopy技术介绍</h4><p>看完了上面的IO操作的底层实现过程，再来了解zerocopy技术就很easy了。IBM有一篇名为《Efficient data transfer through zero copy》的论文对zerocopy做了完整的介绍。感觉非常好，下面就基于这篇文来记录下自己的一些理解。</p>
<p>zerocopy技术的目标就是提高IO密集型JAVA应用程序的性能。在本文的前面部分介绍了：IO操作需要数据频繁地在内核缓冲区和用户缓冲区之间拷贝，而zerocopy技术可以减少这种拷贝的次数，同时也降低了上下文切换(用户态与内核态之间的切换)的次数。</p>
<p>比如，大多数WEB应用程序执行的一项操作就是：接受用户请求—&gt;从本地磁盘读数据—&gt;数据进入内核缓冲区—&gt;用户缓冲区—&gt;内核缓冲区—&gt;用户缓冲区—&gt;socket发送</p>
<p>数据每次在内核缓冲区与用户缓冲区之间的拷贝会消耗CPU以及内存的带宽。而zerocopy有效减少了这种拷贝次数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Each time data traverses the user-kernel boundary, it must be copied, which consumes CPU cycles and memory bandwidth.</span><br><span class="line">Fortunately, you can eliminate these copies through a technique called—appropriately enough —zero copy</span><br></pre></td></tr></table></figure>
<h4 id="那它是怎么做到的呢？"><a href="#那它是怎么做到的呢？" class="headerlink" title="那它是怎么做到的呢？"></a>那它是怎么做到的呢？</h4><p>我们知道，JVM(JAVA虚拟机)为JAVA语言提供了跨平台的一致性，屏蔽了底层操作系统的具体实现细节，因此，JAVA语言也很难直接使用底层操作系统提供的一些“奇技淫巧”。</p>
<p>而要实现zerocopy，首先得有操作系统的支持。其次，JDK类库也要提供相应的接口支持。幸运的是，自JDK1.4以来，JDK提供了对NIO的支持，通过java.nio.channels.FileChannel类的transferTo()方法可以直接将字节传送到可写的通道中(Writable Channel)，并不需要将字节送入用户程序空间(用户缓冲区)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can use the transferTo()method to transfer bytes directly from the channel on which it is invoked to </span><br><span class="line">another writable byte channel, without requiring data to flow through the application</span><br></pre></td></tr></table></figure></p>
<p>下面就来详细分析一下经典的web服务器(比如文件服务器)干的活：从磁盘中中读文件，并把文件通过网络(socket)发送给Client。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File.read(fileDesc, buf, len);</span><br><span class="line">Socket.send(socket, buf, len);</span><br></pre></td></tr></table></figure>
<p>从代码上看，就是两步操作。第一步：将文件读入buf；第二步：将 buf 中的数据通过socket发送出去。但是，这两步操作需要四次上下文切换(用户态与内核态之间的切换) 和 四次拷贝操作才能完成。</p>
<p><img src="/2018/05/05/java-nio/3.png" alt=""></p>
<p>①第一次上下文切换发生在 read()方法执行，表示服务器要去磁盘上读文件了，这会导致一个 sys_read()的系统调用。此时由用户态切换到内核态，完成的动作是：DMA把磁盘上的数据读入到内核缓冲区中（这也是第一次拷贝）。</p>
<p>②第二次上下文切换发生在read()方法的返回(这也说明read()是一个阻塞调用)，表示数据已经成功从磁盘上读到内核缓冲区了。此时，由内核态返回到用户态，完成的动作是：将内核缓冲区中的数据拷贝到用户缓冲区（这是第二次拷贝）。</p>
<p>③第三次上下文切换发生在 send()方法执行，表示服务器准备把数据发送出去了。此时，由用户态切换到内核态，完成的动作是：将用户缓冲区中的数据拷贝到内核缓冲区(这是第三次拷贝)</p>
<p>④第四次上下文切换发生在 send()方法的返回【这里的send()方法可以异步返回，所谓异步返回就是：线程执行了send()之后立即从send()返回，剩下的数据拷贝及发送就交给底层操作系统实现了】。此时，由内核态返回到用户态，完成的动作是：将内核缓冲区中的数据送到 protocol engine.（这是第四次拷贝）</p>
<p>这里对 protocol engine不是太了解，但是从上面的示例图来看：它是NIC(NetWork Interface Card) buffer。网卡的buffer???</p>
<p>下面这段话，非常值得一读：这里再一次提到了为什么需要内核缓冲区。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Use of the intermediate kernel buffer (rather than a direct transfer of the data</span><br><span class="line">into the user buffer)might seem inefficient. But intermediate kernel buffers were </span><br><span class="line">introduced into the process to improve performance. Using the intermediate </span><br><span class="line">buffer on the read side allows the kernel buffer to act as a "readahead cache" </span><br><span class="line">when the application hasn't asked for as much data as the kernel buffer holds.</span><br><span class="line">This significantly improves performance when the requested data amount is less</span><br><span class="line">than the kernel buffer size. The intermediate buffer on the write side allows the write to complete asynchronously.</span><br></pre></td></tr></table></figure>
<p>一个核心观点就是：内核缓冲区提高了性能。咦？是不是很奇怪？因为前面一直说正是因为引入了内核缓冲区(中间缓冲区)，使得数据来回地拷贝，降低了效率。</p>
<p>那先来看看，它为什么说内核缓冲区提高了性能。</p>
<p>对于读操作而言，内核缓冲区就相当于一个“readahead cache”，当用户程序一次只需要读一小部分数据时，首先操作系统从磁盘上读一大块数据到内核缓冲区，用户程序只取走了一小部分( 我可以只 new 了一个 128B的byte数组啊! new byte[128])。当用户程序下一次再读数据，就可以直接从内核缓冲区中取了，操作系统就不需要再次访问磁盘啦！因为用户要读的数据已经在内核缓冲区啦！这也是前面提到的：为什么后续的读操作(read()方法调用)要明显地比第一次快的原因。从这个角度而言，内核缓冲区确实提高了读操作的性能。</p>
<p>再来看写操作：可以做到 “异步写”（write asynchronously）。也即：wirte(dest[]) 时，用户程序告诉操作系统，把dest[]数组中的内容写到XX文件中去，于是write方法就返回了。操作系统则在后台默默地把用户缓冲区中的内容(dest[])拷贝到内核缓冲区，再把内核缓冲区中的数据写入磁盘。那么，只要内核缓冲区未满，用户的write操作就可以很快地返回。这应该就是异步刷盘策略吧。</p>
<p>(其实，到这里。以前一个纠结的问题就是同步IO，异步IO，阻塞IO，非阻塞IO之间的区别已经没有太大的意义了。这些概念，只是针对的看问题的角度不一样而已。阻塞、非阻塞是针对线程自身而言；同步、异步是针对线程以及影响它的外部事件而言….)【更加完美、精辟的解释可以参考这个系列的文章：<a href="http://blog.csdn.net/yinwenjie/article/details/48472237" target="_blank" rel="external">系统间通信（3）——IO通信模型和JAVA实践 上篇</a></p>
<p>既然，你把内核缓冲区说得这么强大和完美，那还要 zerocopy干嘛啊？？？</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unfortunately, this approach itself can become a performance bottleneck if the size of the data requested </span><br><span class="line">is considerably larger than the kernel buffer size. The data gets copied multiple times among the disk, kernel buffer, </span><br><span class="line">and user buffer before it is finally delivered to the application.</span><br><span class="line">Zero copy improves performance by eliminating these redundant data copies.</span><br></pre></td></tr></table></figure>
<p>终于轮到zerocopy粉墨登场了。当需要传输的数据远远大于内核缓冲区的大小时，内核缓冲区就会成为瓶颈。这也是为什么zerocopy技术合适大文件传输的原因。内核缓冲区为啥成为了瓶颈？—我想，很大的一个原因是它已经起不到“缓冲”的功能了，毕竟传输的数据量太大了。</p>
<h5 id="下面来看看zerocopy技术是如何来处理文件传输的。"><a href="#下面来看看zerocopy技术是如何来处理文件传输的。" class="headerlink" title="下面来看看zerocopy技术是如何来处理文件传输的。"></a>下面来看看zerocopy技术是如何来处理文件传输的。</h5><p><img src="/2018/05/05/java-nio/4.png" alt=""></p>
<p>当 transferTo()方法 被调用时，由用户态切换到内核态。完成的动作是：DMA将数据从磁盘读入 Read buffer中(第一次数据拷贝)。然后，还是在内核空间中，将数据从Read buffer 拷贝到 Socket buffer(第二次数据拷贝)，最终再将数据从 Socket buffer 拷贝到 NIC buffer(第三次数据拷贝)。然后，再从内核态返回到用户态。</p>
<p>上面整个过程就只涉及到了：三次数据拷贝和二次上下文切换。感觉也才减少了一次数据拷贝嘛。但这里已经不涉及用户空间的缓冲区了。</p>
<p>三次数据拷贝中，也只有一次拷贝需要到CPU的干预。（第2次拷贝），而前面的传统数据拷贝需要四次且有三次拷贝需要CPU的干预。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is an improvement: we've reduced the number of context switches from four to two and reduced the number of data copies</span><br><span class="line">from four to three (only one of which involves the CPU)</span><br></pre></td></tr></table></figure>
<p>如果说zerocopy技术只能完成到这步，那也就 just so so 了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">We can further reduce the data duplication done by the kernel if the underlying network interface card supports </span><br><span class="line">gather operations. In Linux kernels 2.4 and later, the socket buffer descriptor was modified to accommodate this requirement. </span><br><span class="line">This approach not only reduces multiple context switches but also eliminates the duplicated data copies that </span><br><span class="line">require CPU involvement.</span><br></pre></td></tr></table></figure>
<p>也就是说，如果底层的网络硬件以及操作系统支持，还可以进一步减少数据拷贝次数 以及 CPU干预次数。</p>
<p><img src="/2018/05/05/java-nio/5.png" alt=""></p>
<p>从上图看出：这里一共只有两次拷贝 和 两次上下文切换。而且这两次拷贝都是DMA copy，并不需要CPU干预(严谨一点的话就是不完全需要吧.)。</p>
<p>整个过程如下：</p>
<p>用户程序执行 transferTo()方法，导致一次系统调用，从用户态切换到内核态。完成的动作是：DMA将数据从磁盘中拷贝到Read buffer</p>
<p>用一个描述符标记此次待传输数据的地址以及长度，DMA直接把数据从Read buffer 传输到 NIC buffer。数据拷贝过程都不用CPU干预了。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>这篇文章从IO底层实现原理开始讲解，分析了IO底层实现细节的一些优缺点，以及为什么引入zerocopy技术和zerocopy技术的实现原理。个人的学习记录，转载请注明出处。</p>
<p>参考文献：</p>
<p>1）《JAVA NIO》O’Reilly出版社</p>
<p>2）《Efficient data transfer through zero copy》IBM出版</p>
<p>3）<a href="http://www.linuxjournal.com/article/6345" target="_blank" rel="external">Zero Copy I: User-Mode Perspective</a></p>
<p>来源：<a href="https://www.cnblogs.com/hapjin/p/5736188.html" target="_blank" rel="external">https://www.cnblogs.com/hapjin/p/5736188.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/05/05/netty-bytebuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/netty-bytebuf/" itemprop="url">
                  Netty核心类--缓冲区ByteBuf
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-05 19:17:58 / 修改时间：20:27:55" itemprop="dateCreated datePublished" datetime="2018-05-05T19:17:58+08:00">2018-05-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文主要包括以下内容：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）ByteBuf的三种类型：heapBuffer(堆缓冲区)、directBuffer(直接缓冲区)以及Composite Buffer(复合缓冲区)。</span><br><span class="line"></span><br><span class="line">2）ByteBuf的工作原理。</span><br><span class="line"></span><br><span class="line">3）ByteBuf与JDK中ByteBuffer的区别以及对比</span><br><span class="line"></span><br><span class="line">4）ByteBuf的引用计数器实现类AbstractReferenceCountedByteBuf分析。</span><br><span class="line"></span><br><span class="line">5）UnpooledHeapByteBuf 基于堆内存缓冲器的源码分析</span><br><span class="line"></span><br><span class="line">6）PooledDirectByteBuf 源码分析</span><br></pre></td></tr></table></figure></p>
<h4 id="1-netty中ByteBuf的优势"><a href="#1-netty中ByteBuf的优势" class="headerlink" title="1. netty中ByteBuf的优势"></a>1. netty中ByteBuf的优势</h4><p>缓冲区是不同的通道之间传递数据的中介，JDK中的ByteBuffer操作复杂，而且没有经过优化，所以在netty中实现了一个更加强大的缓冲区 ByteBuf 用于表示字节序列。ByteBuf在netty中是通过Channel传输数据的，新的设计解决了JDK中ByteBuffer中的一些问题。</p>
<p>netty中ByteBuf的缓冲区的优势： </p>
<p>（1）可以自定义缓冲区的类型；</p>
<p>（2）通过内置的复合缓冲类型实现零拷贝；</p>
<p>（3）不需要调用flip()函数切换读/写模式</p>
<p>（4）读取和写入的索引分开了，不像JDK中使用一个索引</p>
<p>（5）引用计数（referenceCounting的实现原理？）</p>
<p>（6） Pooling池</p>
<h4 id="2-netty中的ByteBuf的类型："><a href="#2-netty中的ByteBuf的类型：" class="headerlink" title="2.netty中的ByteBuf的类型："></a>2.netty中的ByteBuf的类型：</h4><p>JDK中的Buffer的类型 有heapBuffer和directBuffer两种类型，但是在netty中除了heap和direct类型外，还有composite Buffer(复合缓冲区类型)。</p>
<h4 id="1-Heap-Buffer-堆缓冲区"><a href="#1-Heap-Buffer-堆缓冲区" class="headerlink" title="(1)Heap Buffer 堆缓冲区"></a>(1)Heap Buffer 堆缓冲区</h4><p>这是最常用的类型，ByteBuf将数据存储在JVM的堆空间，通过将数据存储在数组中实现的。</p>
<p>1）堆缓冲的优点是：由于数据存储在JVM的堆中可以快速创建和快速释放，并且提供了数组的直接快速访问的方法。</p>
<p>2）堆缓冲缺点是：每次读写数据都要先将数据拷贝到直接缓冲区再进行传递。</p>
<h4 id="2-Direct-Buffer-直接缓冲区"><a href="#2-Direct-Buffer-直接缓冲区" class="headerlink" title="(2)Direct Buffer 直接缓冲区"></a>(2)Direct Buffer 直接缓冲区</h4><p>Direct Buffer在堆之外直接分配内存，直接缓冲区不会占用堆的容量。</p>
<p>（1）Direct Buffer的优点是：在使用Socket传递数据时性能很好，由于数据直接在内存中，不存在从JVM拷贝数据到直接缓冲区的过程，性能好。</p>
<p>（2）缺点是：因为Direct Buffer是直接在内存中，所以分配内存空间和释放内存比堆缓冲区更复杂和慢。</p>
<p>虽然netty的Direct Buffer有这个缺点，但是netty通过内存池来解决这个问题。直接缓冲池不支持数组访问数据，但可以通过间接的方式访问数据数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);   </span><br><span class="line"><span class="keyword">if</span>(!directBuf.hasArray())&#123;   </span><br><span class="line">    <span class="keyword">int</span> len = directBuf.readableBytes();   </span><br><span class="line">    <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[len];   </span><br><span class="line">    directBuf.getBytes(<span class="number">0</span>, arr);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是上面的操作太过复杂，所以在使用时，建议一般是用heap buffer。 </p>
<p>不过对于一些IO通信线程中读写缓冲时建议使用DirectByteBuffer，因为这涉及到大量的IO数据读写。对于后端的业务消息的编解码模块使用HeapByteBuffer。</p>
<h4 id="3-Composite-Buffer-复合缓冲区"><a href="#3-Composite-Buffer-复合缓冲区" class="headerlink" title="(3)Composite Buffer 复合缓冲区"></a>(3)Composite Buffer 复合缓冲区</h4><p>这个是netty特有的缓冲类型。复合缓冲区就类似于一个ByteBuf的组合视图，在这个视图里面我们可以创建不同的ByteBuf(可以是不同类型的)。 这样，复合缓冲区就类似于一个列表，我们可以动态的往里面添加和删除其中的ByteBuf，JDK里面的ByteBuffer就没有这样的功能。</p>
<p>Netty提供了Composite ByteBuf来处理复合缓冲区。例如：一条消息由Header和Body组成，将header和body组装成一条消息发送出去。下图显示了Composite ByteBuf组成header和body： </p>
<p><img src="/2018/05/05/netty-bytebuf/1.jpeg" alt=""></p>
<p>如果使用的是JDK的ByteBuffer就不能简单的实现，只能通过创建数组或则新的ByteBuffer，再将里面的内容复制到新的ByteBuffer中，下面给出了一个CompositeByteBuf的使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合缓冲区</span></span><br><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();   </span><br><span class="line"><span class="comment">//堆缓冲区</span></span><br><span class="line">ByteBuf heapBuf = Unpooled.buffer(<span class="number">8</span>);   </span><br><span class="line"><span class="comment">//直接缓冲区</span></span><br><span class="line">ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);   </span><br><span class="line"><span class="comment">//添加ByteBuf到CompositeByteBuf   </span></span><br><span class="line">compBuf.addComponents(heapBuf, directBuf);   </span><br><span class="line"><span class="comment">//删除第一个ByteBuf   </span></span><br><span class="line">compBuf.removeComponent(<span class="number">0</span>);   </span><br><span class="line">Iterator&lt;ByteBuf&gt; iter = compBuf.iterator();   </span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;   </span><br><span class="line">    System.out.println(iter.next().toString());   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组访问数据      </span></span><br><span class="line"><span class="keyword">if</span>(!compBuf.hasArray())&#123;   </span><br><span class="line">    <span class="keyword">int</span> len = compBuf.readableBytes();   </span><br><span class="line">    <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[len];   </span><br><span class="line">    compBuf.getBytes(<span class="number">0</span>, arr);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-ByteBuf是如何工作的："><a href="#3-ByteBuf是如何工作的：" class="headerlink" title="3.ByteBuf是如何工作的："></a>3.ByteBuf是如何工作的：</h4><p>ByteBuf是一个抽象类，内部全部是抽象的函数接口，AbstractByteBuf这个抽象类基本实现了ByteBuf，下面我们通过分析AbstractByteBuf里面的实现来分析ByteBuf的工作原理。</p>
<p>ByteBuf都是基于字节序列的，类似于一个字节数组。在AbstractByteBuf里面定义了下面5个变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">int</span> readerIndex; <span class="comment">//读索引</span></span><br><span class="line"><span class="keyword">int</span> writerIndex; <span class="comment">//写索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;<span class="comment">//标记读索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;<span class="comment">//标记写索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;<span class="comment">//缓冲区的最大容量</span></span><br></pre></td></tr></table></figure></p>
<p>ByteBuf 与JDK中的 ByteBuffer 的最大区别之一就是： </p>
<p>（1）netty的ByteBuf采用了读/写索引分离，一个初始化的ByteBuf的readerIndex和writerIndex都处于0位置。 </p>
<p>（2）当读索引和写索引处于同一位置时，如果我们继续读取，就会抛出异常IndexOutOfBoundsException。 </p>
<p>（3）对于ByteBuf的任何读写操作都会分别单独的维护读索引和写索引。maxCapacity最大容量默认的限制就是Integer.MAX_VALUE。</p>
<h4 id="1-随机访问索引"><a href="#1-随机访问索引" class="headerlink" title="1.随机访问索引"></a>1.随机访问索引</h4><p>ByteBuf提供读/写索引，从0开始的索引，第一个字节索引是0，最后一个字节的索引是capacity-1，下面给出一个示例遍历ByteBuf的字节：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个16字节的buffer,这里默认是创建heap buffer</span></span><br><span class="line">    ByteBuf buf = Unpooled.buffer(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//写数据到buffer</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)&#123;</span><br><span class="line">        buf.writeByte(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buf.capacity(); i++)&#123;</span><br><span class="line">        System.out.print(buf.getByte(i)+<span class="string">", "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***output:</span></span><br><span class="line"><span class="comment">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>这里有一点需要注意的是：通过索引访问byte时不会改变真实的读索引和写索引，我们可以通过ByteBuf的readerIndex()或则writerIndex()函数来分别推进读索引和写索引。</p>
<p>下面分别看看writeByte()和readByte()的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ensureAccessible();<span class="comment">//检验是否可以写入</span></span><br><span class="line">    ensureWritable0(<span class="number">1</span>);</span><br><span class="line">    _setByte(writerIndex++, value);<span class="comment">//这里写索引自增了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkReadableBytes0(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = readerIndex;</span><br><span class="line">    <span class="keyword">byte</span> b = _getByte(i);</span><br><span class="line">    readerIndex = i + <span class="number">1</span>;<span class="comment">//这里读索引自增了</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="读写索引的分区"><a href="#读写索引的分区" class="headerlink" title="读写索引的分区"></a>读写索引的分区</h4><p>ByteBuf提供了两个索引指针变量来支持读写操作，读操作使用的是readerIndex()，写操作使用的是writerIndex()。这与JDK中的ByteBuffer有很大不同，ByteBuffer只有一个方法来设置索引，而且需要使用flip()方法来切换读写操作，这就很麻烦了。</p>
<p>ByteBuf一定满足的是：0&lt;=readerIndex&lt;=writerIndex&lt;=capacity<br>下图显示了一个ByteBuf中可以被划分为三个区域： </p>
<p><img src="/2018/05/05/netty-bytebuf/2.jpeg" alt=""></p>
<h4 id="Discardable-bytes-回收字节"><a href="#Discardable-bytes-回收字节" class="headerlink" title="Discardable bytes 回收字节"></a>Discardable bytes 回收字节</h4><p>对于已经读过的字节，我们需要回收，通过调用ByteBuf.discardReadBytes()来回收已经读取过的字节，discardReadBytes()将回收从索引0到readerIndex之间的字节。调用discardReadBytes()方法之后会变成如下图所示; </p>
<p><img src="/2018/05/05/netty-bytebuf/3.jpeg" alt=""></p>
<p>很明显discardReadBytes()函数很可能会导致内存的复制，它需要移动ByteBuf中可读字节到开始位置，所以该操作会导致时间开销。说白了也就是时间换空间。</p>
<h4 id="可读可写字节"><a href="#可读可写字节" class="headerlink" title="可读可写字节"></a>可读可写字节</h4><p>当我们读取字节的时候，一般要先判断buffer中是否有字节可读，这时候可以调用isReadable()函数来判断：源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writerIndex &gt; readerIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实也就是判断 读索引是否小于写索引 来判断是否还可以读取字节。在判断是否可写时也是判断写索引是否小于最大容量来判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> capacity() &gt; writerIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="清除缓冲区"><a href="#清除缓冲区" class="headerlink" title="清除缓冲区"></a>清除缓冲区</h4><p>清除ByteBuf来说，有两种形式，第一种是clear()函数：源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readerIndex = writerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显这种方式并没有真实的清除缓冲区中的数据，而只是把读/写索引值重新都置为0了，这与discardReadBytes()方法有很大的区别。</p>
<h4 id="标记Mark和重置reset"><a href="#标记Mark和重置reset" class="headerlink" title="标记Mark和重置reset"></a>标记Mark和重置reset</h4><p>从源码可知，每个ByteBuf有两个标注索引，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;<span class="comment">//标记读索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;<span class="comment">//标记写索引</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过重置方法返回上次标记的索引的位置。</p>
<h4 id="衍生的缓冲区"><a href="#衍生的缓冲区" class="headerlink" title="衍生的缓冲区"></a>衍生的缓冲区</h4><p>调用duplicate()、slice()、slice(int index, int length)等方法可以创建一个现有缓冲区的视图（现有缓冲区与原有缓冲区是指向相同内存）。衍生的缓冲区有独立的readerIndex和writerIndex和标记索引。如果需要现有的缓冲区的全新副本，可以使用copy()获得。</p>
<h4 id="4-创建ByteBuf的方法"><a href="#4-创建ByteBuf的方法" class="headerlink" title="4. 创建ByteBuf的方法"></a>4. 创建ByteBuf的方法</h4><p>前面我们也讲过了，ByteBuf主要有三种类型，heap、direct和composite类型，下面介绍创建这三种Buffer的方法：</p>
<p>（1）通过ByteBufAllocator这个接口来创建ByteBuf，这个接口可以创建上面的三种Buffer，一般都是通过channel的alloc()接口获取。</p>
<p>（2）通过Unpooled类里面的静态方法，创建Buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();           </span><br><span class="line">ByteBuf heapBuf = Unpooled.buffer(<span class="number">8</span>);            </span><br><span class="line">ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<p>还有一点就是，ByteBuf里面的数据都是保存在字节数组里面的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] array;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-ByteBuf与ByteBuffer的对比："><a href="#5-ByteBuf与ByteBuffer的对比：" class="headerlink" title="5. ByteBuf与ByteBuffer的对比："></a>5. ByteBuf与ByteBuffer的对比：</h4><p>先来说说ByteBuffer的缺点：</p>
<p>（1）下面是NIO中ByteBuffer存储字节的字节数组的定义，我们可以知道ByteBuffer的字节数组是被定义成final的，也就是长度固定。一旦分配完成就不能扩容和收缩，灵活性低，而且当待存储的对象字节很大可能出现数组越界，用户使用起来稍不小心就可能出现异常。如果要避免越界，在存储之前就要只要需求字节大小，如果buffer的空间不够就创建一个更大的新的ByteBuffer，再将之前的Buffer中数据复制过去，这样的效率是奇低的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;<span class="comment">// Non-null only for heap buffers</span></span><br></pre></td></tr></table></figure>
<p>（2）ByteBuffer只用了一个position指针来标识位置，读写模式切换时需要调用flip()函数和rewind()函数，使用起来需要非常小心，不然很容易出错误。</p>
<p>下面说说对应的ByteBuf的优点： </p>
<p>（1）ByteBuf是吸取ByteBuffer的缺点之后重新设计，存储字节的数组是动态的，最大是Integer.MAX_VALUE。这里的动态性存在write操作中，write时得知buffer不够时，会自动扩容。</p>
<p>（2） ByteBuf的读写索引分离，使用起来十分方便。此外ByteBuf还新增了很多方便实用的功能。</p>
<h4 id="6-ByteBuf的引用计数类AbstractReferenceCountedByteBuf分析"><a href="#6-ByteBuf的引用计数类AbstractReferenceCountedByteBuf分析" class="headerlink" title="6. ByteBuf的引用计数类AbstractReferenceCountedByteBuf分析"></a>6. ByteBuf的引用计数类AbstractReferenceCountedByteBuf分析</h4><p>看类名我们就可以知道，该类主要是对引用进行计数，有点类似于JVM中判断对象是否可回收的引用计数算法。这个类主要是根据ByteBuf的引用次数判断ByteBuf是否可被自动回收。下面来看看源码：</p>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; refCntUpdater;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态代码段初始化refCntUpdater</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; updater =</span><br><span class="line">            PlatformDependent.newAtomicIntegerFieldUpdater(AbstractReferenceCountedByteBuf.class, <span class="string">"refCnt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (updater == <span class="keyword">null</span>) &#123;</span><br><span class="line">        updater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, <span class="string">"refCnt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    refCntUpdater = updater;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> refCnt = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>首先我们能看到refCntUpdater这个变量，这是一个原子变量类AtomicIntegerFieldUpdater，她是一个静态变量，而且是在static代码段里面实例化的，这说明这个类是单例的。这个类的主要作用是以原子的方式对成员变量进行更新操作以实现线程安全（这里线程安全的保证也就是CAS+volatile）。</p>
<p>然后是定义了refCnt变量，用于跟踪对象的引用次数，使用volatile修饰解决原子变量可视性问题。</p>
<h4 id="对象引用计数器"><a href="#对象引用计数器" class="headerlink" title="对象引用计数器"></a>对象引用计数器</h4><p>那么，对对象的引用计数与释放是怎么实现的呢？核心就是两个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//计数加1</span><br><span class="line">retain();</span><br><span class="line"></span><br><span class="line">//计数减一</span><br><span class="line">release();</span><br></pre></td></tr></table></figure></p>
<p>下面分析这两个函数源码：<br>每调用一次retain()函数一次，引用计数器就会加一，由于可能存在多线程并发使用的情景，所以必须保证累加操作是线程安全的，那么是怎么保证的呢？我们来看一下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retain0(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retain</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retain0(checkPositive(increment, <span class="string">"increment"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 最后都是调用这个函数。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ByteBuf <span class="title">retain0</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> refCnt = <span class="keyword">this</span>.refCnt;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> nextCnt = refCnt + increment;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.</span></span><br><span class="line">        <span class="keyword">if</span> (nextCnt &lt;= increment) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(refCnt, increment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (refCntUpdater.compareAndSet(<span class="keyword">this</span>, refCnt, nextCnt)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在retain0()函数中， 通过for(;;)来实现了自旋锁。通过自旋来对引用计数器refCnt执行加1操作。这里的加一操作是通过原子变量refCntUpdater的compareAndSet(this, refCnt, nextCnt)方法实现的，这个通过硬件级别的CAS保证了原子性，如果修改失败了就会不停的自旋，直到修改成功为止。</p>
<p>下面再看看释放的过程：release()函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">release0</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> refCnt = <span class="keyword">this</span>.refCnt;</span><br><span class="line">        <span class="keyword">if</span> (refCnt &lt; decrement) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(refCnt, -decrement);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (refCntUpdater.compareAndSet(<span class="keyword">this</span>, refCnt, refCnt - decrement)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (refCnt == decrement) &#123;</span><br><span class="line">                deallocate();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里基本和retain()函数一样，也是通过自旋和CAS保证执行的正确的将计数器减一。这里需要注意的是当refCnt == decrement 也就是引用对象不可达时，就需要调用deallocate();方法来释放ByteBuf对象。</p>
<h4 id="7-UnpooledHeapByteBuf源码分析"><a href="#7-UnpooledHeapByteBuf源码分析" class="headerlink" title="7. UnpooledHeapByteBuf源码分析"></a>7. UnpooledHeapByteBuf源码分析</h4><p>从类名就可以知道UnpooledHeapByteBuf 是基于堆内存的字节缓冲区，没有基于对象池实现，这意味着每次的IO读写都会创建一个UnpooledHeapByteBuf对象，会造成一定的性能影响，但是也不容易出现内存管理的问题。</p>
<p><img src="/2018/05/05/netty-bytebuf/4.jpeg" alt=""></p>
<h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><p>有三个成员变量，各自的含义见注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓冲区分配器，用于UnpooledHeapByteBuf的内存分配。在UnpooledHeapByteBuf构造器中实例化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBufAllocator alloc;</span><br><span class="line"><span class="comment">//字节数组作为缓冲区</span></span><br><span class="line"><span class="keyword">byte</span>[] array;</span><br><span class="line"><span class="comment">//实现ByteBuf与NIO中ByteBuffer的转换</span></span><br><span class="line"><span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br></pre></td></tr></table></figure></p>
<h4 id="动态扩展缓冲区"><a href="#动态扩展缓冲区" class="headerlink" title="动态扩展缓冲区"></a>动态扩展缓冲区</h4><p>在说道AbstractByteBuf的时候，ByteBuf是可以自动扩展缓冲区大小的，这里我们分析一下在UnpooledHeapByteBuf中是怎么实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span> || newCapacity &gt; maxCapacity()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"newCapacity: "</span> + newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = array.length;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; oldCapacity) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newArray = <span class="keyword">new</span> <span class="keyword">byte</span>[newCapacity];</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, array.length);</span><br><span class="line">        setArray(newArray);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newCapacity &lt; oldCapacity) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newArray = <span class="keyword">new</span> <span class="keyword">byte</span>[newCapacity];</span><br><span class="line">        <span class="keyword">int</span> readerIndex = readerIndex();</span><br><span class="line">        <span class="keyword">if</span> (readerIndex &lt; newCapacity) &#123;</span><br><span class="line">            <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line">            <span class="keyword">if</span> (writerIndex &gt; newCapacity) &#123;</span><br><span class="line">                writerIndex(writerIndex = newCapacity);</span><br><span class="line">            &#125;</span><br><span class="line">            System.arraycopy(array, readerIndex, newArray, readerIndex, writerIndex - readerIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setIndex(newCapacity, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        setArray(newArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面的实现并不复杂：</p>
<p>（1）首先获取原本的容量oldCapacity；</p>
<p>（2）如果新需求容量大于oldCapacity，以新的容量newCapacity创建字节数组，将原来的字节数组内容通过调用System.arraycopy(array, 0, newArray, 0, array.length);复制过去，并将新的字节数组设为ByteBuf的字节数组。</p>
<p>（3）如果新需求容量小于oldCapacity就不需要动态扩展，但是需要截取出一段新缓冲区。</p>
<h4 id="8-PooledDirectByteBuf-内存池原理分析"><a href="#8-PooledDirectByteBuf-内存池原理分析" class="headerlink" title="8. PooledDirectByteBuf 内存池原理分析"></a>8. PooledDirectByteBuf 内存池原理分析</h4><p>PooledDirectByteBuf基于内存池实现的，具体的内存池的实现原理，比较复杂，我没分析清楚，具体的只知道，内存池就是一片提前申请的内存，当需要ByteBuf的时候，就从内存池中申请一片内存，这样效率比较高。</p>
<p>PooledDirectByteBuf和UnPooledDirectByteBuf基本一样，唯一不同的就是内存分配策略。</p>
<h4 id="创建字节缓冲区实例"><a href="#创建字节缓冲区实例" class="headerlink" title="创建字节缓冲区实例"></a>创建字节缓冲区实例</h4><p>由于PooledDirectByteBuf基于内存池实现的，所以不能通过new关键字直接实例化一个对象，而是直接从内存池中获取，然后设置引用计数器的值。看下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PooledDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">    buf.reuse(maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过RECYCLER对象的get()函数从内存池获取PooledDirectByteBuf对象。然后在buf.reuse(maxCapacity); 函数里面设置引用计数器为1。</p>
<p>来源：<a href="https://blog.csdn.net/u010853261/article/details/53690780" target="_blank" rel="external">https://blog.csdn.net/u010853261/article/details/53690780</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/04/30/browser-security/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/browser-security/" itemprop="url">
                  浏览器的同源策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-30 22:00:32 / 修改时间：22:29:03" itemprop="dateCreated datePublished" datetime="2018-04-30T22:00:32+08:00">2018-04-30</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>
<h4 id="一个源的定义"><a href="#一个源的定义" class="headerlink" title="一个源的定义"></a>一个源的定义</h4><p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p><img src="/2018/04/30/browser-security/1.png" alt=""></p>
<p>另请参见文件的源定义: <a href="https://developer.mozilla.org/en-US/docs/Same-origin_policy_for_file:_URIs" target="_blank" rel="external">URLs.</a></p>
<h4 id="源的继承"><a href="#源的继承" class="headerlink" title="源的继承"></a>源的继承</h4><p>data：URLs获得一个新的，空的安全上下文。</p>
<p>在页面中用 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有明确包含有关原始服务器的信息。</p>
<p>例如，about:blank 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过  Window.open()  机制）。 如果此弹出窗口也包含代码，则该代码将继承与创建它的脚本相同的源。data: URL会得到一个新的空的安全上下文。</p>
<p>注意：在Gecko 6.0之前，如果用户在位置栏中输入 data URLs，data URLs 将继承当前浏览器窗口中网页的安全上下文。</p>
<h4 id="IE-例外"><a href="#IE-例外" class="headerlink" title="IE 例外"></a>IE 例外</h4><p>当涉及到同源策略时，Internet Explorer 有两个主要的不同点</p>
<p>授信范围（Trust Zones）：</p>
<p>两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。</p>
<p>端口：</p>
<p>IE 未将端口号加入到同源策略的组成部分之中，因此<code>http://company.com:81/index.html和http://company.com/index.html</code>属于同源并且不受任何限制。<br>这些例外是非标准的，其它浏览器也未做出支持，但会助于开发基于window RT IE的应用程序。</p>
<h4 id="源的更改"><a href="#源的更改" class="headerlink" title="源的更改"></a>源的更改</h4><p>页面可能会因某些限制而改变他的源。脚本可以将 document.domain 的值设置为其当前域或其当前域的超级域。如果将其设置为其当前域的超级域，则较短的域将用于后续源检查。假设<code>http://store.company.com/dir/other.html</code>文档中的一个脚本执行以下语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain = <span class="string">"company.com"</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句执行之后，页面将会成功地通过对<code>http://company.com/dir/page.html</code>的同源检测（假设<code>http://company.com/dir/page.html将其document.domain设置为company.com</code>，以表明它希望允许这样做 - 更多有关信息，请参阅document.domain）。然而，company.com不能设置 document.domain为 othercompany.com因为它不是company.com的超级域。</p>
<p>浏览器单独保存端口号。任何的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null 。因此company.com:8080不能仅通过设置 document.domain=company.com来与company.com通信。必须在他们双方中都进行赋值，以确保端口号都为 null 。</p>
<p>注意：</p>
<p>使用 document.domain 来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值。这是必要的，即使这样做只是将父域设置回其原始值。不这样做可能会导致权限错误。</p>
<h4 id="跨源网络访问"><a href="#跨源网络访问" class="headerlink" title="跨源网络访问"></a>跨源网络访问</h4><p>同源策略控制了不同源之间的交互，例如在使用XMLHttpRequest 或 <img> 标签时则会受到同源策略的约束。这些交互通常分为三类：</p>
<p>通常允许跨域写操作（Cross-origin writes）。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 preflight。<br>通常允许跨域资源嵌入（Cross-origin embedding）。之后下面会举例说明。<br>通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。例如可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或availability of an embedded resource.<br>以下是可能嵌入跨源的资源的一些示例：</p>
<p><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。</p>
<p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code>标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。</p>
<p><code>&lt;img&gt;</code>嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,…</p>
<p><code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code>嵌入多媒体资源。</p>
<p><code>&lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt;</code>的插件。</p>
<p><code>@font-face</code>引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。</p>
<p><code>&lt;frame&gt; 和 &lt;iframe&gt;</code>载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。</p>
<h4 id="如何允许跨源访问"><a href="#如何允许跨源访问" class="headerlink" title="如何允许跨源访问"></a>如何允许跨源访问</h4><p>使用 CORS 允许跨源访问。</p>
<h4 id="如何阻止跨源访问"><a href="#如何阻止跨源访问" class="headerlink" title="如何阻止跨源访问"></a>如何阻止跨源访问</h4><p>阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。</p>
<p>阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。</p>
<p>阻止跨站嵌入，需要确保你的资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守 Conten-Type 消息头。例如，如果您在HTML文档中指定<code>&lt;script&gt;</code> 标记，则浏览器将尝试将HTML解析为JavaScript。 当您的资源不是您网站的入口点时，您还可以使用CSRF令牌来防止嵌入。</p>
<h4 id="跨源脚本API访问"><a href="#跨源脚本API访问" class="headerlink" title="跨源脚本API访问"></a>跨源脚本API访问</h4><p>Javascript的APIs中，如 iframe.contentWindow, window.parent, window.open 和 window.opener 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 Window 和 Location对象的访问添加限制，如下两节所述。</p>
<p>为了在不同源中文档进一步交流，可以使用window.postMessage。</p>
<h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><p>规范:  <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-window" target="_blank" rel="external">http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-window</a>.</p>
<p><img src="/2018/04/30/browser-security/2.png" alt=""></p>
<p>某些浏览器允许访问比规范允许的更多属性。</p>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>Specification:  <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-location" target="_blank" rel="external">http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-location</a>.</p>
<p><img src="/2018/04/30/browser-security/3.png" alt=""></p>
<h4 id="跨源数据存储访问"><a href="#跨源数据存储访问" class="headerlink" title="跨源数据存储访问"></a>跨源数据存储访问</h4><p>存储在浏览器中的数据，如<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/Storage" target="_blank" rel="external">localStorage</a>和<a href="https://developer.mozilla.org/zh-CN/docs/IndexedDB" target="_blank" rel="external">IndexedDB</a>，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。</p>
<p>Cookies 使用不同的源定义方式。一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀（public suffix）即可。Firefox 和 Chrome 使用 <a href="http://publicsuffix.org/" target="_blank" rel="external">Public Suffix List</a> 决定一个域是否是一个公共后缀（public suffix）。Internet Explorer使用其自己的内部方法来确定域是否是公共后缀。不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名(sub-domains) 访问 cookie。设置 cookie 时，你可以使用Domain，Path，Secure，和Http-Only标记来限定其访问性。读取 cookie 时，不会知晓它的出处。 即使您仅使用安全的https连接，您看到的任何cookie都可能使用不安全的连接进行设置。</p>
<h4 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Same-origin_policy_for_file:_URIs" target="_blank" rel="external">Same-origin policy for file: URIs</a></p>
<p><a href="http://www.w3.org/Security/wiki/Same_Origin_Policy" target="_blank" rel="external">Same-Origin Policy at W3C</a></p>
<p>来源：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://51codes.top/2018/04/14/redis-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Codes Online">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/14/redis-install/" itemprop="url">
                  CentOS6.5之Redis安装配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-14 00:19:02 / 修改时间：02:25:47" itemprop="dateCreated datePublished" datetime="2018-04-14T00:19:02+08:00">2018-04-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/环境搭建/" itemprop="url" rel="index"><span itemprop="name">环境搭建</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-3.2.11.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar -xzvf redis-3.2.11.tar.gz</span><br><span class="line"><span class="comment">#复制到指定目录</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/redis</span><br><span class="line">mv redis-3.2.11/* /usr/<span class="built_in">local</span>/redis</span><br><span class="line"><span class="comment">#安装目录下编译</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis</span><br><span class="line">make</span><br><span class="line"><span class="comment">#进入src目录</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#到utils目录复制redis_init_script文件到/etc/init.d/redis</span></span><br><span class="line"><span class="built_in">cd</span> utils</span><br><span class="line">cp redis_init_script /etc/init.d/</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d</span><br><span class="line">mv redis_init_script redis</span><br><span class="line"><span class="comment">#修改权限</span></span><br><span class="line">chmod +x /etc/init.d/redis</span><br><span class="line"><span class="comment">#编辑配置，将路径修改为安装目录</span></span><br><span class="line">vim redis</span><br><span class="line"><span class="comment">#添加[#chkconfig: 2345 80 90]到配置文件否则开机启动设置会不起作用</span></span><br></pre></td></tr></table></figure>
<p>尝试启动或停止redis </p>
<p>service redis start </p>
<p>service redis stop</p>
<h4 id="开机服务启动"><a href="#开机服务启动" class="headerlink" title="开机服务启动"></a>开机服务启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意添加[#chkconfig: 2345 80 90]到配置文件否则开机启动设置会不起作用</span></span><br><span class="line">chkconfig redis on</span><br></pre></td></tr></table></figure>
<h4 id="设置redis密码"><a href="#设置redis密码" class="headerlink" title="设置redis密码"></a>设置redis密码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"><span class="comment">#查看密码</span></span><br><span class="line">127.0.0.1:6792&gt;CONFIG get requirepass</span><br><span class="line"><span class="comment">#设置密码</span></span><br><span class="line">CONFIG <span class="built_in">set</span> requirepass <span class="string">"myredis"</span></span><br><span class="line"><span class="comment">#登录验证</span></span><br><span class="line">AUTH password  </span><br><span class="line"><span class="comment">#重启服务生效</span></span><br></pre></td></tr></table></figure>
<h4 id="远程登录redis开启"><a href="#远程登录redis开启" class="headerlink" title="远程登录redis开启"></a>远程登录redis开启</h4><p>修改redis.conf</p>
<p>注释掉bind 127.0.0.1可以使所有的ip访问redis，若是想指定多个ip访问，但并不是全部的ip访问，可以bind</p>
<p>在redis3.2之后，redis增加了protected-mode，在这个模式下，即使注释掉了bind 127.0.0.1，再访问redisd时候还是报错</p>
<p>修改办法：protected-mode no</p>
<h4 id="下载编译redis-desktop-manager"><a href="#下载编译redis-desktop-manager" class="headerlink" title="下载编译redis desktop manager"></a>下载编译redis desktop manager</h4><p><a href="https://redisdesktop.com/download" target="_blank" rel="external">https://redisdesktop.com/download</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装Xcode，QT5.9</span></span><br><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/uglide/RedisDesktopManager.git -b 0.9 rdm &amp;&amp; <span class="built_in">cd</span> ./rdm &amp;&amp; <span class="built_in">cd</span> src</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">./configure</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">107</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
