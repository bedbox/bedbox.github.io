<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android中的消息机制 | Codes Online</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android中的消息机制</h1><a id="logo" href="/.">Codes Online</a><p class="description">_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _enjoying</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android中的消息机制</h1><div class="post-meta">Oct 30, 2017<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h3 id="一-Looper、Handler、MessageQueue与Message的关系与相关概念"><a href="#一-Looper、Handler、MessageQueue与Message的关系与相关概念" class="headerlink" title="一.Looper、Handler、MessageQueue与Message的关系与相关概念"></a>一.Looper、Handler、MessageQueue与Message的关系与相关概念</h3><h3 id="1-什么是Android消息处理机制？"><a href="#1-什么是Android消息处理机制？" class="headerlink" title="1.什么是Android消息处理机制？"></a>1.什么是Android消息处理机制？</h3><p>  “消息”是windows运行机制中一个基本而又重要的概念。消息是一个报告事件发生的通知，消息驱动是围绕消息的产生与处理展开的，并依靠消息循环机制来实现（百度百科）。与Windows系统一样，Android也是消息驱动型的系统。引用一下消息驱动机制的四要素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  ①接收消息的“消息队列”</span><br><span class="line"></span><br><span class="line">  ②阻塞式地从消息队列中接收消息并进行处理的“线程”</span><br><span class="line"></span><br><span class="line">  ③可发送的“消息的格式”</span><br><span class="line"></span><br><span class="line">  ④“消息发送函数”</span><br></pre></td></tr></table></figure></p>
<p>与之对应，Android系统中对应实现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  ①接收消息的“消息队列” ——　MessageQueue</span><br><span class="line"></span><br><span class="line">  ②阻塞式地从消息队列中接收消息并进行处理的“线程” ——　Thread+Looper</span><br><span class="line"></span><br><span class="line">  ③可发送的“消息的格式” ——　Message</span><br><span class="line"></span><br><span class="line">  ④“消息发送函数”——　Handler的post()和sendMessage()</span><br></pre></td></tr></table></figure></p>
<p>  Android有大量的消息驱动方式来进行交互，比如Android的四大组件——Activity, Service, Broadcast, ContentProvider的启动过程的交互，都离不开消息机制。</p>
<h3 id="2-Handler"><a href="#2-Handler" class="headerlink" title="2.Handler"></a>2.Handler</h3><p>  Android的消息机制，很多时候我们也称之为“Handler机制”，可见Handler这个东西是相当重要了～～那么Handler是用来干什么的呢？刚刚笔者在刷知乎的时候看到有大神怼(教导)一个Android菜鸟的时候其中就提到了一点“…以为Handler就是用来更新UI的…”——好吧，真是垂死病中惊坐起——开始学Android那会笔者也曾经这么认为(捂脸)。</p>
<p>  如果你也这么认为，那么从今天起你就要放弃这种狭隘的想法——Handler是Android消息机制的上层接口，因此我们在开发中与Handler打交道的机会最多。Handler并不是专门用来更新UI的，只是开发者常常用它来更新UI。</p>
<p><strong>Handler的主要用于同一个进程间的线程通信，Handler用于更新UI的时候是”子线程与主线程通信”；当然，Handler也可以用于子线程之间通信</strong>。</p>
<p>  Handler的消息机制主要是就指“Handler的运行机制”，Handler的运行机制时需要底层的MessageQueue和Looper支持的。</p>
<h3 id="3-MessageQueue"><a href="#3-MessageQueue" class="headerlink" title="3.MessageQueue"></a>3.MessageQueue</h3><p>  MessageQueue翻译过来是”消息队列”的意思，实际上它内部的数据结构不是队列，而是单向链表；MessageQueue中储存了大量的消息，由于一个线程同一时间只能处理一条消息，所以我们建了一个链表，将我们需要处理的消息按顺序储存起来，然后一项一项的交给需要的线程处理，这就是MessageQueue存在的价值。</p>
<p>  这里笔者想到一个问题——为什么MessageQueue要用链表而不用数组来作为数据结构呢？再经过网上查找博客＋源码阅读，笔者认为是这样的——之前我们在一片文章中有讲过，单链表更适合做增删的操作，数组更适合做随机访问的操作。再MessageQueue中，我们不止要做随机访问(这里不是真的随机访问，消息的读取是根据计算出来的时间顺序来的，后文会讲)跟多的我们做的是插入和删除操作，MessageQueue.enqueueMessage()就是插入消息(消息的插入需要根据时间发送的时间顺序来确定，不存在头插还是尾插)，而插入消息；而MessageQueue.next()则是读取消息，且读取的同时也伴随这删除的过程。试想一下，一个消息队列要循环起来，必然要频繁的进行插入/读取操作，假如采用数组的话，这两个操作的平均时间复杂度都是O(N/2)，而链表为O(1)，显然链表更合适。</p>
<h3 id="4-Looper"><a href="#4-Looper" class="headerlink" title="4.Looper"></a>4.Looper</h3><p>  Looper和MessageQueue的消息就像水泵和井(里边装的是水)的关系一样，我们有了消息(水)，但是为了把水从井中抽取出来(循环起来)，我们得有一个水泵作为动力，这个动力就是Looper。</p>
<p>  如果我们在一个线程中调用Looper.prepare()…Looper.loop()，那么你的线程就成功升级为了一个Looper线程，这意味着你的线程有了一个消息泵(Looper)和一个消息队列(MessageQueue),此时你就可以调用Handler来进行线程间的通信了。</p>
<p>  我们应用的UI线程也就是主线程，在应用启动的时候，系统会自动初始化一个Looper，也就是说，我们的UI线程默认是Looper线程。这也就是为什么主线程中直接调用Handler没什么事，但是再子线程中创建Handler需要哦手动调用Looper.prepare()…Looper.loop()的和原因。</p>
<h3 id="5-Message"><a href="#5-Message" class="headerlink" title="5.Message"></a>5.Message</h3><p>  Message也就是消息，井中的水。一个Message包括了消息类型(what),消息内容(arg1,arg2),发送它的Handler(target),Runnable回调接口等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;        <span class="comment">//数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1;         <span class="comment">//简单的整数值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;        <span class="comment">//简单的整数值可以直接发送，是一种替代setData（Bundle）的低成本方案，更加省资源</span></span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;            <span class="comment">//Handler发送一个消息之后，返回此消息的目标交付时间（以毫秒为单位）。</span></span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;        <span class="comment">//Bundle可以携带更复杂的数据类型</span></span><br><span class="line"><span class="comment">/*package*/</span> Handler target;        <span class="comment">//哪个Handler发送的消息</span></span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;</span><br><span class="line"><span class="comment">//可以看到，Message带了一个指向一下个节点的链，也就是说，MessageQueue内部维护的实际上是一个链表</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;        <span class="comment">//消息池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;    <span class="comment">//消息池的最大容量</span></span><br></pre></td></tr></table></figure>
<p>讲到这里，我们先上一张图加深一下大家对于这几个东西的直观认识：</p>
<p><img src="/2017/10/30/android-handler/1.png" alt=""></p>
<h3 id="二-子线程与主线程Handler通信原理-子线程是如何通过Handler更新UI的"><a href="#二-子线程与主线程Handler通信原理-子线程是如何通过Handler更新UI的" class="headerlink" title="二.子线程与主线程Handler通信原理(子线程是如何通过Handler更新UI的)"></a>二.子线程与主线程Handler通信原理(子线程是如何通过Handler更新UI的)</h3><h3 id="1-一些熟悉的场景"><a href="#1-一些熟悉的场景" class="headerlink" title="1.一些熟悉的场景"></a>1.一些熟悉的场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">     <span class="keyword">switch</span> (msg.what) &#123;      <span class="comment">//判断标志位</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="comment">//更新UI操作</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">//耗时操作</span></span><br><span class="line">      ｝</span><br><span class="line">    Message msg =Message.obtain();<span class="comment">//从全局池中返回一个message实例，避免多次创建（如new Message）</span></span><br><span class="line">    msg.obj = data;</span><br><span class="line">    msg.what=<span class="number">1</span>;   <span class="comment">//标志消息的标志</span></span><br><span class="line">    handler.sendMessage(msg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyThread().start();</span><br></pre></td></tr></table></figure>
<p>  上面代码是我们再Android开发中经常写的一段代码，其主要作用是再子线程中进行耗时操作，并通过Handler向主线程中发送消息，通知主线程做出相应的UI变化。注意这段代码中，Handler是再主线程中创建的，因此不需要手动调用Looper.prepare()添加Looper。</p>
<p>  如果我们试图再子线程中创建一个Handler，如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Handler handler ;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">//耗时操作</span></span><br><span class="line">      ｝</span><br><span class="line">    handler = <span class="keyword">new</span> Handler();</span><br><span class="line">    Message msg =Message.obtain();<span class="comment">//从全局池中返回一个message实例，避免多次创建（如new Message）</span></span><br><span class="line">    msg.obj = data;</span><br><span class="line">    msg.what=<span class="number">1</span>;   <span class="comment">//标志消息的标志</span></span><br><span class="line">    handler.sendMessage(msg);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">new</span> MyThread().start();</span><br></pre></td></tr></table></figure>
<p>那么很显然，这个时候就会出bug了～～为了解决这个bug，我们需要手动再子线程中创建Looper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handler = <span class="keyword">new</span> Handler();</span><br><span class="line">Looper.prepare();</span><br><span class="line">Message msg =Message.obtain();<span class="comment">//从全局池中返回一个message实例，避免多次创建（如new Message）</span></span><br><span class="line">msg.obj = data;</span><br><span class="line">msg.what=<span class="number">1</span>;   <span class="comment">//标志消息的标志</span></span><br><span class="line">handler.sendMessage(msg);</span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure>
<p>为什么是这样呢？接下来从源码的解读分析</p>
<h3 id="2-Looper"><a href="#2-Looper" class="headerlink" title="2.Looper"></a>2.Looper</h3><p>(frameworks/base/core/java/android/os/Looper)</p>
<p>(1)Looper.perpare()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Looper"</span>;</span><br><span class="line">    <span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Thread mThread;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看到Looper.prepare()方法中调用了prepare(ture)方法，其中true表示，该Looper是可以被终止的。因为我们是在子线程中创建的Looper，当子线程的消息处理完之后，理应把改Looper终止掉(MessageQueue.quit)。但是在主线程的Looper中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepareMainLooper就是给主线程添加Looper,可以看到，主线程中的prepare(false)中的参数false表示的是，主线程中的Looper不能被终止掉，毕竟它是整个应用的生命，需要时刻准备着处理或者正在处理应用中的各种消息。</p>
<p>  好了我们接着看上面的prepare()中干了什么。这里出现了一个新的重量级的东西：sThreadLocal，它是ThreadLocal类的实例，关于ThreadLocal类是干什么的，我们在这里不做过多解释，我们只需要知道他是用于储存不同线程唯一对象的一个东西,即多个线程在ThreadLocal类中，通过ThreadLocal.set()保存了自己的变量之后，那么我们再各个子线程中调用ThreadLocal.get()方法，得到的仍然是当前线程之前存进去的那个值。各个线程存取各自的值，不会产生冲突。</p>
<p>  知道了ThreadLocal的作用之后，我们在来看sThreadLocal.set(new Looper(quitAllowed));这句表示我们再ThreadLocal类中保存了一个Looper对象(new Looper())，根据上面对ThreadLocal类的介绍，如果我们再当前线程中调用ThreadLocal.get()方法，则会得到本线程之前保存的唯一的变量。因此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个if表示的是，如果sThreadLocal.get() != null，说明当前线程中已经存在一个Looper，我们不能在一个线程中同时创建多个，所以此时会抛出异常。为了避免这种异常，我们可以在Looper.prepare()之前调用Looper.myLooper()类来返回当前线程中的Looper对象，判断为空之后，再调用prepare()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Ok，比比了这么多，我们接着看new Looper()中Looper中的构造函数中做了什么:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出现了消息队列MessageQueue(quitAllowed)，其中参数就是表示是否允许Looper退出的标示符。可以看到，在Looper中我们创建了一个MessageQueue实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>，此时我们的Looper就拥有了MessageQueue的对象引用。</p>
<p>(2)Looper.Loop()</p>
<p>  在Looper.perpare()调用完即我们为线程准备好Looper之后，最后一步我们还需要调用Loop()让整个Looper循环起来，这样消息才能发送出去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        ......</span><br><span class="line">        msg.recycleUnchecked();        <span class="comment">//释放占据的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用了我们刚说过的myLooper()来获取当前线程再ThreadLcoal类中储存的Looper,如果Looper为空则会抛出异常，提示当前线程没有Looper。然后inal MessageQueue queue = me.mQueue;是获取当前线程的Looper中的MessageQueue对象。</p>
<p>  之后这个Looper便进入了一个无限循环的状态——for(;;)，Message msg = queue.next();是一条一条遍历整个消息队列，拿出msg消息。</p>
<p>  而msg.target.dispatchMessage(msg);这句中的msg.target实际上就是当前消息的目标Handler，也就是哪个线程中的Handler发送的消息，当然，这个发送它的Handler也要在自己所在的线程中接受这条消息。</p>
<p>  msg.recycleUnchecked();这句是将这天消息放入Message类中的消息池中。</p>
<p>从上面我们基本上可以得出——Looper &gt; MessageQueue &gt; Message的关系，也就是说，每个Looper中维护了一个消息队列，而一个消息队列中则以链表的形式排列着一条条消息。</p>
<h3 id="3-MessageQueue-next"><a href="#3-MessageQueue-next" class="headerlink" title="3.MessageQueue.next()"></a>3.MessageQueue.next()</h3><p>(frameworks/base/core/java/android/os/MessageQueue)<br>上面的Looper类中我们实例化了一个MessageQueue对象，并调用了MessageQueue.next()类方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;        <span class="comment">//当消息循环已经退出，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration　循环迭代的首次为-1，也就是初始值为-１</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;        <span class="comment">//消息队列开始无限循环</span></span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻塞操作的方法，当等待nextPollTimeoutMillis时长，或者消息队列里边有了消息被唤醒时，</span></span><br><span class="line">        <span class="comment">//只有满足这两个条件该方法才会返回，for循环才能往下执行下面的代码，否则就一直在这等着</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;    <span class="comment">//这一段同步块代码中就是再检索下一条message,如果找到了就返回</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();    <span class="comment">//手机开机到现在的时间(毫秒为单位)，手机睡眠的时间不包括再内</span></span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;            <span class="comment">//如果此时消息不为null,但是这个消息找不到发送它的Handler，说明为不合法消息，放弃并寻找下一条异步消息</span></span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;    <span class="comment">//如果消息不为null(这次是个正常消息)</span></span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 虽然消息是正常的，但是还没到发送的时间。msg.when表示消息发送的时间，因为我们可能调用了postDelay()</span></span><br><span class="line">                    <span class="comment">//延迟发送。我们之前说过，当等待nextPollTimeoutMillis时长后nativePollOnce()方法就会返回。</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//else则表示，成功抓到了一条消息</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;        <span class="comment">//单链表操作，下面讲</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">              ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个mPtr我们之前在MessageQueue的构造方法中提到过:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它通过mPtr = nativeInit();得到值，nativeInit()是一个native层的方法，根据注释来看，它主要是判断Looper目前的状态。if (ptr == 0) {表示的是当前线程的Looper已经退出或者被处理掉了，这种情况发生在“应用在退出之后试图重启Looper”的情况下，这种情况是不被允许的，因此此时return null;</p>
<p>  上面这段中还要讲的就是单链表的操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prevMsg.next = msg.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mMessages = msg.next;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.next = <span class="keyword">null</span>;</span><br><span class="line">    msg.markInUse();    <span class="comment">//表示这个消息已经被传递(使用了)</span></span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，再synchronized (this)同步块一开始的时候，有一个全局变量mMessages，这实际上就是等待处理消息,这个变量很重要，之后我们会多次遇到。这里还有一个叫prevMsg的Message,用于保存找不到msg.target的消息(废消息)。OK，回到链表操作中来，if (prevMsg != null)，很遗憾，有一个不合法的消息，此时上面已经经历了prevMsg = msg;　msg = msg.next;这两步，加上prevMsg.next = msg.next;这一步，实际上就是prevMsg的后继引用跳过了msg，直接指向了msg的下一位(注意prevMsg是不合法的，但是它的下一位msg是合法的)。</p>
<p>  再看else，说明没有不合法的消息，Message msg = mMessages;加上mMessages = msg.next;，这两步实际上和上面一样，也是工作指针后移，越过了msg。也就是msg出队，msg的下一条消息成为mMessages(待处理消息)，否则就进入一个阻塞状态，一直等到有新的消息入队。</p>
<p>  OK，上面if和else中越过的msg，就是我们要返回的正常消息，接着两句:msg.next = null;和return msg;就可以知道，前者是将msg的后继引用清空(将它从链表中删除)，然后return。</p>
<p>  通过上面的分析我们知道，MessageQueue.next()作用就是遍历链表，找出一个合法的msg，将它从链表中删除后返回，这实际上也就是一个消息出队的过程</p>
<h3 id="4-Handler"><a href="#4-Handler" class="headerlink" title="4.Handler"></a>4.Handler</h3><p>(1)Handler.post/sendMessage将一个消息添加到消息队列中</p>
<p>  上面我们已经讲完了Handler通信的两个重要的基础类——MessageQueue和Looper，接下来我们分析一下Handler是如何将一个消息发送出去的。</p>
<p>  我们从Handler的构造函数开始看起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Hnadler在发送消息的时候先获取当前线程的Looper，然后做一次looper的非空判断；接着获取了Looper中的MessageQueue对象。这样，我们的Handler已经和Looer以及MessageQueue取得了联系。</p>
<p>  接着回到文章最开始的时候举的那个例子中，handler.sendMessage()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面几个方法的逻辑都比较清晰，可以看到，最终调用了MessageQueue的enqueueMessage()方法，其中第一个参数为msg,第二个参数uptimeMillis = SystemClock.uptimeMillis() + delayMillis，也就是开机到现在的时间(不包括睡眠时间)+我们设定的delay时间，接下来我们看看enqueueMessage()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;    <span class="comment">//目标Handler为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;    <span class="comment">//msg已经用过了    </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;        <span class="comment">//如果这个Looper正在退出，回收msg，加入到消息池</span></span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            msg.recycle();        <span class="comment">//释放msg资源</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();        <span class="comment">//表示这个msg已经被使用了</span></span><br><span class="line">        <span class="comment">//这里我们可以知道，Message类的when属性实际上就是SystemClock.uptimeMillis() + delayMillis</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">        <span class="comment">//如果p == null，说明MessageQueue中没有消息；或者msg的时间是这个消息队列中最靠前的</span></span><br><span class="line">            msg.next = p;        <span class="comment">//将这个msg提取出来，并复制给mMessages，mMessages会在上面的</span></span><br><span class="line">            mMessages = msg;    <span class="comment">//MessageQueue.next()方法中进行一系列判断后返回</span></span><br><span class="line">            needWake = mBlocked;    <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;        <span class="comment">//elss,说明此时我们发送过来的消息需要按照一定规则插入到队列中</span></span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">  ①        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;        <span class="comment">//工作指针后移并且循环遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;    <span class="comment">//找到一个不为空并且发送时间大于当前发送时间的消息,</span></span><br><span class="line">                    <span class="keyword">break</span>;        <span class="comment">//跳出循环，准备把msg（要发送的消息）查到这条消息之前</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   ②       msg.next = p; <span class="comment">// 单链表插入</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<p>  上面代码中①处的for()循环就是在循环遍历MessageQueue以找到合适的msg插位置，②处的代码实际上就是一个单链表插入的过程，我们可以把整个插入的代码连起来，这样更容易看出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prev = p;</span><br><span class="line">p = p.next;</span><br><span class="line">msg.next = p;</span><br><span class="line">prev.next = msg;</span><br></pre></td></tr></table></figure>
<p>没骗你吧~~这就是把我们的要发送的消息msg插入到了链表中的p节点之前。</p>
<p>  我们需要明确的一点是，这里的Handler.post/sendMessage方法是和上面的MessageQueue.next()方法是对应的，他是消息的入队操作。</p>
<p>(2)Looper.loop()中调用Handler.dispatchMessage()接受并处理消息</p>
<p>  好了，讲到这里，我们可以看到，Handler.post或者Handler.sendMessage方法，最终是将他们要发送的消息添加到了消息队列中(Handler.post实际上也是调用了Handler.sendMessageDaley())。</p>
<p>  那么接受消息在哪呢？好吧看标题你也知道，Looper.loop()方法中我们实现了消息的重写与接收。我们回过头去看Looper类，在该类中MessageQueue.next()这个消息出队的方法调用完之后，出现了msg.target.dispatchMessage(msg);这句代码，我们说过这句代码中的msg.target就是消息的目标Handler,于是我们回到Handler中看下这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看到最终我们调用了一个空方法，为什么呢，因为消息的最终回调是由我们控制的，我们在创建handler的时候会在Handler所在的线程中(如果是子线程更新主线程UI的话，就在主线程中)重写handleMessage方法，然后根据msg.what进行消息处理(对照开始给出的Hanlder常见场景)。</p>
<p>我们梳理一下整个流程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">① handler = <span class="keyword">new</span> Handler();    <span class="comment">//创建Handler对象</span></span><br><span class="line">② Looper.prepare();        <span class="comment">//准备好Looper，初始化MessageQueue</span></span><br><span class="line">③ Message msg =Message.obtain();    <span class="comment">//从消息池中取出一个可用的Message实例</span></span><br><span class="line">④ msg.obj = data;            <span class="comment">//消息的数据</span></span><br><span class="line">   msg.what=<span class="number">1</span>;                <span class="comment">//标志消息的标志</span></span><br><span class="line">⑤ handler.sendMessage(msg);        <span class="comment">//发送消息，将一个消息添加到消息队列中去</span></span><br><span class="line">⑥ Looper.loop();        <span class="comment">//使用loop使消息队列循环起来，并进行消息的出队删除操作</span></span><br></pre></td></tr></table></figure>
<p>Looper.loop()中的消息出队之后，将调用Handler的dispatchMessage，最终大我们在代码中重写的handleMessage用以自定处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">       <span class="keyword">switch</span> (msg.what) &#123;      <span class="comment">//判断标志位</span></span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               <span class="comment">//更新UI操作</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>(3)Handler.post() &amp; View.post() &amp; Activity.runOnUiThread()</p>
<p>①Handler.post()</p>
<p>  上面我们说了Handler.sendMessage()方法，并且在文章开头的实例中展示了Handler.sendMessage()的使用方法，下面我们来说一下Handler.post()，该方法的具体使用还是略微的有一点不同的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Hander.post()方法还是调用了sendMessageDelayed方法，这跟之前的流程是一样的。这里我们要说的是sendMessageDelayed(getPostMessage(r), 0);中的getPostMessage(r)方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中将消息的callback字段的值指定为传入的Runnable对象。这个callback字段之前我们有遇到过——在Handler的dispatchMessage()方法中原来有做一个检查，如果Message的callback等于null才会去调用handleMessage()方法，否则就调用handleCallback()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handleCallback(msg)：</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的run也就是一开始的时候传入的run接口。也就是说，如果通过post(Runnable r)传递消息的话，我们直接就可以在post()方法中进行UI操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handler = <span class="keyword">new</span> Handler();  </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            handler.post(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    <span class="comment">// 在这里进行UI操作  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;).start();</span><br></pre></td></tr></table></figure>
<p>写法上简洁了很多，但是本质上都是一样的。</p>
<p>②View.post()<br>(source/android-24/android/view/View):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到同样调用了Handler的post方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Activity.runOnUiThread()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">            mHandler.post(action);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            action.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，否则就直接调用Runnable对象的run()方法。</p>
<h3 id="5-Message-obtain"><a href="#5-Message-obtain" class="headerlink" title="5.Message.obtain"></a>5.Message.obtain</h3><p>上面我们需要解释的一个东西便是Message msg =Message.obtain();这句，Message的obtain()方法中维护了一个消息池，其最大容量MAX_POOL_SIZE = 50</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment"> * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;    <span class="comment">//消息池不为空时从消息池中直接拿消息</span></span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;    <span class="comment">//工作指针后移，准备取出sPool</span></span><br><span class="line">            m.next = <span class="keyword">null</span>;    <span class="comment">//从sPool中取出一个Message对象，并消息链表断开</span></span><br><span class="line">            m.flags = <span class="number">0</span>;     <span class="comment">// 清除in-use flag</span></span><br><span class="line">            sPoolSize--;    <span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();    <span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Constructor (but the preferred way to get a Message is to call &#123;<span class="doctag">@link</span> #obtain() Message.obtain()&#125;).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们当然可以直接new Message()这样来创建消息，但是一般来讲我们还是应该调用Message.obtain()方法来返回一个消息实例，以避免Message对象的多次创建。</p>
<p>好了，到此为止，我们调用Handler发送消息更新UI的整个流程就说完了。</p>
<h3 id="三-Activity启动过程中UI线程的MainLooper的创建"><a href="#三-Activity启动过程中UI线程的MainLooper的创建" class="headerlink" title="三.Activity启动过程中UI线程的MainLooper的创建"></a>三.Activity启动过程中UI线程的MainLooper的创建</h3><p>  Actvity的启动流程我们之前在一片文章中有讲过，真正启动Activity的是ActiivtyThread类中的main()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    ......</span><br><span class="line">    Looper.loop();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在启动一个Activity之前,我们在ActivityThread.main()方法中，调用了Looper.prepareMainLooper()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法同上面的Looper.prepare()方法一样，只不过这里准备的是主线程中的Looper,因此prepare(false);其中的参数false表示的是，该线程的Looper不能退出。之后调用myLooper则是获取主线程中的Looper对象，这些和上面都没什么区别。</p>
<p>  我们回到ActivityThread.main()中，在准备完主线程的Looper之后，ActivityThread thread = new ActivityThread();创建一个ActivityThread实例。thread.attach(false);参数false表示这不是系统进程，是给普通应用程序使用的进程。</p>
<p>我们接着thread.attach(false);来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>
<p>注意到mgr.attachApplication(mAppThread);这句，其中mAppThread是ApplicationThread的对象，mgr为IActivityManager接口类，而真正实现IActivityManager接口的是在ActivityManagerService(AMS)类中,关于AMS类中的代码我们这里就先不详细解释了，我们只需要知道，在它当中经过一系列的处理~~最终：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r, System.identityHashCode(r),</span><br><span class="line">        r.info, r.icicle, results, newIntents, !andResume, isNextTransitionForward());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又回调到了ActivityThread类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法在ApplicationThread(Binder线程)中调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line">        updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line">        ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">        r.token = token;</span><br><span class="line">        r.ident = ident;</span><br><span class="line">        r.intent = intent;</span><br><span class="line">        r.referrer = referrer;</span><br><span class="line">        r.voiceInteractor = voiceInteractor;</span><br><span class="line">        r.activityInfo = info;</span><br><span class="line">        r.compatInfo = compatInfo;</span><br><span class="line">        r.state = state;</span><br><span class="line">        r.persistentState = persistentState;</span><br><span class="line">        r.pendingResults = pendingResults;</span><br><span class="line">        r.pendingIntents = pendingNewIntents;</span><br><span class="line">        r.startsNotResumed = notResumed;</span><br><span class="line">        r.isForward = isForward;</span><br><span class="line">        r.profilerInfo = profilerInfo;</span><br><span class="line">        r.overrideConfig = overrideConfig;</span><br><span class="line">        updatePendingConfiguration(curConfig);</span><br><span class="line">        sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里将一系列应用的信息封装在ActivityClientRecord中之后，最终调用了sendMessage(H.LAUNCH_ACTIVITY, r);发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的“H”实际上就是一个Handler类：private class H extends Handler {，而这里的mH则是H的子类。接着往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">           <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">               Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">               <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">               r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                       r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">               handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">               Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">               ......</span><br></pre></td></tr></table></figure>
<p>可以看到，这里handleMessage收到了我们发送的LAUNCH_ACTIVITY也就是启动Activity的请求，实际上这里还有PAUSE_ACTIVITY，RESUME_ACTIVITY等一系列请求的处理。</p>
<p>之后handleLaunchActivity(r, null, “LAUNCH_ACTIVITY”);–&gt;performLaunchActivity–&gt;mInstrumentation.callActivityOnCreate一系列流程之后，我们的Activity就启动了，这个我们在之前的文章中有讲过，这里不再獒述。</p>
<p>来源：<a href="http://www.jianshu.com/p/f1da1ed7bd7e" target="_blank" rel="external">http://www.jianshu.com/p/f1da1ed7bd7e</a></p>
</div><div class="tags"></div><div class="post-nav"><a href="/2017/10/30/cglib-for-android/" class="pre">将cglib动态代理思想带入Android开发</a><a href="/2017/10/30/kafka-zookeeper/" class="next">消息中间件kafka+zookeeper集群部署</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenCV/">OpenCV</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式/">嵌入式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/环境搭建/">环境搭建</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/行业/">行业</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.linkedkeeper.com/" title="张松然" target="_blank">张松然</a><ul></ul><a href="http://weishu.me/" title="维术" target="_blank">维术</a><ul></ul><a href="http://zhixinliu.com/" title="Zhixin Liu" target="_blank">Zhixin Liu</a><ul></ul><a href="http://www.ruanyifeng.com/" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.tianmaying.com/user/luoruici" title="Ricky" target="_blank">Ricky</a><ul></ul><a href="http://jeffdeng.me/" title="荒于嬉" target="_blank">荒于嬉</a><ul></ul><a href="https://kcaogen.com/blog" title="康草根" target="_blank">康草根</a><ul></ul><a href="http://13blog.site/" title="zhenfeng13" target="_blank">zhenfeng13</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Codes Online.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>