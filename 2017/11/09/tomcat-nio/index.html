<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>深度解读Tomcat中的NIO模型 | Codes Online</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深度解读Tomcat中的NIO模型</h1><a id="logo" href="/.">Codes Online</a><p class="description">_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _enjoying</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深度解读Tomcat中的NIO模型</h1><div class="post-meta">Nov 9, 2017<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h3 id="一、I-O复用模型解读"><a href="#一、I-O复用模型解读" class="headerlink" title="一、I/O复用模型解读"></a>一、I/O复用模型解读</h3><p>Tomcat的NIO是基于I/O复用来实现的。对这点一定要清楚，不然我们的讨论就不在一个逻辑线上。下面这张图学习过I/O模型知识的一般都见过，出自《UNIX网络编程》，I/O模型一共有阻塞式I/O，非阻塞式I/O，I/O复用(select/poll/epoll)，信号驱动式I/O和异步I/O。这篇文章讲的是I/O复用。</p>
<p><img src="/2017/11/09/tomcat-nio/1.jpg" alt=""></p>
<p>这里先来说下用户态和内核态，直白来讲，如果线程执行的是用户代码，当前线程处在用户态，如果线程执行的是内核里面的代码，当前线程处在内核态。更深层来讲，操作系统为代码所处的特权级别分了4个级别。不过现代操作系统只用到了0和3两个级别。0和3的切换就是用户态和内核态的切换。更详细的可参照《深入理解计算机操作系统》。I/O复用模型，是同步非阻塞，这里的非阻塞是指I/O读写，对应的是recvfrom操作，因为数据报文已经准备好，无需阻塞。说它是同步，是因为，这个执行是在一个线程里面执行的。有时候，还会说它又是阻塞的，实际上是指阻塞在select上面，必须等到读就绪、写就绪等网络事件。有时候我们又说I/O复用是多路复用，这里的多路是指N个连接，每一个连接对应一个channel，或者说多路就是多个channel。复用，是指多个连接复用了一个线程或者少量线程(在Tomcat中是Math.min(2,Runtime.getRuntime().availableProcessors()))。</p>
<p>上面提到的网络事件有连接就绪，接收就绪，读就绪，写就绪四个网络事件。I/O复用主要是通过Selector复用器来实现的，可以结合下面这个图理解上面的叙述。</p>
<p><img src="/2017/11/09/tomcat-nio/2.jpg" alt=""></p>
<h3 id="二、TOMCAT对IO模型的支持"><a href="#二、TOMCAT对IO模型的支持" class="headerlink" title="二、TOMCAT对IO模型的支持"></a>二、TOMCAT对IO模型的支持</h3><p><img src="/2017/11/09/tomcat-nio/3.jpg" alt=""></p>
<p>tomcat从6以后开始支持NIO模型，实现是基于JDK的java.nio包。这里可以看到对read body 和response body是Blocking的。关于这点在第6.3节源代码阅读有重点介绍。</p>
<h3 id="三、TOMCAT中NIO的配置与使用"><a href="#三、TOMCAT中NIO的配置与使用" class="headerlink" title="三、TOMCAT中NIO的配置与使用"></a>三、TOMCAT中NIO的配置与使用</h3><p>在Connector节点配置protocol=”org.apache.coyote.http11.Http11NioProtocol”，Http11NioProtocol协议下默认最大连接数是10000，也可以重新修改maxConnections的值，同时我们可以设置最大线程数maxThreads，这里设置的最大线程数就是Excutor的线程池的大小。在BIO模式下实际上是没有maxConnections，即使配置也不会生效，BIO模式下的maxConnections是保持跟maxThreads大小一致，因为它是一请求一线程模式。</p>
<h3 id="四、NioEndpoint组件关系图解读"><a href="#四、NioEndpoint组件关系图解读" class="headerlink" title="四、NioEndpoint组件关系图解读"></a>四、NioEndpoint组件关系图解读</h3><p><img src="/2017/11/09/tomcat-nio/4.jpg" alt=""></p>
<p>我们要理解tomcat的nio最主要就是对NioEndpoint的理解。它一共包含LimitLatch、Acceptor、Poller、SocketProcessor、Excutor5个部分。LimitLatch是连接控制器，它负责维护连接数的计算，nio模式下默认是10000，达到这个阈值后，就会拒绝连接请求。Acceptor负责接收连接，默认是1个线程来执行，将请求的事件注册到事件列表。有Poller来负责轮询，Poller线程数量是cpu的核数Math.min(2,Runtime.getRuntime().availableProcessors())。由Poller将就绪的事件生成SocketProcessor同时交给Excutor去执行。Excutor线程池的大小就是我们在Connector节点配置的maxThreads的值。在Excutor的线程中，会完成从socket中读取http request，解析成HttpServletRequest对象，分派到相应的servlet并完成逻辑，然后将response通过socket发回client。在从socket中读数据和往socket中写数据的过程，并没有像典型的非阻塞的NIO的那样，注册OP_READ或OP_WRITE事件到主Selector，而是直接通过socket完成读写，这时是阻塞完成的，但是在timeout控制上，使用了NIO的Selector机制，但是这个Selector并不是Poller线程维护的主Selector，而是BlockPoller线程中维护的Selector，称之为辅Selector。详细源代码可以参照 第6.3节。</p>
<h3 id="五、NioEndpoint执行序列图"><a href="#五、NioEndpoint执行序列图" class="headerlink" title="五、NioEndpoint执行序列图"></a>五、NioEndpoint执行序列图</h3><p><img src="/2017/11/09/tomcat-nio/5.jpg" alt=""></p>
<p>在下一小节NioEndpoint源码解读中我们将对步骤1-步骤11依次找到对应的代码来说明。</p>
<h3 id="六、NioEndpoint源码解读"><a href="#六、NioEndpoint源码解读" class="headerlink" title="六、NioEndpoint源码解读"></a>六、NioEndpoint源码解读</h3><h3 id="6-1、初始化"><a href="#6-1、初始化" class="headerlink" title="6.1、初始化"></a>6.1、初始化</h3><p>无论是BIO还是NIO，开始都会初始化连接限制，不可能无限增大，NIO模式下默认是10000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> LimitLatch <span class="title">initializeConnectionLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxConnections==-<span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (connectionLimitLatch==<span class="keyword">null</span>) &#123;</span><br><span class="line">        connectionLimitLatch = <span class="keyword">new</span> LimitLatch(getMaxConnections());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connectionLimitLatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2、步骤解读"><a href="#6-2、步骤解读" class="headerlink" title="6.2、步骤解读"></a>6.2、步骤解读</h3><p>下面我们着重叙述跟NIO相关的流程，共分为11个步骤，分别对应上面序列图中的步骤。</p>
<p>步骤1：绑定IP地址及端口，将ServerSocketChannel设置为阻塞。</p>
<p>这里为什么要设置成阻塞呢，我们一直都在说非阻塞。Tomcat的设计初衷主要是为了操作方便。这样这里就跟BIO模式下一样了。只不过在BIO下这里返回的是Socket，NIO下这里返回的是SocketChannel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">    serverSock.socket().bind(addr,getBacklog());</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); </span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">    selectorPool.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤2：启动接收线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这个方法实际是在它的超类AbstractEndpoint里面    </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> Acceptor[count];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        acceptors[i] = createAcceptor();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(acceptors[i], getName() + <span class="string">"-Acceptor-"</span> + i);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤3：ServerSocketChannel.accept()接收新连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>.<span class="title">Acceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//省略代码...</span></span><br><span class="line">                SocketChannel socket = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                        </span><br><span class="line">                    socket = serverSock.accept();<span class="comment">//接收新连接</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    <span class="comment">//省略代码...</span></span><br><span class="line">                    <span class="keyword">throw</span> ioe;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//省略代码...</span></span><br><span class="line">                <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">                        <span class="comment">//省略代码...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//省略代码...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketTimeoutException sx) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                <span class="comment">//省略代码...</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (OutOfMemoryError oom) &#123;</span><br><span class="line">                <span class="comment">//省略代码...</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">//省略代码...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤4：将接收到的链接通道设置为非阻塞</p>
<p>步骤5：构造NioChannel对象</p>
<p>步骤6：register注册到轮询线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.configureBlocking(<span class="keyword">false</span>);<span class="comment">//将连接通道设置为非阻塞</span></span><br><span class="line">        Socket sock = socket.socket();</span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line">        NioChannel channel = nioChannels.poll();<span class="comment">//构造NioChannel对象</span></span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">        getPoller0().register(channel);<span class="comment">//register注册到轮询线程</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤7：构造PollerEvent，并添加到事件队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConcurrentLinkedQueue&lt;Runnable&gt; events = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Runnable&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> NioChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">    PollerEvent r = eventCache.poll();</span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">    addEvent(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤8：启动轮询线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">        <span class="comment">// Start poller threads</span></span><br><span class="line">        pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤9：取出队列中新增的PollerEvent并注册到Selector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PollerEvent</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( interestOps == OP_REGISTER ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.getIOChannel().register(socket.getPoller().getSelector(), SelectionKey.OP_READ, key);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">                log.error(<span class="string">""</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//省略代码...</span></span><br><span class="line">        &#125;<span class="comment">//end if</span></span><br><span class="line">    &#125;<span class="comment">//run</span></span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤10：Selector.select()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Loop until destroy() is called</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//省略代码...</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( !close ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        keyCount = selector.selectNow();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        keyCount = selector.select(selectorTimeout);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//省略代码...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//省略代码...</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> ( NullPointerException x ) &#123;</span><br><span class="line">                <span class="comment">//省略代码...</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> ( CancelledKeyException x ) &#123;</span><br><span class="line">                <span class="comment">//省略代码...</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                <span class="comment">//省略代码...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//省略代码...</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                        keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey sk = iterator.next();</span><br><span class="line">                KeyAttachment attachment = (KeyAttachment)sk.attachment();</span><br><span class="line">                <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    attachment.access();</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    processKey(sk, attachment);<span class="comment">//此方法跟下去就是把SocketProcessor交给Excutor去执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//while</span></span><br><span class="line">            <span class="comment">//省略代码...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError oom) &#123;</span><br><span class="line">            <span class="comment">//省略代码...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤11：根据选择的SelectionKey构造SocketProcessor提交到请求处理线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(NioChannel socket, SocketStatus status, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">        SocketProcessor sc = processorCache.poll();</span><br><span class="line">        <span class="keyword">if</span> ( sc == <span class="keyword">null</span> ) </span><br><span class="line">            sc = <span class="keyword">new</span> SocketProcessor(socket,status);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            sc.reset(socket,status);</span><br><span class="line">        <span class="keyword">if</span> ( dispatch &amp;&amp; getExecutor()!=<span class="keyword">null</span> ) </span><br><span class="line">            getExecutor().execute(sc);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            sc.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3、NioBlockingSelector和BlockPoller介绍"><a href="#6-3、NioBlockingSelector和BlockPoller介绍" class="headerlink" title="6.3、NioBlockingSelector和BlockPoller介绍"></a>6.3、NioBlockingSelector和BlockPoller介绍</h3><p>上面的序列图有个地方我没有描述，就是NioSelectorPool这个内部类，是因为在整体理解tomcat的nio上面在序列图里面不包括它更好理解。在有了上面的基础后，我们在来说下NioSelectorPool这个类，对更深层了解Tomcat的NIO一定要知道它的作用。NioEndpoint对象中维护了一个NioSelecPool对象，这个NioSelectorPool中又维护了一个BlockPoller线程，这个线程就是基于辅Selector进行NIO的逻辑。以执行servlet后，得到response，往socket中写数据为例，最终写的过程调用NioBlockingSelector的write方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer buf, NioChannel socket, <span class="keyword">long</span> writeTimeout,MutableInteger lastWrite)</span> </span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());  </span><br><span class="line">    <span class="keyword">if</span> ( key == <span class="keyword">null</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Key no longer registered"</span>);  </span><br><span class="line">    KeyAttachment att = (KeyAttachment) key.attachment();  </span><br><span class="line">    <span class="keyword">int</span> written = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">int</span> keycount = <span class="number">1</span>; <span class="comment">//assume we can write  </span></span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis(); <span class="comment">//start the timeout timer  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">while</span> ( (!timedout) &amp;&amp; buf.hasRemaining()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (keycount &gt; <span class="number">0</span>) &#123; <span class="comment">//only write if we were registered for a write  </span></span><br><span class="line">                <span class="comment">//直接往socket中写数据  </span></span><br><span class="line">                <span class="keyword">int</span> cnt = socket.write(buf); <span class="comment">//write the data  </span></span><br><span class="line">                lastWrite.set(cnt);  </span><br><span class="line">                <span class="keyword">if</span> (cnt == -<span class="number">1</span>)  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();  </span><br><span class="line">                written += cnt;  </span><br><span class="line">                <span class="comment">//写数据成功，直接进入下一次循环，继续写  </span></span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    time = System.currentTimeMillis(); <span class="comment">//reset our timeout timer  </span></span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//we successfully wrote, try again without a selector  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//如果写数据返回值cnt等于0，通常是网络不稳定造成的写数据失败  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">//开始一个倒数计数器   </span></span><br><span class="line">                <span class="keyword">if</span> ( att.getWriteLatch()==<span class="keyword">null</span> || att.getWriteLatch().getCount()==<span class="number">0</span>) </span><br><span class="line">                    att.startWriteLatch(<span class="number">1</span>);  </span><br><span class="line">                <span class="comment">//将socket注册到辅Selector，这里poller就是BlockSelector线程  </span></span><br><span class="line">                poller.add(att,SelectionKey.OP_WRITE);  </span><br><span class="line">                <span class="comment">//阻塞，直至超时时间唤醒，或者在还没有达到超时时间，在BlockSelector中唤醒  </span></span><br><span class="line">                att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);  </span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ignore) &#123;  </span><br><span class="line">                Thread.interrupted();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> ( att.getWriteLatch()!=<span class="keyword">null</span> &amp;&amp; att.getWriteLatch().getCount()&gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                keycount = <span class="number">0</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">//还没超时就唤醒，说明网络状态恢复，继续下一次循环，完成写socket  </span></span><br><span class="line">                keycount = <span class="number">1</span>;  </span><br><span class="line">                att.resetWriteLatch();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (writeTimeout &gt; <span class="number">0</span> &amp;&amp; (keycount == <span class="number">0</span>))  </span><br><span class="line">                timedout = (System.currentTimeMillis() - time) &gt;= writeTimeout;  </span><br><span class="line">        &#125; <span class="comment">//while  </span></span><br><span class="line">        <span class="keyword">if</span> (timedout)   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketTimeoutException();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        poller.remove(att,SelectionKey.OP_WRITE);  </span><br><span class="line">        <span class="keyword">if</span> (timedout &amp;&amp; key != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            poller.cancelKey(socket, key);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> written;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说当socket.write()返回0时，说明网络状态不稳定，这时将socket注册OP_WRITE事件到辅Selector，由BlockPoller线程不断轮询这个辅Selector，直到发现这个socket的写状态恢复了，通过那个倒数计数器，通知Worker线程继续写socket动作。看一下BlockSelector线程的代码逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (run) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ......  </span><br><span class="line">            Iterator iterator = keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">while</span> (run &amp;&amp; iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;  </span><br><span class="line">                SelectionKey sk = (SelectionKey) iterator.next();  </span><br><span class="line">                KeyAttachment attachment = (KeyAttachment)sk.attachment();  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    attachment.access();  </span><br><span class="line">                    iterator.remove(); ;  </span><br><span class="line">                    sk.interestOps(sk.interestOps() &amp; (~sk.readyOps()));  </span><br><span class="line">                    <span class="keyword">if</span> ( sk.isReadable() ) &#123;  </span><br><span class="line">                        countDown(attachment.getReadLatch());  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="comment">//发现socket可写状态恢复，将倒数计数器置位，通知Worker线程继续  </span></span><br><span class="line">                    <span class="keyword">if</span> (sk.isWritable()) &#123;  </span><br><span class="line">                        countDown(attachment.getWriteLatch());  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;<span class="keyword">catch</span> (CancelledKeyException ckx) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (sk!=<span class="keyword">null</span>) sk.cancel();  </span><br><span class="line">                    countDown(attachment.getReadLatch());  </span><br><span class="line">                    countDown(attachment.getWriteLatch());  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;<span class="comment">//while  </span></span><br><span class="line">        &#125;<span class="keyword">catch</span> ( Throwable t ) &#123;  </span><br><span class="line">            log.error(<span class="string">""</span>,t);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    events.clear();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        selector.selectNow();<span class="comment">//cancel all remaining keys  </span></span><br><span class="line">    &#125;<span class="keyword">catch</span>( Exception ignore ) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())log.debug(<span class="string">""</span>,ignore);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个辅Selector主要是减少线程间的切换，同时还可减轻主Selector的负担。</p>
<h3 id="七、关于性能"><a href="#七、关于性能" class="headerlink" title="七、关于性能"></a>七、关于性能</h3><p>下面这份报告是我们压测的一个结果，跟想象的是不是不太一样？几乎没有差别，实际上NIO优化的是I/O的读写，如果瓶颈不在这里的话，比如传输字节数很小的情况下，BIO和NIO实际上是没有差别的。NIO的优势更在于用少量的线程hold住大量的连接。还有一点，我们在压测的过程中，遇到在NIO模式下刚开始的一小段时间内容，会有错误，这是因为一般的压测工具是基于一种长连接，也就是说比如模拟1000并发，那么同时建立1000个连接，下一时刻再发送请求就是基于先前的这1000个连接来发送，还有TOMCAT的NIO处理是有POLLER线程来接管的，它的线程数一般等于CPU的核数，如果一瞬间有大量并发过来，POLLER也会顿时处理不过来。</p>
<p><img src="/2017/11/09/tomcat-nio/6.png" alt=""></p>
<h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>NIO只是优化了网络IO的读写，如果系统的瓶颈不在这里，比如每次读取的字节说都是500b，那么BIO和NIO在性能上没有区别。NIO模式是最大化压榨CPU，把时间片都更好利用起来。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源如内存，有关线程资源可参照这篇文章《一台java服务器可以跑多少个线程》。因此，使用的线程越少越好。而I/O复用模型正是利用少量的线程来管理大量的连接。在对于维护大量长连接的应用里面更适合用基于I/O复用模型NIO，比如web qq这样的应用。所以我们要清楚系统的瓶颈是I/O还是CPU的计算。</p>
<p>参考资料：</p>
<p><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/http.html" target="_blank" rel="external">http://tomcat.apache.org/tomcat-7.0-doc/config/http.html</a></p>
<p><a href="http://gearever.iteye.com/blog/1844203" target="_blank" rel="external">http://gearever.iteye.com/blog/1844203</a></p>
<p>《Tomcat内核设计剖析》</p>
<p>《深入理解计算机操作系统》</p>
<p>《UNIX网络编程》卷1</p>
<p>来源：<a href="http://www.linkedkeeper.com/detail/blog.action?bid=1046" target="_blank" rel="external">http://www.linkedkeeper.com/detail/blog.action?bid=1046</a></p>
</div><div class="tags"></div><div class="post-nav"><a href="/2017/11/11/java-synchronized/" class="pre">Java中Synchronized的用法</a><a href="/2017/11/09/nodejs-io/" class="next">Nodejs的事件驱动和异步I/O</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenCV/">OpenCV</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式/">嵌入式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/环境搭建/">环境搭建</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/行业/">行业</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.linkedkeeper.com/" title="张松然" target="_blank">张松然</a><ul></ul><a href="http://weishu.me/" title="维术" target="_blank">维术</a><ul></ul><a href="http://zhixinliu.com/" title="Zhixin Liu" target="_blank">Zhixin Liu</a><ul></ul><a href="http://www.ruanyifeng.com/" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.tianmaying.com/user/luoruici" title="Ricky" target="_blank">Ricky</a><ul></ul><a href="http://jeffdeng.me/" title="荒于嬉" target="_blank">荒于嬉</a><ul></ul><a href="https://kcaogen.com/blog" title="康草根" target="_blank">康草根</a><ul></ul><a href="http://13blog.site/" title="zhenfeng13" target="_blank">zhenfeng13</a><ul></ul><a href="http://binux.cn/" title="Binux" target="_blank">Binux</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Codes Online.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>