<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Netty核心类--缓冲区ByteBuf | Codes Online</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Netty核心类--缓冲区ByteBuf</h1><a id="logo" href="/.">Codes Online</a><p class="description">_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _enjoying</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Netty核心类--缓冲区ByteBuf</h1><div class="post-meta">May 5, 2018<span> | </span><span class="category"><a href="/categories/Netty/">Netty</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>本文主要包括以下内容：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）ByteBuf的三种类型：heapBuffer(堆缓冲区)、directBuffer(直接缓冲区)以及Composite Buffer(复合缓冲区)。</span><br><span class="line"></span><br><span class="line">2）ByteBuf的工作原理。</span><br><span class="line"></span><br><span class="line">3）ByteBuf与JDK中ByteBuffer的区别以及对比</span><br><span class="line"></span><br><span class="line">4）ByteBuf的引用计数器实现类AbstractReferenceCountedByteBuf分析。</span><br><span class="line"></span><br><span class="line">5）UnpooledHeapByteBuf 基于堆内存缓冲器的源码分析</span><br><span class="line"></span><br><span class="line">6）PooledDirectByteBuf 源码分析</span><br></pre></td></tr></table></figure></p>
<h4 id="1-netty中ByteBuf的优势"><a href="#1-netty中ByteBuf的优势" class="headerlink" title="1. netty中ByteBuf的优势"></a>1. netty中ByteBuf的优势</h4><p>缓冲区是不同的通道之间传递数据的中介，JDK中的ByteBuffer操作复杂，而且没有经过优化，所以在netty中实现了一个更加强大的缓冲区 ByteBuf 用于表示字节序列。ByteBuf在netty中是通过Channel传输数据的，新的设计解决了JDK中ByteBuffer中的一些问题。</p>
<p>netty中ByteBuf的缓冲区的优势： </p>
<p>（1）可以自定义缓冲区的类型；</p>
<p>（2）通过内置的复合缓冲类型实现零拷贝；</p>
<p>（3）不需要调用flip()函数切换读/写模式</p>
<p>（4）读取和写入的索引分开了，不像JDK中使用一个索引</p>
<p>（5）引用计数（referenceCounting的实现原理？）</p>
<p>（6） Pooling池</p>
<h4 id="2-netty中的ByteBuf的类型："><a href="#2-netty中的ByteBuf的类型：" class="headerlink" title="2.netty中的ByteBuf的类型："></a>2.netty中的ByteBuf的类型：</h4><p>JDK中的Buffer的类型 有heapBuffer和directBuffer两种类型，但是在netty中除了heap和direct类型外，还有composite Buffer(复合缓冲区类型)。</p>
<h4 id="1-Heap-Buffer-堆缓冲区"><a href="#1-Heap-Buffer-堆缓冲区" class="headerlink" title="(1)Heap Buffer 堆缓冲区"></a>(1)Heap Buffer 堆缓冲区</h4><p>这是最常用的类型，ByteBuf将数据存储在JVM的堆空间，通过将数据存储在数组中实现的。</p>
<p>1）堆缓冲的优点是：由于数据存储在JVM的堆中可以快速创建和快速释放，并且提供了数组的直接快速访问的方法。</p>
<p>2）堆缓冲缺点是：每次读写数据都要先将数据拷贝到直接缓冲区再进行传递。</p>
<h4 id="2-Direct-Buffer-直接缓冲区"><a href="#2-Direct-Buffer-直接缓冲区" class="headerlink" title="(2)Direct Buffer 直接缓冲区"></a>(2)Direct Buffer 直接缓冲区</h4><p>Direct Buffer在堆之外直接分配内存，直接缓冲区不会占用堆的容量。</p>
<p>（1）Direct Buffer的优点是：在使用Socket传递数据时性能很好，由于数据直接在内存中，不存在从JVM拷贝数据到直接缓冲区的过程，性能好。</p>
<p>（2）缺点是：因为Direct Buffer是直接在内存中，所以分配内存空间和释放内存比堆缓冲区更复杂和慢。</p>
<p>虽然netty的Direct Buffer有这个缺点，但是netty通过内存池来解决这个问题。直接缓冲池不支持数组访问数据，但可以通过间接的方式访问数据数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);   </span><br><span class="line"><span class="keyword">if</span>(!directBuf.hasArray())&#123;   </span><br><span class="line">    <span class="keyword">int</span> len = directBuf.readableBytes();   </span><br><span class="line">    <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[len];   </span><br><span class="line">    directBuf.getBytes(<span class="number">0</span>, arr);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是上面的操作太过复杂，所以在使用时，建议一般是用heap buffer。 </p>
<p>不过对于一些IO通信线程中读写缓冲时建议使用DirectByteBuffer，因为这涉及到大量的IO数据读写。对于后端的业务消息的编解码模块使用HeapByteBuffer。</p>
<h4 id="3-Composite-Buffer-复合缓冲区"><a href="#3-Composite-Buffer-复合缓冲区" class="headerlink" title="(3)Composite Buffer 复合缓冲区"></a>(3)Composite Buffer 复合缓冲区</h4><p>这个是netty特有的缓冲类型。复合缓冲区就类似于一个ByteBuf的组合视图，在这个视图里面我们可以创建不同的ByteBuf(可以是不同类型的)。 这样，复合缓冲区就类似于一个列表，我们可以动态的往里面添加和删除其中的ByteBuf，JDK里面的ByteBuffer就没有这样的功能。</p>
<p>Netty提供了Composite ByteBuf来处理复合缓冲区。例如：一条消息由Header和Body组成，将header和body组装成一条消息发送出去。下图显示了Composite ByteBuf组成header和body： </p>
<p><img src="/2018/05/05/netty-bytebuf/1.jpeg" alt=""></p>
<p>如果使用的是JDK的ByteBuffer就不能简单的实现，只能通过创建数组或则新的ByteBuffer，再将里面的内容复制到新的ByteBuffer中，下面给出了一个CompositeByteBuf的使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合缓冲区</span></span><br><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();   </span><br><span class="line"><span class="comment">//堆缓冲区</span></span><br><span class="line">ByteBuf heapBuf = Unpooled.buffer(<span class="number">8</span>);   </span><br><span class="line"><span class="comment">//直接缓冲区</span></span><br><span class="line">ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);   </span><br><span class="line"><span class="comment">//添加ByteBuf到CompositeByteBuf   </span></span><br><span class="line">compBuf.addComponents(heapBuf, directBuf);   </span><br><span class="line"><span class="comment">//删除第一个ByteBuf   </span></span><br><span class="line">compBuf.removeComponent(<span class="number">0</span>);   </span><br><span class="line">Iterator&lt;ByteBuf&gt; iter = compBuf.iterator();   </span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;   </span><br><span class="line">    System.out.println(iter.next().toString());   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组访问数据      </span></span><br><span class="line"><span class="keyword">if</span>(!compBuf.hasArray())&#123;   </span><br><span class="line">    <span class="keyword">int</span> len = compBuf.readableBytes();   </span><br><span class="line">    <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[len];   </span><br><span class="line">    compBuf.getBytes(<span class="number">0</span>, arr);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-ByteBuf是如何工作的："><a href="#3-ByteBuf是如何工作的：" class="headerlink" title="3.ByteBuf是如何工作的："></a>3.ByteBuf是如何工作的：</h4><p>ByteBuf是一个抽象类，内部全部是抽象的函数接口，AbstractByteBuf这个抽象类基本实现了ByteBuf，下面我们通过分析AbstractByteBuf里面的实现来分析ByteBuf的工作原理。</p>
<p>ByteBuf都是基于字节序列的，类似于一个字节数组。在AbstractByteBuf里面定义了下面5个变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">int</span> readerIndex; <span class="comment">//读索引</span></span><br><span class="line"><span class="keyword">int</span> writerIndex; <span class="comment">//写索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;<span class="comment">//标记读索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;<span class="comment">//标记写索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;<span class="comment">//缓冲区的最大容量</span></span><br></pre></td></tr></table></figure></p>
<p>ByteBuf 与JDK中的 ByteBuffer 的最大区别之一就是： </p>
<p>（1）netty的ByteBuf采用了读/写索引分离，一个初始化的ByteBuf的readerIndex和writerIndex都处于0位置。 </p>
<p>（2）当读索引和写索引处于同一位置时，如果我们继续读取，就会抛出异常IndexOutOfBoundsException。 </p>
<p>（3）对于ByteBuf的任何读写操作都会分别单独的维护读索引和写索引。maxCapacity最大容量默认的限制就是Integer.MAX_VALUE。</p>
<h4 id="1-随机访问索引"><a href="#1-随机访问索引" class="headerlink" title="1.随机访问索引"></a>1.随机访问索引</h4><p>ByteBuf提供读/写索引，从0开始的索引，第一个字节索引是0，最后一个字节的索引是capacity-1，下面给出一个示例遍历ByteBuf的字节：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个16字节的buffer,这里默认是创建heap buffer</span></span><br><span class="line">    ByteBuf buf = Unpooled.buffer(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//写数据到buffer</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)&#123;</span><br><span class="line">        buf.writeByte(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buf.capacity(); i++)&#123;</span><br><span class="line">        System.out.print(buf.getByte(i)+<span class="string">", "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***output:</span></span><br><span class="line"><span class="comment">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>这里有一点需要注意的是：通过索引访问byte时不会改变真实的读索引和写索引，我们可以通过ByteBuf的readerIndex()或则writerIndex()函数来分别推进读索引和写索引。</p>
<p>下面分别看看writeByte()和readByte()的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ensureAccessible();<span class="comment">//检验是否可以写入</span></span><br><span class="line">    ensureWritable0(<span class="number">1</span>);</span><br><span class="line">    _setByte(writerIndex++, value);<span class="comment">//这里写索引自增了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkReadableBytes0(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = readerIndex;</span><br><span class="line">    <span class="keyword">byte</span> b = _getByte(i);</span><br><span class="line">    readerIndex = i + <span class="number">1</span>;<span class="comment">//这里读索引自增了</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="读写索引的分区"><a href="#读写索引的分区" class="headerlink" title="读写索引的分区"></a>读写索引的分区</h4><p>ByteBuf提供了两个索引指针变量来支持读写操作，读操作使用的是readerIndex()，写操作使用的是writerIndex()。这与JDK中的ByteBuffer有很大不同，ByteBuffer只有一个方法来设置索引，而且需要使用flip()方法来切换读写操作，这就很麻烦了。</p>
<p>ByteBuf一定满足的是：0&lt;=readerIndex&lt;=writerIndex&lt;=capacity<br>下图显示了一个ByteBuf中可以被划分为三个区域： </p>
<p><img src="/2018/05/05/netty-bytebuf/2.jpeg" alt=""></p>
<h4 id="Discardable-bytes-回收字节"><a href="#Discardable-bytes-回收字节" class="headerlink" title="Discardable bytes 回收字节"></a>Discardable bytes 回收字节</h4><p>对于已经读过的字节，我们需要回收，通过调用ByteBuf.discardReadBytes()来回收已经读取过的字节，discardReadBytes()将回收从索引0到readerIndex之间的字节。调用discardReadBytes()方法之后会变成如下图所示; </p>
<p><img src="/2018/05/05/netty-bytebuf/3.jpeg" alt=""></p>
<p>很明显discardReadBytes()函数很可能会导致内存的复制，它需要移动ByteBuf中可读字节到开始位置，所以该操作会导致时间开销。说白了也就是时间换空间。</p>
<h4 id="可读可写字节"><a href="#可读可写字节" class="headerlink" title="可读可写字节"></a>可读可写字节</h4><p>当我们读取字节的时候，一般要先判断buffer中是否有字节可读，这时候可以调用isReadable()函数来判断：源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writerIndex &gt; readerIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实也就是判断 读索引是否小于写索引 来判断是否还可以读取字节。在判断是否可写时也是判断写索引是否小于最大容量来判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> capacity() &gt; writerIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="清除缓冲区"><a href="#清除缓冲区" class="headerlink" title="清除缓冲区"></a>清除缓冲区</h4><p>清除ByteBuf来说，有两种形式，第一种是clear()函数：源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readerIndex = writerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显这种方式并没有真实的清除缓冲区中的数据，而只是把读/写索引值重新都置为0了，这与discardReadBytes()方法有很大的区别。</p>
<h4 id="标记Mark和重置reset"><a href="#标记Mark和重置reset" class="headerlink" title="标记Mark和重置reset"></a>标记Mark和重置reset</h4><p>从源码可知，每个ByteBuf有两个标注索引，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;<span class="comment">//标记读索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;<span class="comment">//标记写索引</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过重置方法返回上次标记的索引的位置。</p>
<h4 id="衍生的缓冲区"><a href="#衍生的缓冲区" class="headerlink" title="衍生的缓冲区"></a>衍生的缓冲区</h4><p>调用duplicate()、slice()、slice(int index, int length)等方法可以创建一个现有缓冲区的视图（现有缓冲区与原有缓冲区是指向相同内存）。衍生的缓冲区有独立的readerIndex和writerIndex和标记索引。如果需要现有的缓冲区的全新副本，可以使用copy()获得。</p>
<h4 id="4-创建ByteBuf的方法"><a href="#4-创建ByteBuf的方法" class="headerlink" title="4. 创建ByteBuf的方法"></a>4. 创建ByteBuf的方法</h4><p>前面我们也讲过了，ByteBuf主要有三种类型，heap、direct和composite类型，下面介绍创建这三种Buffer的方法：</p>
<p>（1）通过ByteBufAllocator这个接口来创建ByteBuf，这个接口可以创建上面的三种Buffer，一般都是通过channel的alloc()接口获取。</p>
<p>（2）通过Unpooled类里面的静态方法，创建Buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();           </span><br><span class="line">ByteBuf heapBuf = Unpooled.buffer(<span class="number">8</span>);            </span><br><span class="line">ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<p>还有一点就是，ByteBuf里面的数据都是保存在字节数组里面的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] array;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-ByteBuf与ByteBuffer的对比："><a href="#5-ByteBuf与ByteBuffer的对比：" class="headerlink" title="5. ByteBuf与ByteBuffer的对比："></a>5. ByteBuf与ByteBuffer的对比：</h4><p>先来说说ByteBuffer的缺点：</p>
<p>（1）下面是NIO中ByteBuffer存储字节的字节数组的定义，我们可以知道ByteBuffer的字节数组是被定义成final的，也就是长度固定。一旦分配完成就不能扩容和收缩，灵活性低，而且当待存储的对象字节很大可能出现数组越界，用户使用起来稍不小心就可能出现异常。如果要避免越界，在存储之前就要只要需求字节大小，如果buffer的空间不够就创建一个更大的新的ByteBuffer，再将之前的Buffer中数据复制过去，这样的效率是奇低的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;<span class="comment">// Non-null only for heap buffers</span></span><br></pre></td></tr></table></figure>
<p>（2）ByteBuffer只用了一个position指针来标识位置，读写模式切换时需要调用flip()函数和rewind()函数，使用起来需要非常小心，不然很容易出错误。</p>
<p>下面说说对应的ByteBuf的优点： </p>
<p>（1）ByteBuf是吸取ByteBuffer的缺点之后重新设计，存储字节的数组是动态的，最大是Integer.MAX_VALUE。这里的动态性存在write操作中，write时得知buffer不够时，会自动扩容。</p>
<p>（2） ByteBuf的读写索引分离，使用起来十分方便。此外ByteBuf还新增了很多方便实用的功能。</p>
<h4 id="6-ByteBuf的引用计数类AbstractReferenceCountedByteBuf分析"><a href="#6-ByteBuf的引用计数类AbstractReferenceCountedByteBuf分析" class="headerlink" title="6. ByteBuf的引用计数类AbstractReferenceCountedByteBuf分析"></a>6. ByteBuf的引用计数类AbstractReferenceCountedByteBuf分析</h4><p>看类名我们就可以知道，该类主要是对引用进行计数，有点类似于JVM中判断对象是否可回收的引用计数算法。这个类主要是根据ByteBuf的引用次数判断ByteBuf是否可被自动回收。下面来看看源码：</p>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; refCntUpdater;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态代码段初始化refCntUpdater</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; updater =</span><br><span class="line">            PlatformDependent.newAtomicIntegerFieldUpdater(AbstractReferenceCountedByteBuf.class, <span class="string">"refCnt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (updater == <span class="keyword">null</span>) &#123;</span><br><span class="line">        updater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, <span class="string">"refCnt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    refCntUpdater = updater;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> refCnt = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>首先我们能看到refCntUpdater这个变量，这是一个原子变量类AtomicIntegerFieldUpdater，她是一个静态变量，而且是在static代码段里面实例化的，这说明这个类是单例的。这个类的主要作用是以原子的方式对成员变量进行更新操作以实现线程安全（这里线程安全的保证也就是CAS+volatile）。</p>
<p>然后是定义了refCnt变量，用于跟踪对象的引用次数，使用volatile修饰解决原子变量可视性问题。</p>
<h4 id="对象引用计数器"><a href="#对象引用计数器" class="headerlink" title="对象引用计数器"></a>对象引用计数器</h4><p>那么，对对象的引用计数与释放是怎么实现的呢？核心就是两个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//计数加1</span><br><span class="line">retain();</span><br><span class="line"></span><br><span class="line">//计数减一</span><br><span class="line">release();</span><br></pre></td></tr></table></figure></p>
<p>下面分析这两个函数源码：<br>每调用一次retain()函数一次，引用计数器就会加一，由于可能存在多线程并发使用的情景，所以必须保证累加操作是线程安全的，那么是怎么保证的呢？我们来看一下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retain0(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">retain</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> retain0(checkPositive(increment, <span class="string">"increment"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 最后都是调用这个函数。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ByteBuf <span class="title">retain0</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> refCnt = <span class="keyword">this</span>.refCnt;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> nextCnt = refCnt + increment;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.</span></span><br><span class="line">        <span class="keyword">if</span> (nextCnt &lt;= increment) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(refCnt, increment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (refCntUpdater.compareAndSet(<span class="keyword">this</span>, refCnt, nextCnt)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在retain0()函数中， 通过for(;;)来实现了自旋锁。通过自旋来对引用计数器refCnt执行加1操作。这里的加一操作是通过原子变量refCntUpdater的compareAndSet(this, refCnt, nextCnt)方法实现的，这个通过硬件级别的CAS保证了原子性，如果修改失败了就会不停的自旋，直到修改成功为止。</p>
<p>下面再看看释放的过程：release()函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">release0</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> refCnt = <span class="keyword">this</span>.refCnt;</span><br><span class="line">        <span class="keyword">if</span> (refCnt &lt; decrement) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(refCnt, -decrement);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (refCntUpdater.compareAndSet(<span class="keyword">this</span>, refCnt, refCnt - decrement)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (refCnt == decrement) &#123;</span><br><span class="line">                deallocate();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里基本和retain()函数一样，也是通过自旋和CAS保证执行的正确的将计数器减一。这里需要注意的是当refCnt == decrement 也就是引用对象不可达时，就需要调用deallocate();方法来释放ByteBuf对象。</p>
<h4 id="7-UnpooledHeapByteBuf源码分析"><a href="#7-UnpooledHeapByteBuf源码分析" class="headerlink" title="7. UnpooledHeapByteBuf源码分析"></a>7. UnpooledHeapByteBuf源码分析</h4><p>从类名就可以知道UnpooledHeapByteBuf 是基于堆内存的字节缓冲区，没有基于对象池实现，这意味着每次的IO读写都会创建一个UnpooledHeapByteBuf对象，会造成一定的性能影响，但是也不容易出现内存管理的问题。</p>
<p><img src="/2018/05/05/netty-bytebuf/4.jpeg" alt=""></p>
<h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><p>有三个成员变量，各自的含义见注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓冲区分配器，用于UnpooledHeapByteBuf的内存分配。在UnpooledHeapByteBuf构造器中实例化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBufAllocator alloc;</span><br><span class="line"><span class="comment">//字节数组作为缓冲区</span></span><br><span class="line"><span class="keyword">byte</span>[] array;</span><br><span class="line"><span class="comment">//实现ByteBuf与NIO中ByteBuffer的转换</span></span><br><span class="line"><span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br></pre></td></tr></table></figure></p>
<h4 id="动态扩展缓冲区"><a href="#动态扩展缓冲区" class="headerlink" title="动态扩展缓冲区"></a>动态扩展缓冲区</h4><p>在说道AbstractByteBuf的时候，ByteBuf是可以自动扩展缓冲区大小的，这里我们分析一下在UnpooledHeapByteBuf中是怎么实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span> || newCapacity &gt; maxCapacity()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"newCapacity: "</span> + newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = array.length;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; oldCapacity) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newArray = <span class="keyword">new</span> <span class="keyword">byte</span>[newCapacity];</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, array.length);</span><br><span class="line">        setArray(newArray);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newCapacity &lt; oldCapacity) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newArray = <span class="keyword">new</span> <span class="keyword">byte</span>[newCapacity];</span><br><span class="line">        <span class="keyword">int</span> readerIndex = readerIndex();</span><br><span class="line">        <span class="keyword">if</span> (readerIndex &lt; newCapacity) &#123;</span><br><span class="line">            <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line">            <span class="keyword">if</span> (writerIndex &gt; newCapacity) &#123;</span><br><span class="line">                writerIndex(writerIndex = newCapacity);</span><br><span class="line">            &#125;</span><br><span class="line">            System.arraycopy(array, readerIndex, newArray, readerIndex, writerIndex - readerIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setIndex(newCapacity, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        setArray(newArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面的实现并不复杂：</p>
<p>（1）首先获取原本的容量oldCapacity；</p>
<p>（2）如果新需求容量大于oldCapacity，以新的容量newCapacity创建字节数组，将原来的字节数组内容通过调用System.arraycopy(array, 0, newArray, 0, array.length);复制过去，并将新的字节数组设为ByteBuf的字节数组。</p>
<p>（3）如果新需求容量小于oldCapacity就不需要动态扩展，但是需要截取出一段新缓冲区。</p>
<h4 id="8-PooledDirectByteBuf-内存池原理分析"><a href="#8-PooledDirectByteBuf-内存池原理分析" class="headerlink" title="8. PooledDirectByteBuf 内存池原理分析"></a>8. PooledDirectByteBuf 内存池原理分析</h4><p>PooledDirectByteBuf基于内存池实现的，具体的内存池的实现原理，比较复杂，我没分析清楚，具体的只知道，内存池就是一片提前申请的内存，当需要ByteBuf的时候，就从内存池中申请一片内存，这样效率比较高。</p>
<p>PooledDirectByteBuf和UnPooledDirectByteBuf基本一样，唯一不同的就是内存分配策略。</p>
<h4 id="创建字节缓冲区实例"><a href="#创建字节缓冲区实例" class="headerlink" title="创建字节缓冲区实例"></a>创建字节缓冲区实例</h4><p>由于PooledDirectByteBuf基于内存池实现的，所以不能通过new关键字直接实例化一个对象，而是直接从内存池中获取，然后设置引用计数器的值。看下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PooledDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">    buf.reuse(maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过RECYCLER对象的get()函数从内存池获取PooledDirectByteBuf对象。然后在buf.reuse(maxCapacity); 函数里面设置引用计数器为1。</p>
<p>来源：<a href="https://blog.csdn.net/u010853261/article/details/53690780" target="_blank" rel="external">https://blog.csdn.net/u010853261/article/details/53690780</a></p>
</div><div class="tags"></div><div class="post-nav"><a href="/2018/05/05/java-nio/" class="pre">JAVA IO 以及 NIO 理解</a><a href="/2018/04/30/browser-security/" class="next">浏览器的同源策略</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenCV/">OpenCV</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式/">嵌入式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/环境搭建/">环境搭建</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/行业/">行业</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.linkedkeeper.com/" title="张松然" target="_blank">张松然</a><ul></ul><a href="http://weishu.me/" title="维术" target="_blank">维术</a><ul></ul><a href="http://zhixinliu.com/" title="Zhixin Liu" target="_blank">Zhixin Liu</a><ul></ul><a href="http://www.ruanyifeng.com/" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.tianmaying.com/user/luoruici" title="Ricky" target="_blank">Ricky</a><ul></ul><a href="http://jeffdeng.me/" title="荒于嬉" target="_blank">荒于嬉</a><ul></ul><a href="https://kcaogen.com/blog" title="康草根" target="_blank">康草根</a><ul></ul><a href="http://13blog.site/" title="zhenfeng13" target="_blank">zhenfeng13</a><ul></ul><a href="http://binux.cn/" title="Binux" target="_blank">Binux</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Codes Online.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>